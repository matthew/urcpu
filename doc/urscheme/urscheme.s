        movl %esp, (stack_bottom)
report_error:
        call ensure_string
        lea 8(%eax), %ebx
        push %ebx
        movl 4(%eax), %eax
        # fd 2: stderr
        movl $2, %ebx
        movl %eax, %edx
        pop %ecx
        movl $4, %eax
        int $0x80
        movl $1, %ebx
        movl $1, %eax
        int $0x80
package_up_variadic_args:
        # we have %ebp pointing at args, %edx with count
        # saved %ebp in %eax.  zero-iterations case: return nil
        push %eax
        movl $2 + 256<<2, %eax
variadic_loop:
        dec %edx
        # fucking dec doesn't update carry flag, so jump if negative
        js variadic_loop_end
        # calling cons clobbers registers, so push %edx
        push %edx
        # now push args for cons
        push %eax
        push 4(%ebp,%edx,4)
        # give cons its argument count
        movl $2, %edx
        call cons
        # now the args are popped and we have new list in %eax
        pop %edx
        jmp variadic_loop
variadic_loop_end:
        # now we pretend procedure was called with the list as first arg
        movl %eax, (%ebp)
        # restore %eax to value on entry to package_up_variadic_args
        pop %eax
        ret
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
k_5:
        .long 0xbabb1e
        .long 33
        .ascii "error: wrong number of arguments\n"
        .text
argument_count_wrong:
        movl $k_5, %eax
        jmp report_error
return_true:
        movl $2 + 257<<2, %eax
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
return_false:
        movl $2 + 258<<2, %eax
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .section .data
_procedureP_2:
        .long _procedureP_1
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_procedureP_1:
        .long 0xca11ab1e
        .long _procedureP_3
        .long 0
        .text
        .type _procedureP_3, @function
_procedureP_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        push %eax
        movl 0(%ebp), %eax
        # test whether %eax has magic: 0xca11ab1e
        # first, ensure that it's a pointer, not something unboxed
        test $3, %eax
        jnz return_false
        # now, test its magic number
        cmpl $0xca11ab1e, (%eax)
        jnz return_false
        jmp return_true
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _procedureP_3, .-_procedureP_3
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_procedureP_4:
        .long 0xbabb1e
        .long 23
        .ascii "error: not a procedure\n"
        .text
k_1:
        movl $_procedureP_4, %eax
        jmp report_error
ensure_procedure:
        # test whether %eax has magic: 0xca11ab1e
        # first, ensure that it's a pointer, not something unboxed
        test $3, %eax
        jnz k_1
        # now, test its magic number
        cmpl $0xca11ab1e, (%eax)
        jnz k_1
        ret
        .bss
the_arena:
        .space 128*1048576
end_arena:
        .section .data
arena_pointer:
        .long the_arena
        .text
        .section .data
stack_bottom:
        .long 0
        .text
        .section .data
_stringP_2:
        .long _stringP_1
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_stringP_1:
        .long 0xca11ab1e
        .long _stringP_3
        .long 0
        .text
        .type _stringP_3, @function
_stringP_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        push %eax
        movl 0(%ebp), %eax
        # test whether %eax has magic: 0xbabb1e
        # first, ensure that it's a pointer, not something unboxed
        test $3, %eax
        jnz return_false
        # now, test its magic number
        cmpl $0xbabb1e, (%eax)
        jnz return_false
        jmp return_true
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _stringP_3, .-_stringP_3
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_stringP_4:
        .long 0xbabb1e
        .long 20
        .ascii "error: not a string\n"
        .text
k_2:
        movl $_stringP_4, %eax
        jmp report_error
ensure_string:
        # test whether %eax has magic: 0xbabb1e
        # first, ensure that it's a pointer, not something unboxed
        test $3, %eax
        jnz k_2
        # now, test its magic number
        cmpl $0xbabb1e, (%eax)
        jnz k_2
        ret
        .section .data
_make_string_2:
        .long _make_string_1
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_make_string_1:
        .long 0xca11ab1e
        .long _make_string_3
        .long 0
        .text
        .type _make_string_3, @function
_make_string_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        push %eax
        movl 0(%ebp), %eax
        call ensure_integer
        # we need 8 bytes more than the string length
        sar %eax
        sar %eax
        add $8, %eax
        # code to allocate memory; untagged number of bytes in %eax
        add $3, %eax
        and $~3, %eax
        movl (arena_pointer), %ebx
        add %eax, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        movl %ebx, %eax
        # now %eax points to newly allocated memory
        movl $0xbabb1e, (%eax)
        movl %eax, %ebx
        # push address to return, get string length and store it
        push %eax
        movl 0(%ebp), %eax
        sar %eax
        sar %eax
        movl %eax, 4(%ebx)
        # fill string with Xes
        lea 8(%ebx), %edi
        movl %eax, %ecx
        movl $'X, %eax
        rep stosb
        # now pop and return the address
        pop %eax
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _make_string_3, .-_make_string_3
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_make_string_4:
        .long 0xbabb1e
        .long 33
        .ascii "error: array index out of bounds\n"
        .text
index_out_of_bounds:
        movl $_make_string_4, %eax
        jmp report_error
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_make_string_5:
        .long 0xbabb1e
        .long 25
        .ascii "error: the arena is full\n"
        .text
arena_full:
        movl $_make_string_5, %eax
        jmp report_error
        .section .data
_string_setBang_2:
        .long _string_setBang_1
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_string_setBang_1:
        .long 0xca11ab1e
        .long _string_setBang_3
        .long 0
        .text
        .type _string_setBang_3, @function
_string_setBang_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $3, %edx
        jnz argument_count_wrong
        # string-set! primitive procedure
        push %eax
        movl 0(%ebp), %eax
        call ensure_string
        lea 8(%eax), %ebx
        push %ebx
        movl 4(%eax), %eax
        push %eax
        movl 4(%ebp), %eax
        # verify that tagged %eax is in [0, untagged NOS)
        call ensure_integer
        sar %eax
        sar %eax
        # set flags by (unsigned array index - array max)
        cmpl (%esp), %eax
        # now we expect unsigned overflow, i.e. borrow/carry.
        jnb index_out_of_bounds
        # now discard both the index and the bound
        pop %eax
        pop %eax
        push %eax
        movl 4(%ebp), %eax
        sar %eax
        sar %eax
        movl %eax, %edi
        # now retrieve the address of string bytes from the stack
        pop %eax
        movl %eax, %ebx
        push %eax
        movl 8(%ebp), %eax
        test $1, %eax
        jnz not_a_character
        test $2, %eax
        je not_a_character
        cmpl $2 + 256<<2, %eax
        jnb not_a_character
        sar %eax
        sar %eax
        movb %al, (%ebx,%edi,1)
        # discard the character and base address
        pop %eax
        pop %eax
        # but we need a return value...
        push %eax
        movl 0(%ebp), %eax
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _string_setBang_3, .-_string_setBang_3
        .section .data
_string_ref_2:
        .long _string_ref_1
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_string_ref_1:
        .long 0xca11ab1e
        .long _string_ref_3
        .long 0
        .text
        .type _string_ref_3, @function
_string_ref_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $2, %edx
        jnz argument_count_wrong
        # string-ref primitive procedure
        push %eax
        movl 0(%ebp), %eax
        call ensure_string
        lea 8(%eax), %ebx
        push %ebx
        movl 4(%eax), %eax
        push %eax
        movl 4(%ebp), %eax
        # verify that tagged %eax is in [0, untagged NOS)
        call ensure_integer
        sar %eax
        sar %eax
        # set flags by (unsigned array index - array max)
        cmpl (%esp), %eax
        # now we expect unsigned overflow, i.e. borrow/carry.
        jnb index_out_of_bounds
        # now discard both the index and the bound
        pop %eax
        pop %eax
        push %eax
        movl 4(%ebp), %eax
        sar %eax
        sar %eax
        # get base address of string data from stack
        pop %ebx
        movzbl (%eax,%ebx,1), %eax
        sal %eax
        inc %eax
        sal %eax
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _string_ref_3, .-_string_ref_3
        .section .data
_pairP_2:
        .long _pairP_1
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_pairP_1:
        .long 0xca11ab1e
        .long _pairP_3
        .long 0
        .text
        .type _pairP_3, @function
_pairP_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        push %eax
        movl 0(%ebp), %eax
        # test whether %eax has magic: 0x2ce11ed
        # first, ensure that it's a pointer, not something unboxed
        test $3, %eax
        jnz return_false
        # now, test its magic number
        cmpl $0x2ce11ed, (%eax)
        jnz return_false
        jmp return_true
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _pairP_3, .-_pairP_3
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_pairP_4:
        .long 0xbabb1e
        .long 18
        .ascii "error: not a cons\n"
        .text
k_3:
        movl $_pairP_4, %eax
        jmp report_error
ensure_cons:
        # test whether %eax has magic: 0x2ce11ed
        # first, ensure that it's a pointer, not something unboxed
        test $3, %eax
        jnz k_3
        # now, test its magic number
        cmpl $0x2ce11ed, (%eax)
        jnz k_3
        ret
        .text
cons:
        .section .data
_cons_2:
        .long _cons_1
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_cons_1:
        .long 0xca11ab1e
        .long _cons_3
        .long 0
        .text
        .type _cons_3, @function
_cons_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $2, %edx
        jnz argument_count_wrong
        # allocate bytes: 12
        push %eax
        movl (arena_pointer), %eax
        add $12, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x2ce11ed, (%eax)
        movl %eax, %ebx
        push %eax
        movl 0(%ebp), %eax
        movl %eax, 4(%ebx)
        pop %eax
        push %eax
        movl 4(%ebp), %eax
        movl %eax, 8(%ebx)
        pop %eax
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _cons_3, .-_cons_3
        .section .data
_symbolP_2:
        .long _symbolP_1
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_symbolP_1:
        .long 0xca11ab1e
        .long _symbolP_3
        .long 0
        .text
        .type _symbolP_3, @function
_symbolP_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        push %eax
        movl 0(%ebp), %eax
        # test whether %eax has magic: 0x1abe1
        # first, ensure that it's a pointer, not something unboxed
        test $3, %eax
        jnz return_false
        # now, test its magic number
        cmpl $0x1abe1, (%eax)
        jnz return_false
        jmp return_true
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _symbolP_3, .-_symbolP_3
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_symbolP_4:
        .long 0xbabb1e
        .long 20
        .ascii "error: not a symbol\n"
        .text
k_4:
        movl $_symbolP_4, %eax
        jmp report_error
ensure_symbol:
        # test whether %eax has magic: 0x1abe1
        # first, ensure that it's a pointer, not something unboxed
        test $3, %eax
        jnz k_4
        # now, test its magic number
        cmpl $0x1abe1, (%eax)
        jnz k_4
        ret
        .section .data
_string_Gtsymbol_2:
        .long _string_Gtsymbol_1
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_string_Gtsymbol_1:
        .long 0xca11ab1e
        .long _string_Gtsymbol_3
        .long 0
        .text
        .type _string_Gtsymbol_3, @function
_string_Gtsymbol_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        push %eax
        movl 0(%ebp), %eax
        call ensure_string
        lea 8(%eax), %ebx
        push %ebx
        movl 4(%eax), %eax
        # now string length is in %eax and string data pointer at (%esp)
        movl (symbol_table), %ebx
string_to_symbol_loop:
        test %ebx, %ebx
        je intern_new_symbol
        # fetch pointer to string value
        movl 4(%ebx), %edx
        # fetch string length
        movl 4(%edx), %ecx
        cmpl %ecx, %eax
        jnz wrong_symbol_thanks_for_playing
        # fetch string pointer
        lea 8(%edx), %esi
        movl (%esp), %edi
        # compare strings at [esi:esi+ecx] and [edi:edi+ecx]
        repe cmpsb
        jnz wrong_symbol_thanks_for_playing
        # found the right symbol
        pop %eax
        movl %ebx, %eax
        jmp string_symbol_return
wrong_symbol_thanks_for_playing:
        # get address of next symbol
        movl 8(%ebx), %ebx
        jmp string_to_symbol_loop
intern_new_symbol:
        # get string pointer
        push %eax
        movl 0(%ebp), %eax
        # symbols are 12 bytes
        # allocate bytes: 12
        push %eax
        movl (arena_pointer), %eax
        add $12, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1abe1, (%eax)
        # store string pointer for new symbol
        movl (%esp), %ebx
        movl %ebx, 4(%eax)
        movl (symbol_table), %ebx
        movl %ebx, 8(%eax)
        movl %eax, (symbol_table)
string_symbol_return:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _string_Gtsymbol_3, .-_string_Gtsymbol_3
        .section .data
_display_2:
        .long _display_1
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_display_1:
        .long 0xca11ab1e
        .long _display_3
        .long 0
        .text
        .type _display_3, @function
_display_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        push %eax
        movl 0(%ebp), %eax
        call ensure_string
        lea 8(%eax), %ebx
        push %ebx
        movl 4(%eax), %eax
        # fd 1: stdout
        movl $1, %ebx
        movl %eax, %edx
        pop %ecx
        movl $4, %eax
        int $0x80
        movl $2 + 256<<2, %eax
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _display_3, .-_display_3
        .section .data
_current_input_port_2:
        .long _current_input_port_1
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_current_input_port_1:
        .long 0xca11ab1e
        .long _current_input_port_3
        .long 0
        .text
        .type _current_input_port_3, @function
_current_input_port_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $0, %edx
        jnz argument_count_wrong
        # We don't have ports right now, so return nil
        push %eax
        movl $2 + 256<<2, %eax
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _current_input_port_3, .-_current_input_port_3
        .section .data
_read_char_2:
        .long _read_char_1
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_char_1:
        .long 0xca11ab1e
        .long _read_char_3
        .long 0
        .text
        .type _read_char_3, @function
_read_char_3:
        # make space for variadic argument list
        pop %ebx
        push %ebx
        push %ebx
        # push desired %esp on return
        lea 8(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        call package_up_variadic_args
        # We don't care about our args.
        # (maybe somebody passed us (current-input-port))
        .section .bss
read_char_buffer:
        .space 1024
read_char_buffer_end:
        .section .data
read_char_pointer:
        .long read_char_buffer
read_char_buffer_fill_pointer:
        .long read_char_buffer
        .text
read_char:
        movl (read_char_pointer), %eax
        cmpl (read_char_buffer_fill_pointer), %eax
        jnz return_char_from_buffer
        cmpl $read_char_buffer_end, %eax
        jnz call_read_syscall
        movl $read_char_buffer, %eax
        movl %eax, (read_char_pointer)
        movl %eax, (read_char_buffer_fill_pointer)
call_read_syscall:
        # __NR_read; see asm-i486/unistd.h
        movl $3, %eax
        # stdin
        movl $0, %ebx
        movl (read_char_buffer_fill_pointer), %ecx
        movl $read_char_buffer_end, %edx
        sub (read_char_buffer_fill_pointer), %edx
        int $0x80
        test %eax, %eax
        je return_eof
        jl report_read_error
        add %eax, (read_char_buffer_fill_pointer)
        movl (read_char_pointer), %eax
return_char_from_buffer:
        movl %eax, %ebx
        inc %ebx
        movl %ebx, (read_char_pointer)
        movzbl (%eax), %eax
        sal %eax
        inc %eax
        sal %eax
        jmp read_char_return
return_eof:
        movl $2 + 259<<2, %eax
read_char_return:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _read_char_3, .-_read_char_3
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_char_4:
        .long 0xbabb1e
        .long 27
        .ascii "error: read error on stdin\n"
        .text
report_read_error:
        movl $_read_char_4, %eax
        jmp report_error
        .section .data
_display_stderr_2:
        .long _display_stderr_1
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_display_stderr_1:
        .long 0xca11ab1e
        .long _display_stderr_3
        .long 0
        .text
        .type _display_stderr_3, @function
_display_stderr_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        push %eax
        movl 0(%ebp), %eax
        call ensure_string
        lea 8(%eax), %ebx
        push %ebx
        movl 4(%eax), %eax
        # fd 2: stderr
        movl $2, %ebx
        movl %eax, %edx
        pop %ecx
        movl $4, %eax
        int $0x80
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _display_stderr_3, .-_display_stderr_3
        .section .data
_exit_2:
        .long _exit_1
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_exit_1:
        .long 0xca11ab1e
        .long _exit_3
        .long 0
        .text
        .type _exit_3, @function
_exit_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        push %eax
        movl 0(%ebp), %eax
        call ensure_integer
        sar %eax
        sar %eax
        movl %eax, %ebx
        movl $1, %eax
        int $0x80
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _exit_3, .-_exit_3
        .section .data
_integerP_2:
        .long _integerP_1
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_integerP_1:
        .long 0xca11ab1e
        .long _integerP_3
        .long 0
        .text
        .type _integerP_3, @function
_integerP_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        push %eax
        movl 0(%ebp), %eax
        and $3, %eax
        cmpl $1, %eax
        je return_true
        jmp return_false
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _integerP_3, .-_integerP_3
ensure_integer:
        test $1, %eax
        je not_an_integer
        test $2, %eax
        jnz not_an_integer
        ret
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_integerP_4:
        .long 0xbabb1e
        .long 22
        .ascii "error: not an integer\n"
        .text
not_an_integer:
        movl $_integerP_4, %eax
        jmp report_error
        .section .data
_remainder_2:
        .long _remainder_1
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_remainder_1:
        .long 0xca11ab1e
        .long _remainder_3
        .long 0
        .text
        .type _remainder_3, @function
_remainder_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $2, %edx
        jnz argument_count_wrong
        push %eax
        movl 4(%ebp), %eax
        call ensure_integer
        # fetch dividend second; idiv wants it in %eax
        push %eax
        movl 0(%ebp), %eax
        call ensure_integer
        # zero out the tag
        dec %eax
        pop %ebx
        dec %ebx
        # zero the top half of the dividend
        sub %edx, %edx
        idiv %ebx
        # remainder (<<2) is in %edx
        movl %edx, %eax
        # put the tag back
        inc %eax
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _remainder_3, .-_remainder_3
        .section .data
_quotient_2:
        .long _quotient_1
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_quotient_1:
        .long 0xca11ab1e
        .long _quotient_3
        .long 0
        .text
        .type _quotient_3, @function
_quotient_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $2, %edx
        jnz argument_count_wrong
        push %eax
        movl 4(%ebp), %eax
        call ensure_integer
        # fetch dividend second; idiv wants it in %eax
        push %eax
        movl 0(%ebp), %eax
        call ensure_integer
        # zero out the tag
        dec %eax
        pop %ebx
        dec %ebx
        # zero the top half of the dividend
        sub %edx, %edx
        idiv %ebx
        sal %eax
        sal %eax
        inc %eax
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _quotient_3, .-_quotient_3
        .section .data
_Lt_2:
        .long _Lt_1
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_Lt_1:
        .long 0xca11ab1e
        .long _Lt_3
        .long 0
        .text
        .type _Lt_3, @function
_Lt_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $2, %edx
        jnz argument_count_wrong
        # procedure <: (< x y) returns true if x < y
        push %eax
        movl 0(%ebp), %eax
        call ensure_integer
        push %eax
        movl 4(%ebp), %eax
        call ensure_integer
        cmpl %eax, (%esp)
        pop %eax
        jl return_true
        jmp return_false
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _Lt_3, .-_Lt_3
        .section .data
_eof_objectP_2:
        .long _eof_objectP_1
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_eof_objectP_1:
        .long 0xca11ab1e
        .long _eof_objectP_3
        .long 0
        .text
        .type _eof_objectP_3, @function
_eof_objectP_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        push %eax
        movl 0(%ebp), %eax
        cmpl $2 + 259<<2, %eax
        je return_true
        jmp return_false
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _eof_objectP_3, .-_eof_objectP_3
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_eof_objectP_4:
        .long 0xbabb1e
        .long 23
        .ascii "error: not a character\n"
        .text
not_a_character:
        movl $_eof_objectP_4, %eax
        jmp report_error
        .section .data
_charP_2:
        .long _charP_1
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_charP_1:
        .long 0xca11ab1e
        .long _charP_3
        .long 0
        .text
        .type _charP_3, @function
_charP_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        push %eax
        movl 0(%ebp), %eax
        test $1, %eax
        jnz return_false
        test $2, %eax
        je return_false
        cmpl $2 + 256<<2, %eax
        jnb return_false
        jmp return_true
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _charP_3, .-_charP_3
        .globl _start
_start:
        .weak _start
        .globl main
main:
        movl $0x610ba1, %ebp
        .section .data
_Plus_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _Plus_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_Plus_3:
        .long 0xca11ab1e
        .long _Plus_4
        .long 0
        .text
        .type _Plus_4, @function
_Plus_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $2, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 4(%ebp), %eax
        push %eax
        movl 0(%ebp), %eax
        # inlined integer add
        call ensure_integer
        xchg %eax, (%esp)
        call ensure_integer
        pop %ebx
        add %ebx, %eax
        dec %eax
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _Plus_4, .-_Plus_4
_Plus_2:
        push %eax
        movl $_Plus_3, %eax
        # initialize global variable with value
        movl %eax, (_Plus_1)
        pop %eax
        .section .data
___1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp ___2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
___3:
        .long 0xca11ab1e
        .long ___4
        .long 0
        .text
        .type ___4, @function
___4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $2, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 4(%ebp), %eax
        push %eax
        movl 0(%ebp), %eax
        # inlined integer subtract
        call ensure_integer
        xchg %eax, (%esp)
        call ensure_integer
        sub %eax, (%esp)
        pop %eax
        inc %eax
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size ___4, .-___4
___2:
        push %eax
        movl $___3, %eax
        # initialize global variable with value
        movl %eax, (___1)
        pop %eax
        .section .data
_car_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _car_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_car_3:
        .long 0xca11ab1e
        .long _car_4
        .long 0
        .text
        .type _car_4, @function
_car_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _car_4, .-_car_4
_car_2:
        push %eax
        movl $_car_3, %eax
        # initialize global variable with value
        movl %eax, (_car_1)
        pop %eax
        .section .data
_cdr_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _cdr_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_cdr_3:
        .long 0xca11ab1e
        .long _cdr_4
        .long 0
        .text
        .type _cdr_4, @function
_cdr_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # inlined cdr
        call ensure_cons
        movl 8(%eax), %eax
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _cdr_4, .-_cdr_4
_cdr_2:
        push %eax
        movl $_cdr_3, %eax
        # initialize global variable with value
        movl %eax, (_cdr_1)
        pop %eax
        .section .data
_1Plus_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _1Plus_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_1Plus_3:
        .long 0xca11ab1e
        .long _1Plus_4
        .long 0
        .text
        .type _1Plus_4, @function
_1Plus_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # 1+
        call ensure_integer
        add $1<<2, %eax
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _1Plus_4, .-_1Plus_4
_1Plus_2:
        push %eax
        movl $_1Plus_3, %eax
        # initialize global variable with value
        movl %eax, (_1Plus_1)
        pop %eax
        .section .data
_1__1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _1__2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_1__3:
        .long 0xca11ab1e
        .long _1__4
        .long 0
        .text
        .type _1__4, @function
_1__4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        call ensure_integer
        add $-1<<2, %eax
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _1__4, .-_1__4
_1__2:
        push %eax
        movl $_1__3, %eax
        # initialize global variable with value
        movl %eax, (_1__1)
        pop %eax
        .section .data
_list_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _list_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_list_3:
        .long 0xca11ab1e
        .long _list_4
        .long 0
        .text
        .type _list_4, @function
_list_4:
        # make space for variadic argument list
        pop %ebx
        push %ebx
        push %ebx
        # push desired %esp on return
        lea 8(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        call package_up_variadic_args
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _list_4, .-_list_4
_list_2:
        push %eax
        movl $_list_3, %eax
        # initialize global variable with value
        movl %eax, (_list_1)
        pop %eax
        .section .data
_length_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _length_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_length_3:
        .long 0xca11ab1e
        .long _length_4
        .long 0
        .text
        .type _length_4, @function
_length_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl $2 + 256<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _length_5
        push %eax
        movl $1 + 0<<2, %eax
        jmp _length_6
_length_5:
        push %eax
        movl 0(%ebp), %eax
        # inlined cdr
        call ensure_cons
        movl 8(%eax), %eax
        # get procedure
        push %eax
        movl (_length_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # 1+
        call ensure_integer
        add $1<<2, %eax
_length_6:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _length_4, .-_length_4
_length_2:
        push %eax
        movl $_length_3, %eax
        # initialize global variable with value
        movl %eax, (_length_1)
        pop %eax
        .section .data
_assq_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _assq_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_assq_3:
        .long 0xca11ab1e
        .long _assq_4
        .long 0
        .text
        .type _assq_4, @function
_assq_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $2, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 4(%ebp), %eax
        push %eax
        movl $2 + 256<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _assq_5
        push %eax
        movl $2 + 258<<2, %eax
        jmp _assq_6
_assq_5:
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl 4(%ebp), %eax
        # get procedure
        push %eax
        movl (_assq_9), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _assq_7
        push %eax
        movl 4(%ebp), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        jmp _assq_8
_assq_7:
        push %eax
        movl 4(%ebp), %eax
        # inlined cdr
        call ensure_cons
        movl 8(%eax), %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_assq_1), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
_assq_8:
_assq_6:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _assq_4, .-_assq_4
_assq_2:
        push %eax
        movl $_assq_3, %eax
        # initialize global variable with value
        movl %eax, (_assq_1)
        pop %eax
        .section .data
_memq_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _memq_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_memq_3:
        .long 0xca11ab1e
        .long _memq_4
        .long 0
        .text
        .type _memq_4, @function
_memq_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $2, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 4(%ebp), %eax
        push %eax
        movl $2 + 256<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _memq_5
        push %eax
        movl $2 + 258<<2, %eax
        jmp _memq_6
_memq_5:
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl 4(%ebp), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _memq_7
        push %eax
        movl 4(%ebp), %eax
        jmp _memq_8
_memq_7:
        push %eax
        movl 4(%ebp), %eax
        # inlined cdr
        call ensure_cons
        movl 8(%eax), %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_memq_1), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
_memq_8:
_memq_6:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _memq_4, .-_memq_4
_memq_2:
        push %eax
        movl $_memq_3, %eax
        # initialize global variable with value
        movl %eax, (_memq_1)
        pop %eax
        .section .data
_memv_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        push %eax
        movl (_memq_1), %eax
        # initialize global variable with value
        movl %eax, (_memv_1)
        pop %eax
        .section .data
_reduce_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _reduce_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_reduce_3:
        .long 0xca11ab1e
        .long _reduce_4
        .long 0
        .text
        .type _reduce_4, @function
_reduce_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $3, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 4(%ebp), %eax
        push %eax
        movl $2 + 256<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _reduce_5
        push %eax
        movl 8(%ebp), %eax
        jmp _reduce_6
_reduce_5:
        push %eax
        movl 8(%ebp), %eax
        push %eax
        movl 4(%ebp), %eax
        # inlined cdr
        call ensure_cons
        movl 8(%eax), %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_reduce_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        call *%ebx
        push %eax
        movl 4(%ebp), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl 0(%ebp), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
_reduce_6:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _reduce_4, .-_reduce_4
_reduce_2:
        push %eax
        movl $_reduce_3, %eax
        # initialize global variable with value
        movl %eax, (_reduce_1)
        pop %eax
        .section .data
_append2_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _append2_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_append2_3:
        .long 0xca11ab1e
        .long _append2_4
        .long 0
        .text
        .type _append2_4, @function
_append2_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $2, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 4(%ebp), %eax
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl (_cons_2), %eax
        # get procedure
        push %eax
        movl (_reduce_1), %eax
        # apply procedure
        # Tail call; nargs = 3
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 8(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push -8(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _append2_4, .-_append2_4
_append2_2:
        push %eax
        movl $_append2_3, %eax
        # initialize global variable with value
        movl %eax, (_append2_1)
        pop %eax
        .section .data
_append_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _append_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_append_3:
        .long 0xca11ab1e
        .long _append_4
        .long 0
        .text
        .type _append_4, @function
_append_4:
        # make space for variadic argument list
        pop %ebx
        push %ebx
        push %ebx
        # push desired %esp on return
        lea 8(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        call package_up_variadic_args
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl $2 + 256<<2, %eax
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl (_append2_1), %eax
        # get procedure
        push %eax
        movl (_reduce_1), %eax
        # apply procedure
        # Tail call; nargs = 3
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 8(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push -8(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _append_4, .-_append_4
_append_2:
        push %eax
        movl $_append_3, %eax
        # initialize global variable with value
        movl %eax, (_append_1)
        pop %eax
        .section .data
_assq_9:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _caar_1
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_caar_2:
        .long 0xca11ab1e
        .long _caar_3
        .long 0
        .text
        .type _caar_3, @function
_caar_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _caar_3, .-_caar_3
_caar_1:
        push %eax
        movl $_caar_2, %eax
        # initialize global variable with value
        movl %eax, (_assq_9)
        pop %eax
        .section .data
_cdar_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _cdar_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_cdar_3:
        .long 0xca11ab1e
        .long _cdar_4
        .long 0
        .text
        .type _cdar_4, @function
_cdar_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        # inlined cdr
        call ensure_cons
        movl 8(%eax), %eax
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _cdar_4, .-_cdar_4
_cdar_2:
        push %eax
        movl $_cdar_3, %eax
        # initialize global variable with value
        movl %eax, (_cdar_1)
        pop %eax
        .section .data
_cadr_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _cadr_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_cadr_3:
        .long 0xca11ab1e
        .long _cadr_4
        .long 0
        .text
        .type _cadr_4, @function
_cadr_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # inlined cdr
        call ensure_cons
        movl 8(%eax), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _cadr_4, .-_cadr_4
_cadr_2:
        push %eax
        movl $_cadr_3, %eax
        # initialize global variable with value
        movl %eax, (_cadr_1)
        pop %eax
        .section .data
_cddr_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _cddr_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_cddr_3:
        .long 0xca11ab1e
        .long _cddr_4
        .long 0
        .text
        .type _cddr_4, @function
_cddr_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # inlined cdr
        call ensure_cons
        movl 8(%eax), %eax
        # inlined cdr
        call ensure_cons
        movl 8(%eax), %eax
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _cddr_4, .-_cddr_4
_cddr_2:
        push %eax
        movl $_cddr_3, %eax
        # initialize global variable with value
        movl %eax, (_cddr_1)
        pop %eax
        .section .data
_caddr_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _caddr_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_caddr_3:
        .long 0xca11ab1e
        .long _caddr_4
        .long 0
        .text
        .type _caddr_4, @function
_caddr_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # inlined cdr
        call ensure_cons
        movl 8(%eax), %eax
        # inlined cdr
        call ensure_cons
        movl 8(%eax), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _caddr_4, .-_caddr_4
_caddr_2:
        push %eax
        movl $_caddr_3, %eax
        # initialize global variable with value
        movl %eax, (_caddr_1)
        pop %eax
        .section .data
_caadr_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _caadr_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_caadr_3:
        .long 0xca11ab1e
        .long _caadr_4
        .long 0
        .text
        .type _caadr_4, @function
_caadr_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # inlined cdr
        call ensure_cons
        movl 8(%eax), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _caadr_4, .-_caadr_4
_caadr_2:
        push %eax
        movl $_caadr_3, %eax
        # initialize global variable with value
        movl %eax, (_caadr_1)
        pop %eax
        .section .data
_cdadr_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _cdadr_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_cdadr_3:
        .long 0xca11ab1e
        .long _cdadr_4
        .long 0
        .text
        .type _cdadr_4, @function
_cdadr_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # inlined cdr
        call ensure_cons
        movl 8(%eax), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        # inlined cdr
        call ensure_cons
        movl 8(%eax), %eax
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _cdadr_4, .-_cdadr_4
_cdadr_2:
        push %eax
        movl $_cdadr_3, %eax
        # initialize global variable with value
        movl %eax, (_cdadr_1)
        pop %eax
        .section .data
_cadar_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _cadar_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_cadar_3:
        .long 0xca11ab1e
        .long _cadar_4
        .long 0
        .text
        .type _cadar_4, @function
_cadar_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        # inlined cdr
        call ensure_cons
        movl 8(%eax), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _cadar_4, .-_cadar_4
_cadar_2:
        push %eax
        movl $_cadar_3, %eax
        # initialize global variable with value
        movl %eax, (_cadar_1)
        pop %eax
        .section .data
_caddar_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _caddar_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_caddar_3:
        .long 0xca11ab1e
        .long _caddar_4
        .long 0
        .text
        .type _caddar_4, @function
_caddar_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        # inlined cdr
        call ensure_cons
        movl 8(%eax), %eax
        # inlined cdr
        call ensure_cons
        movl 8(%eax), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _caddar_4, .-_caddar_4
_caddar_2:
        push %eax
        movl $_caddar_3, %eax
        # initialize global variable with value
        movl %eax, (_caddar_1)
        pop %eax
        .section .data
_cadddr_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _cadddr_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_cadddr_3:
        .long 0xca11ab1e
        .long _cadddr_4
        .long 0
        .text
        .type _cadddr_4, @function
_cadddr_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # inlined cdr
        call ensure_cons
        movl 8(%eax), %eax
        # inlined cdr
        call ensure_cons
        movl 8(%eax), %eax
        # inlined cdr
        call ensure_cons
        movl 8(%eax), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _cadddr_4, .-_cadddr_4
_cadddr_2:
        push %eax
        movl $_cadddr_3, %eax
        # initialize global variable with value
        movl %eax, (_cadddr_1)
        pop %eax
        .section .data
_caaadr_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _caaadr_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_caaadr_3:
        .long 0xca11ab1e
        .long _caaadr_4
        .long 0
        .text
        .type _caaadr_4, @function
_caaadr_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # inlined cdr
        call ensure_cons
        movl 8(%eax), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _caaadr_4, .-_caaadr_4
_caaadr_2:
        push %eax
        movl $_caaadr_3, %eax
        # initialize global variable with value
        movl %eax, (_caaadr_1)
        pop %eax
        .section .data
_not_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _not_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_not_3:
        .long 0xca11ab1e
        .long _not_4
        .long 0
        .text
        .type _not_4, @function
_not_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _not_5
        push %eax
        movl $2 + 257<<2, %eax
        jmp _not_6
_not_5:
        push %eax
        movl $2 + 258<<2, %eax
_not_6:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _not_4, .-_not_4
_not_2:
        push %eax
        movl $_not_3, %eax
        # initialize global variable with value
        movl %eax, (_not_1)
        pop %eax
        .section .data
_string_length_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _string_length_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_string_length_3:
        .long 0xca11ab1e
        .long _string_length_4
        .long 0
        .text
        .type _string_length_4, @function
_string_length_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # string-length inlined primitive
        call ensure_string
        lea 8(%eax), %ebx
        push %ebx
        movl 4(%eax), %eax
        pop %ebx
        sal %eax
        sal %eax
        inc %eax
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _string_length_4, .-_string_length_4
_string_length_2:
        push %eax
        movl $_string_length_3, %eax
        # initialize global variable with value
        movl %eax, (_string_length_1)
        pop %eax
        .section .data
_symbol_Gtstring_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _symbol_Gtstring_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_symbol_Gtstring_3:
        .long 0xca11ab1e
        .long _symbol_Gtstring_4
        .long 0
        .text
        .type _symbol_Gtstring_4, @function
_symbol_Gtstring_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        call ensure_symbol
        movl 4(%eax), %eax
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _symbol_Gtstring_4, .-_symbol_Gtstring_4
_symbol_Gtstring_2:
        push %eax
        movl $_symbol_Gtstring_3, %eax
        # initialize global variable with value
        movl %eax, (_symbol_Gtstring_1)
        pop %eax
        .section .data
_string_append_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _string_append_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_string_append_3:
        .long 0xca11ab1e
        .long _string_append_4
        .long 0
        .text
        .type _string_append_4, @function
_string_append_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $2, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # move arg from stack to heap: s1
        push %eax
        movl 0(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # move arg from stack to heap: s2
        push %eax
        movl 4(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # string-length inlined primitive
        call ensure_string
        lea 8(%eax), %ebx
        push %ebx
        movl 4(%eax), %eax
        pop %ebx
        sal %eax
        sal %eax
        inc %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # string-length inlined primitive
        call ensure_string
        lea 8(%eax), %ebx
        push %ebx
        movl 4(%eax), %eax
        pop %ebx
        sal %eax
        sal %eax
        inc %eax
        # inlined integer add
        call ensure_integer
        xchg %eax, (%esp)
        call ensure_integer
        pop %ebx
        add %ebx, %eax
        dec %eax
        # get procedure
        push %eax
        movl (_make_string_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        # jump past the body of the lambda
        jmp _string_append_5
        .text
        .type _string_append_6, @function
_string_append_6:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 s2
        push 12(%eax)
        # fetch artifact from closure: 1 s1
        push 16(%eax)
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl $1 + 0<<2, %eax
        push %eax
        movl 0(%ebp), %eax
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # string-length inlined primitive
        call ensure_string
        lea 8(%eax), %ebx
        push %ebx
        movl 4(%eax), %eax
        pop %ebx
        sal %eax
        sal %eax
        inc %eax
        push %eax
        movl $1 + 0<<2, %eax
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_string_append_7), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $5, %edx
        call *%ebx
        pop %eax
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # string-length inlined primitive
        call ensure_string
        lea 8(%eax), %ebx
        push %ebx
        movl 4(%eax), %eax
        pop %ebx
        sal %eax
        sal %eax
        inc %eax
        push %eax
        movl 0(%ebp), %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # string-length inlined primitive
        call ensure_string
        lea 8(%eax), %ebx
        push %ebx
        movl 4(%eax), %eax
        pop %ebx
        sal %eax
        sal %eax
        inc %eax
        push %eax
        movl $1 + 0<<2, %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_string_append_7), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $5, %edx
        call *%ebx
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _string_append_6, .-_string_append_6
_string_append_5:
        # allocate bytes: 20
        push %eax
        movl (arena_pointer), %eax
        add $20, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_string_append_6, 4(%ebx)
        movl $2, 8(%ebx)
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl %eax, 16(%ebx)
        pop %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _string_append_4, .-_string_append_4
_string_append_2:
        push %eax
        movl $_string_append_3, %eax
        # initialize global variable with value
        movl %eax, (_string_append_1)
        pop %eax
        .section .data
_string_append_7:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _string_blitBang_1
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_string_blitBang_2:
        .long 0xca11ab1e
        .long _string_blitBang_3
        .long 0
        .text
        .type _string_blitBang_3, @function
_string_blitBang_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $5, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 8(%ebp), %eax
        push %eax
        movl $1 + 0<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _string_blitBang_4
        push %eax
        movl $2 + 258<<2, %eax
        jmp _string_blitBang_5
_string_blitBang_4:
        push %eax
        movl 4(%ebp), %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_string_ref_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        push %eax
        movl 16(%ebp), %eax
        push %eax
        movl 12(%ebp), %eax
        # get procedure
        push %eax
        movl (_string_setBang_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        call *%ebx
        pop %eax
        push %eax
        movl 16(%ebp), %eax
        # 1+
        call ensure_integer
        add $1<<2, %eax
        push %eax
        movl 12(%ebp), %eax
        push %eax
        movl 8(%ebp), %eax
        call ensure_integer
        add $-1<<2, %eax
        push %eax
        movl 4(%ebp), %eax
        # 1+
        call ensure_integer
        add $1<<2, %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_string_append_7), %eax
        # apply procedure
        # Tail call; nargs = 5
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 16(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push -8(%ebx)
        push -12(%ebx)
        push -16(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $5, %edx
        jmp *%ebx
_string_blitBang_5:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _string_blitBang_3, .-_string_blitBang_3
_string_blitBang_1:
        push %eax
        movl $_string_blitBang_2, %eax
        # initialize global variable with value
        movl %eax, (_string_append_7)
        pop %eax
        .section .data
_char_whitespaceP_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _char_whitespaceP_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_char_whitespaceP_3:
        .long 0xca11ab1e
        .long _char_whitespaceP_4
        .long 0
        .text
        .type _char_whitespaceP_4, @function
_char_whitespaceP_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_char_whitespaceP_9:
        .long 0x2ce11ed
        .long 2 + 9<<2
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_char_whitespaceP_8:
        .long 0x2ce11ed
        .long 2 + 10<<2
        .long _char_whitespaceP_9
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_char_whitespaceP_7:
        .long 0x2ce11ed
        .long 2 + 32<<2
        .long _char_whitespaceP_8
        .text
        push %eax
        movl $_char_whitespaceP_7, %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_memv_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _char_whitespaceP_5
        push %eax
        movl $2 + 258<<2, %eax
        jmp _char_whitespaceP_6
_char_whitespaceP_5:
        push %eax
        movl $2 + 257<<2, %eax
_char_whitespaceP_6:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _char_whitespaceP_4, .-_char_whitespaceP_4
_char_whitespaceP_2:
        push %eax
        movl $_char_whitespaceP_3, %eax
        # initialize global variable with value
        movl %eax, (_char_whitespaceP_1)
        pop %eax
        .section .data
_charLtP_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _charLtP_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_charLtP_3:
        .long 0xca11ab1e
        .long _charLtP_4
        .long 0
        .text
        .type _charLtP_4, @function
_charLtP_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $2, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 4(%ebp), %eax
        test $1, %eax
        jnz not_a_character
        test $2, %eax
        je not_a_character
        cmpl $2 + 256<<2, %eax
        jnb not_a_character
        dec %eax
        push %eax
        movl 0(%ebp), %eax
        test $1, %eax
        jnz not_a_character
        test $2, %eax
        je not_a_character
        cmpl $2 + 256<<2, %eax
        jnb not_a_character
        dec %eax
        # get procedure
        push %eax
        movl (_Lt_2), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _charLtP_4, .-_charLtP_4
_charLtP_2:
        push %eax
        movl $_charLtP_3, %eax
        # initialize global variable with value
        movl %eax, (_charLtP_1)
        pop %eax
        .section .data
_charLtEqP_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _charLtEqP_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_charLtEqP_3:
        .long 0xca11ab1e
        .long _charLtEqP_4
        .long 0
        .text
        .type _charLtEqP_4, @function
_charLtEqP_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $2, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # move arg from stack to heap: a
        push %eax
        movl 0(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # move arg from stack to heap: b
        push %eax
        movl 4(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_charLtEqP_5), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        # jump past the body of the lambda
        jmp _charLtEqP_6
        .text
        .type _charLtEqP_7, @function
_charLtEqP_7:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 a
        push 12(%eax)
        # fetch artifact from closure: 1 b
        push 16(%eax)
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _charLtEqP_8
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_charLtP_1), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        jmp _charLtEqP_9
_charLtEqP_8:
        push %eax
        movl 0(%ebp), %eax
_charLtEqP_9:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _charLtEqP_7, .-_charLtEqP_7
_charLtEqP_6:
        # allocate bytes: 20
        push %eax
        movl (arena_pointer), %eax
        add $20, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_charLtEqP_7, 4(%ebx)
        movl $2, 8(%ebx)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        movl %eax, 16(%ebx)
        pop %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _charLtEqP_4, .-_charLtEqP_4
_charLtEqP_2:
        push %eax
        movl $_charLtEqP_3, %eax
        # initialize global variable with value
        movl %eax, (_charLtEqP_1)
        pop %eax
        .section .data
_char_betweenP_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _char_betweenP_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_char_betweenP_3:
        .long 0xca11ab1e
        .long _char_betweenP_4
        .long 0
        .text
        .type _char_betweenP_4, @function
_char_betweenP_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $3, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 4(%ebp), %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_charLtEqP_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _char_betweenP_5
        push %eax
        movl $2 + 258<<2, %eax
        jmp _char_betweenP_6
_char_betweenP_5:
        push %eax
        movl 8(%ebp), %eax
        push %eax
        movl 4(%ebp), %eax
        # get procedure
        push %eax
        movl (_charLtEqP_1), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
_char_betweenP_6:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _char_betweenP_4, .-_char_betweenP_4
_char_betweenP_2:
        push %eax
        movl $_char_betweenP_3, %eax
        # initialize global variable with value
        movl %eax, (_char_betweenP_1)
        pop %eax
        .section .data
_char_alphabeticP_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _char_alphabeticP_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_char_alphabeticP_3:
        .long 0xca11ab1e
        .long _char_alphabeticP_4
        .long 0
        .text
        .type _char_alphabeticP_4, @function
_char_alphabeticP_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # move arg from stack to heap: x
        push %eax
        movl 0(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        push %eax
        movl $2 + 90<<2, %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        push %eax
        movl $2 + 65<<2, %eax
        # get procedure
        push %eax
        movl (_char_betweenP_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        call *%ebx
        # get procedure
        # jump past the body of the lambda
        jmp _char_alphabeticP_5
        .text
        .type _char_alphabeticP_6, @function
_char_alphabeticP_6:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 x
        push 12(%eax)
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _char_alphabeticP_7
        push %eax
        movl $2 + 122<<2, %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        push %eax
        movl $2 + 97<<2, %eax
        # get procedure
        push %eax
        movl (_char_betweenP_1), %eax
        # apply procedure
        # Tail call; nargs = 3
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 8(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push -8(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        jmp *%ebx
        jmp _char_alphabeticP_8
_char_alphabeticP_7:
        push %eax
        movl 0(%ebp), %eax
_char_alphabeticP_8:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _char_alphabeticP_6, .-_char_alphabeticP_6
_char_alphabeticP_5:
        # allocate bytes: 16
        push %eax
        movl (arena_pointer), %eax
        add $16, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_char_alphabeticP_6, 4(%ebx)
        movl $1, 8(%ebx)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _char_alphabeticP_4, .-_char_alphabeticP_4
_char_alphabeticP_2:
        push %eax
        movl $_char_alphabeticP_3, %eax
        # initialize global variable with value
        movl %eax, (_char_alphabeticP_1)
        pop %eax
        .section .data
_char_numericP_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _char_numericP_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_char_numericP_3:
        .long 0xca11ab1e
        .long _char_numericP_4
        .long 0
        .text
        .type _char_numericP_4, @function
_char_numericP_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl $2 + 57<<2, %eax
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl $2 + 48<<2, %eax
        # get procedure
        push %eax
        movl (_char_betweenP_1), %eax
        # apply procedure
        # Tail call; nargs = 3
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 8(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push -8(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _char_numericP_4, .-_char_numericP_4
_char_numericP_2:
        push %eax
        movl $_char_numericP_3, %eax
        # initialize global variable with value
        movl %eax, (_char_numericP_1)
        pop %eax
        .section .data
_eqP_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _eqP_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_eqP_3:
        .long 0xca11ab1e
        .long _eqP_4
        .long 0
        .text
        .type _eqP_4, @function
_eqP_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $2, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl 4(%ebp), %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _eqP_5
        push %eax
        movl $2 + 257<<2, %eax
        jmp _eqP_6
_eqP_5:
        push %eax
        movl $2 + 258<<2, %eax
_eqP_6:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _eqP_4, .-_eqP_4
_eqP_2:
        push %eax
        movl $_eqP_3, %eax
        # initialize global variable with value
        movl %eax, (_eqP_1)
        pop %eax
        .section .data
_Eq_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        push %eax
        movl (_eqP_1), %eax
        # initialize global variable with value
        movl %eax, (_Eq_1)
        pop %eax
        .section .data
_charEqP_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        push %eax
        movl (_eqP_1), %eax
        # initialize global variable with value
        movl %eax, (_charEqP_1)
        pop %eax
        .section .data
_charLtEqP_5:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        push %eax
        movl (_eqP_1), %eax
        # initialize global variable with value
        movl %eax, (_charLtEqP_5)
        pop %eax
        .section .data
_equalP_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _equalP_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_equalP_3:
        .long 0xca11ab1e
        .long _equalP_4
        .long 0
        .text
        .type _equalP_4, @function
_equalP_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $2, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl 4(%ebp), %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _equalP_5
        push %eax
        movl $2 + 257<<2, %eax
        jmp _equalP_6
_equalP_5:
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_stringP_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _equalP_7
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_pairP_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _equalP_9
        push %eax
        movl $2 + 258<<2, %eax
        jmp _equalP_10
_equalP_9:
        # %ifeq
        push %eax
        movl 4(%ebp), %eax
        # get procedure
        push %eax
        movl (_pairP_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _equalP_11
        push %eax
        movl $2 + 258<<2, %eax
        jmp _equalP_12
_equalP_11:
        # %ifeq
        push %eax
        movl 4(%ebp), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        push %eax
        movl 0(%ebp), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_equalP_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _equalP_13
        push %eax
        movl $2 + 258<<2, %eax
        jmp _equalP_14
_equalP_13:
        push %eax
        movl 4(%ebp), %eax
        # inlined cdr
        call ensure_cons
        movl 8(%eax), %eax
        push %eax
        movl 0(%ebp), %eax
        # inlined cdr
        call ensure_cons
        movl 8(%eax), %eax
        # get procedure
        push %eax
        movl (_equalP_1), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
_equalP_14:
_equalP_12:
_equalP_10:
        jmp _equalP_8
_equalP_7:
        # %ifeq
        push %eax
        movl 4(%ebp), %eax
        # get procedure
        push %eax
        movl (_stringP_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _equalP_15
        push %eax
        movl $2 + 258<<2, %eax
        jmp _equalP_16
_equalP_15:
        push %eax
        movl 4(%ebp), %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_equalP_17), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
_equalP_16:
_equalP_8:
_equalP_6:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _equalP_4, .-_equalP_4
_equalP_2:
        push %eax
        movl $_equalP_3, %eax
        # initialize global variable with value
        movl %eax, (_equalP_1)
        pop %eax
        .section .data
_equalP_17:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _stringEqP_1
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_stringEqP_2:
        .long 0xca11ab1e
        .long _stringEqP_3
        .long 0
        .text
        .type _stringEqP_3, @function
_stringEqP_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $2, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        # string-length inlined primitive
        call ensure_string
        lea 8(%eax), %ebx
        push %ebx
        movl 4(%eax), %eax
        pop %ebx
        sal %eax
        sal %eax
        inc %eax
        push %eax
        movl 4(%ebp), %eax
        # string-length inlined primitive
        call ensure_string
        lea 8(%eax), %ebx
        push %ebx
        movl 4(%eax), %eax
        pop %ebx
        sal %eax
        sal %eax
        inc %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _stringEqP_4
        push %eax
        movl $1 + 0<<2, %eax
        push %eax
        movl 4(%ebp), %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_stringEqP_6), %eax
        # apply procedure
        # Tail call; nargs = 3
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 8(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push -8(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        jmp *%ebx
        jmp _stringEqP_5
_stringEqP_4:
        push %eax
        movl $2 + 258<<2, %eax
_stringEqP_5:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _stringEqP_3, .-_stringEqP_3
_stringEqP_1:
        push %eax
        movl $_stringEqP_2, %eax
        # initialize global variable with value
        movl %eax, (_equalP_17)
        pop %eax
        .section .data
_stringEqP_6:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _stringEqP_2_1
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_stringEqP_2_2:
        .long 0xca11ab1e
        .long _stringEqP_2_3
        .long 0
        .text
        .type _stringEqP_2_3, @function
_stringEqP_2_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $3, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # move arg from stack to heap: a
        push %eax
        movl 0(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # move arg from stack to heap: b
        push %eax
        movl 4(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # move arg from stack to heap: idx
        push %eax
        movl 8(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # string-length inlined primitive
        call ensure_string
        lea 8(%eax), %ebx
        push %ebx
        movl 4(%eax), %eax
        pop %ebx
        sal %eax
        sal %eax
        inc %eax
        # fetching heap var pointer 2
        push %eax
        movl -24(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_Eq_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        # jump past the body of the lambda
        jmp _stringEqP_2_4
        .text
        .type _stringEqP_2_5, @function
_stringEqP_2_5:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 a
        push 12(%eax)
        # fetch artifact from closure: 1 b
        push 16(%eax)
        # fetch artifact from closure: 2 idx
        push 20(%eax)
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _stringEqP_2_6
        # %ifeq
        # fetching heap var pointer 2
        push %eax
        movl -24(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_string_ref_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # fetching heap var pointer 2
        push %eax
        movl -24(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_string_ref_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_charEqP_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _stringEqP_2_8
        push %eax
        movl $2 + 258<<2, %eax
        jmp _stringEqP_2_9
_stringEqP_2_8:
        # fetching heap var pointer 2
        push %eax
        movl -24(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # 1+
        call ensure_integer
        add $1<<2, %eax
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_stringEqP_6), %eax
        # apply procedure
        # Tail call; nargs = 3
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 8(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push -8(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        jmp *%ebx
_stringEqP_2_9:
        jmp _stringEqP_2_7
_stringEqP_2_6:
        push %eax
        movl 0(%ebp), %eax
_stringEqP_2_7:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _stringEqP_2_5, .-_stringEqP_2_5
_stringEqP_2_4:
        # allocate bytes: 24
        push %eax
        movl (arena_pointer), %eax
        add $24, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_stringEqP_2_5, 4(%ebx)
        movl $3, 8(%ebx)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        movl %eax, 16(%ebx)
        pop %eax
        # fetching heap var pointer 2
        push %eax
        movl -24(%ebp), %eax
        movl %eax, 20(%ebx)
        pop %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _stringEqP_2_3, .-_stringEqP_2_3
_stringEqP_2_1:
        push %eax
        movl $_stringEqP_2_2, %eax
        # initialize global variable with value
        movl %eax, (_stringEqP_6)
        pop %eax
        .section .data
_nullP_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _nullP_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_nullP_3:
        .long 0xca11ab1e
        .long _nullP_4
        .long 0
        .text
        .type _nullP_4, @function
_nullP_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl $2 + 256<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _nullP_5
        push %eax
        movl $2 + 257<<2, %eax
        jmp _nullP_6
_nullP_5:
        push %eax
        movl $2 + 258<<2, %eax
_nullP_6:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _nullP_4, .-_nullP_4
_nullP_2:
        push %eax
        movl $_nullP_3, %eax
        # initialize global variable with value
        movl %eax, (_nullP_1)
        pop %eax
        .section .data
_booleanP_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _booleanP_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_booleanP_3:
        .long 0xca11ab1e
        .long _booleanP_4
        .long 0
        .text
        .type _booleanP_4, @function
_booleanP_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl $2 + 257<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _booleanP_5
        push %eax
        movl $2 + 257<<2, %eax
        jmp _booleanP_6
_booleanP_5:
        push %eax
        movl $2 + 258<<2, %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_eqP_1), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
_booleanP_6:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _booleanP_4, .-_booleanP_4
_booleanP_2:
        push %eax
        movl $_booleanP_3, %eax
        # initialize global variable with value
        movl %eax, (_booleanP_1)
        pop %eax
        .section .data
_numberP_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        push %eax
        movl (_integerP_2), %eax
        # initialize global variable with value
        movl %eax, (_numberP_1)
        pop %eax
        .section .data
_for_each_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _for_each_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_for_each_3:
        .long 0xca11ab1e
        .long _for_each_4
        .long 0
        .text
        .type _for_each_4, @function
_for_each_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $2, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 4(%ebp), %eax
        push %eax
        movl $2 + 256<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _for_each_5
        push %eax
        movl $2 + 258<<2, %eax
        jmp _for_each_6
_for_each_5:
        push %eax
        movl 4(%ebp), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl 0(%ebp), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl 4(%ebp), %eax
        # inlined cdr
        call ensure_cons
        movl 8(%eax), %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_for_each_1), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
_for_each_6:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _for_each_4, .-_for_each_4
_for_each_2:
        push %eax
        movl $_for_each_3, %eax
        # initialize global variable with value
        movl %eax, (_for_each_1)
        pop %eax
        .section .data
_map_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _map_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_map_3:
        .long 0xca11ab1e
        .long _map_4
        .long 0
        .text
        .type _map_4, @function
_map_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $2, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 4(%ebp), %eax
        push %eax
        movl $2 + 256<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _map_5
        push %eax
        movl $2 + 256<<2, %eax
        jmp _map_6
_map_5:
        push %eax
        movl 4(%ebp), %eax
        # inlined cdr
        call ensure_cons
        movl 8(%eax), %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_map_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        push %eax
        movl 4(%ebp), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl 0(%ebp), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_cons_2), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
_map_6:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _map_4, .-_map_4
_map_2:
        push %eax
        movl $_map_3, %eax
        # initialize global variable with value
        movl %eax, (_map_1)
        pop %eax
        .section .data
_reverse_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _reverse_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_reverse_3:
        .long 0xca11ab1e
        .long _reverse_4
        .long 0
        .text
        .type _reverse_4, @function
_reverse_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl $2 + 256<<2, %eax
        # get procedure
        push %eax
        movl (_reverse_5), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _reverse_4, .-_reverse_4
_reverse_2:
        push %eax
        movl $_reverse_3, %eax
        # initialize global variable with value
        movl %eax, (_reverse_1)
        pop %eax
        .section .data
_reverse_5:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _reverse_plus_1
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_reverse_plus_2:
        .long 0xca11ab1e
        .long _reverse_plus_3
        .long 0
        .text
        .type _reverse_plus_3, @function
_reverse_plus_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $2, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 4(%ebp), %eax
        push %eax
        movl $2 + 256<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _reverse_plus_4
        push %eax
        movl 0(%ebp), %eax
        jmp _reverse_plus_5
_reverse_plus_4:
        push %eax
        movl 4(%ebp), %eax
        # inlined cdr
        call ensure_cons
        movl 8(%eax), %eax
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl 4(%ebp), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_cons_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_reverse_5), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
_reverse_plus_5:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _reverse_plus_3, .-_reverse_plus_3
_reverse_plus_1:
        push %eax
        movl $_reverse_plus_2, %eax
        # initialize global variable with value
        movl %eax, (_reverse_5)
        pop %eax
        .section .data
_string_Gtlist_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _string_Gtlist_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_string_Gtlist_3:
        .long 0xca11ab1e
        .long _string_Gtlist_4
        .long 0
        .text
        .type _string_Gtlist_4, @function
_string_Gtlist_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl $2 + 256<<2, %eax
        push %eax
        movl 0(%ebp), %eax
        # string-length inlined primitive
        call ensure_string
        lea 8(%eax), %ebx
        push %ebx
        movl 4(%eax), %eax
        pop %ebx
        sal %eax
        sal %eax
        inc %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_string_Gtlist_5), %eax
        # apply procedure
        # Tail call; nargs = 3
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 8(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push -8(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _string_Gtlist_4, .-_string_Gtlist_4
_string_Gtlist_2:
        push %eax
        movl $_string_Gtlist_3, %eax
        # initialize global variable with value
        movl %eax, (_string_Gtlist_1)
        pop %eax
        .section .data
_string_Gtlist_5:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _string_Gtlist_2_1
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_string_Gtlist_2_2:
        .long 0xca11ab1e
        .long _string_Gtlist_2_3
        .long 0
        .text
        .type _string_Gtlist_2_3, @function
_string_Gtlist_2_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $3, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 4(%ebp), %eax
        push %eax
        movl $1 + 0<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _string_Gtlist_2_4
        push %eax
        movl 8(%ebp), %eax
        jmp _string_Gtlist_2_5
_string_Gtlist_2_4:
        push %eax
        movl 8(%ebp), %eax
        push %eax
        movl $1 + 1<<2, %eax
        push %eax
        movl 4(%ebp), %eax
        # inlined integer subtract
        call ensure_integer
        xchg %eax, (%esp)
        call ensure_integer
        sub %eax, (%esp)
        pop %eax
        inc %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_string_ref_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_cons_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        push %eax
        movl $1 + 1<<2, %eax
        push %eax
        movl 4(%ebp), %eax
        # inlined integer subtract
        call ensure_integer
        xchg %eax, (%esp)
        call ensure_integer
        sub %eax, (%esp)
        pop %eax
        inc %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_string_Gtlist_5), %eax
        # apply procedure
        # Tail call; nargs = 3
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 8(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push -8(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        jmp *%ebx
_string_Gtlist_2_5:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _string_Gtlist_2_3, .-_string_Gtlist_2_3
_string_Gtlist_2_1:
        push %eax
        movl $_string_Gtlist_2_2, %eax
        # initialize global variable with value
        movl %eax, (_string_Gtlist_5)
        pop %eax
        .section .data
_integer_Gtchar_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _integer_Gtchar_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_integer_Gtchar_3:
        .long 0xca11ab1e
        .long _integer_Gtchar_4
        .long 0
        .text
        .type _integer_Gtchar_4, @function
_integer_Gtchar_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        inc %eax
        test $1, %eax
        jnz not_a_character
        test $2, %eax
        je not_a_character
        cmpl $2 + 256<<2, %eax
        jnb not_a_character
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _integer_Gtchar_4, .-_integer_Gtchar_4
_integer_Gtchar_2:
        push %eax
        movl $_integer_Gtchar_3, %eax
        # initialize global variable with value
        movl %eax, (_integer_Gtchar_1)
        pop %eax
        .section .data
_char_Gtinteger_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _char_Gtinteger_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_char_Gtinteger_3:
        .long 0xca11ab1e
        .long _char_Gtinteger_4
        .long 0
        .text
        .type _char_Gtinteger_4, @function
_char_Gtinteger_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        test $1, %eax
        jnz not_a_character
        test $2, %eax
        je not_a_character
        cmpl $2 + 256<<2, %eax
        jnb not_a_character
        dec %eax
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _char_Gtinteger_4, .-_char_Gtinteger_4
_char_Gtinteger_2:
        push %eax
        movl $_char_Gtinteger_3, %eax
        # initialize global variable with value
        movl %eax, (_char_Gtinteger_1)
        pop %eax
        .section .data
_list_Gtstring_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _list_Gtstring_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_list_Gtstring_3:
        .long 0xca11ab1e
        .long _list_Gtstring_4
        .long 0
        .text
        .type _list_Gtstring_4, @function
_list_Gtstring_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl $1 + 0<<2, %eax
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_length_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_make_string_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_list_Gtstring_5), %eax
        # apply procedure
        # Tail call; nargs = 3
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 8(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push -8(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _list_Gtstring_4, .-_list_Gtstring_4
_list_Gtstring_2:
        push %eax
        movl $_list_Gtstring_3, %eax
        # initialize global variable with value
        movl %eax, (_list_Gtstring_1)
        pop %eax
        .section .data
_list_Gtstring_5:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _list_Gtstring_2_1
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_list_Gtstring_2_2:
        .long 0xca11ab1e
        .long _list_Gtstring_2_3
        .long 0
        .text
        .type _list_Gtstring_2_3, @function
_list_Gtstring_2_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $3, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 4(%ebp), %eax
        push %eax
        movl $2 + 256<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _list_Gtstring_2_4
        push %eax
        movl 0(%ebp), %eax
        jmp _list_Gtstring_2_5
_list_Gtstring_2_4:
        push %eax
        movl 4(%ebp), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        push %eax
        movl 8(%ebp), %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_string_setBang_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        call *%ebx
        pop %eax
        push %eax
        movl 8(%ebp), %eax
        # 1+
        call ensure_integer
        add $1<<2, %eax
        push %eax
        movl 4(%ebp), %eax
        # inlined cdr
        call ensure_cons
        movl 8(%eax), %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_list_Gtstring_5), %eax
        # apply procedure
        # Tail call; nargs = 3
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 8(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push -8(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        jmp *%ebx
_list_Gtstring_2_5:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _list_Gtstring_2_3, .-_list_Gtstring_2_3
_list_Gtstring_2_1:
        push %eax
        movl $_list_Gtstring_2_2, %eax
        # initialize global variable with value
        movl %eax, (_list_Gtstring_5)
        pop %eax
        .section .data
_char_Gtstring_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _char_Gtstring_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_char_Gtstring_3:
        .long 0xca11ab1e
        .long _char_Gtstring_4
        .long 0
        .text
        .type _char_Gtstring_4, @function
_char_Gtstring_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # move arg from stack to heap: char
        push %eax
        movl 0(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        push %eax
        movl $1 + 1<<2, %eax
        # get procedure
        push %eax
        movl (_make_string_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        # jump past the body of the lambda
        jmp _char_Gtstring_5
        .text
        .type _char_Gtstring_6, @function
_char_Gtstring_6:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 char
        push 12(%eax)
        # discarding useless value in %eax
        pop %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        push %eax
        movl $1 + 0<<2, %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_string_setBang_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        call *%ebx
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _char_Gtstring_6, .-_char_Gtstring_6
_char_Gtstring_5:
        # allocate bytes: 16
        push %eax
        movl (arena_pointer), %eax
        add $16, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_char_Gtstring_6, 4(%ebx)
        movl $1, 8(%ebx)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _char_Gtstring_4, .-_char_Gtstring_4
_char_Gtstring_2:
        push %eax
        movl $_char_Gtstring_3, %eax
        # initialize global variable with value
        movl %eax, (_char_Gtstring_1)
        pop %eax
        .section .data
_string_digit_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _string_digit_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_string_digit_3:
        .long 0xca11ab1e
        .long _string_digit_4
        .long 0
        .text
        .type _string_digit_4, @function
_string_digit_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_string_digit_5:
        .long 0xbabb1e
        .long 10
        .ascii "0123456789"
        .text
        push %eax
        movl $_string_digit_5, %eax
        # get procedure
        push %eax
        movl (_string_ref_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_char_Gtstring_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _string_digit_4, .-_string_digit_4
_string_digit_2:
        push %eax
        movl $_string_digit_3, %eax
        # initialize global variable with value
        movl %eax, (_string_digit_1)
        pop %eax
        .section .data
_number_Gtstring_2_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _number_Gtstring_2_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_number_Gtstring_2_3:
        .long 0xca11ab1e
        .long _number_Gtstring_2_4
        .long 0
        .text
        .type _number_Gtstring_2_4, @function
_number_Gtstring_2_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl $1 + 10<<2, %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_Lt_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _number_Gtstring_2_5
        push %eax
        movl $1 + 10<<2, %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_remainder_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_string_digit_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $1 + 10<<2, %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_quotient_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_number_Gtstring_2_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_string_append_1), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        jmp _number_Gtstring_2_6
_number_Gtstring_2_5:
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_string_digit_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
_number_Gtstring_2_6:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _number_Gtstring_2_4, .-_number_Gtstring_2_4
_number_Gtstring_2_2:
        push %eax
        movl $_number_Gtstring_2_3, %eax
        # initialize global variable with value
        movl %eax, (_number_Gtstring_2_1)
        pop %eax
        .section .data
_number_Gtstring_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _number_Gtstring_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_number_Gtstring_3:
        .long 0xca11ab1e
        .long _number_Gtstring_4
        .long 0
        .text
        .type _number_Gtstring_4, @function
_number_Gtstring_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl $1 + 0<<2, %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_Lt_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _number_Gtstring_5
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_number_Gtstring_2_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        jmp _number_Gtstring_6
_number_Gtstring_5:
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl $1 + 0<<2, %eax
        # inlined integer subtract
        call ensure_integer
        xchg %eax, (%esp)
        call ensure_integer
        sub %eax, (%esp)
        pop %eax
        inc %eax
        # get procedure
        push %eax
        movl (_number_Gtstring_2_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_number_Gtstring_7:
        .long 0xbabb1e
        .long 1
        .ascii "-"
        .text
        push %eax
        movl $_number_Gtstring_7, %eax
        # get procedure
        push %eax
        movl (_string_append_1), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
_number_Gtstring_6:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _number_Gtstring_4, .-_number_Gtstring_4
_number_Gtstring_2:
        push %eax
        movl $_number_Gtstring_3, %eax
        # initialize global variable with value
        movl %eax, (_number_Gtstring_1)
        pop %eax
        .section .data
_string_Gtnumber_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _string_Gtnumber_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_string_Gtnumber_3:
        .long 0xca11ab1e
        .long _string_Gtnumber_4
        .long 0
        .text
        .type _string_Gtnumber_4, @function
_string_Gtnumber_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # move arg from stack to heap: str
        push %eax
        movl 0(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # %ifeq
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # string-length inlined primitive
        call ensure_string
        lea 8(%eax), %ebx
        push %ebx
        movl 4(%eax), %eax
        pop %ebx
        sal %eax
        sal %eax
        inc %eax
        push %eax
        movl $1 + 0<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _string_Gtnumber_5
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_string_Gtnumber_7:
        .long 0xbabb1e
        .long 30
        .ascii "string->number of empty string"
        .text
        push %eax
        movl $_string_Gtnumber_7, %eax
        # get procedure
        push %eax
        movl (_string_Gtnumber_8), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        jmp _string_Gtnumber_6
_string_Gtnumber_5:
        push %eax
        movl $1 + 0<<2, %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_string_ref_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        # jump past the body of the lambda
        jmp _string_Gtnumber_9
        .text
        .type _string_Gtnumber_10, @function
_string_Gtnumber_10:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 str
        push 12(%eax)
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl $2 + 43<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _string_Gtnumber_11
        push %eax
        movl $1 + 0<<2, %eax
        push %eax
        movl $1 + 1<<2, %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_string_Gtnumber_13), %eax
        # apply procedure
        # Tail call; nargs = 3
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 8(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push -8(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        jmp *%ebx
        jmp _string_Gtnumber_12
_string_Gtnumber_11:
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl $2 + 45<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _string_Gtnumber_14
        push %eax
        movl $1 + 0<<2, %eax
        push %eax
        movl $1 + 1<<2, %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_string_Gtnumber_13), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        call *%ebx
        push %eax
        movl $1 + 0<<2, %eax
        # inlined integer subtract
        call ensure_integer
        xchg %eax, (%esp)
        call ensure_integer
        sub %eax, (%esp)
        pop %eax
        inc %eax
        jmp _string_Gtnumber_15
_string_Gtnumber_14:
        push %eax
        movl $1 + 0<<2, %eax
        push %eax
        movl $1 + 0<<2, %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_string_Gtnumber_13), %eax
        # apply procedure
        # Tail call; nargs = 3
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 8(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push -8(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        jmp *%ebx
_string_Gtnumber_15:
_string_Gtnumber_12:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _string_Gtnumber_10, .-_string_Gtnumber_10
_string_Gtnumber_9:
        # allocate bytes: 16
        push %eax
        movl (arena_pointer), %eax
        add $16, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_string_Gtnumber_10, 4(%ebx)
        movl $1, 8(%ebx)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
_string_Gtnumber_6:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _string_Gtnumber_4, .-_string_Gtnumber_4
_string_Gtnumber_2:
        push %eax
        movl $_string_Gtnumber_3, %eax
        # initialize global variable with value
        movl %eax, (_string_Gtnumber_1)
        pop %eax
        .section .data
_string_Gtnumber_13:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _string_Gtnumber_2_1
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_string_Gtnumber_2_2:
        .long 0xca11ab1e
        .long _string_Gtnumber_2_3
        .long 0
        .text
        .type _string_Gtnumber_2_3, @function
_string_Gtnumber_2_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $3, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # move arg from stack to heap: str
        push %eax
        movl 0(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # move arg from stack to heap: idx
        push %eax
        movl 4(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # move arg from stack to heap: sofar
        push %eax
        movl 8(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # %ifeq
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # string-length inlined primitive
        call ensure_string
        lea 8(%eax), %ebx
        push %ebx
        movl 4(%eax), %eax
        pop %ebx
        sal %eax
        sal %eax
        inc %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _string_Gtnumber_2_4
        # fetching heap var pointer 2
        push %eax
        movl -24(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        jmp _string_Gtnumber_2_5
_string_Gtnumber_2_4:
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_string_ref_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        # jump past the body of the lambda
        jmp _string_Gtnumber_2_6
        .text
        .type _string_Gtnumber_2_7, @function
_string_Gtnumber_2_7:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 str
        push 12(%eax)
        # fetch artifact from closure: 1 idx
        push 16(%eax)
        # fetch artifact from closure: 2 sofar
        push 20(%eax)
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl $2 + 57<<2, %eax
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl $2 + 48<<2, %eax
        # get procedure
        push %eax
        movl (_char_betweenP_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        call *%ebx
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _string_Gtnumber_2_8
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        push %eax
        movl 0(%ebp), %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_string_Gtnumber_2_10:
        .long 0xbabb1e
        .long 16
        .ascii "non-numeric char"
        .text
        push %eax
        movl $_string_Gtnumber_2_10, %eax
        # get procedure
        push %eax
        movl (_string_Gtnumber_8), %eax
        # apply procedure
        # Tail call; nargs = 3
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 8(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push -8(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        jmp *%ebx
        jmp _string_Gtnumber_2_9
_string_Gtnumber_2_8:
        push %eax
        movl $2 + 48<<2, %eax
        test $1, %eax
        jnz not_a_character
        test $2, %eax
        je not_a_character
        cmpl $2 + 256<<2, %eax
        jnb not_a_character
        dec %eax
        push %eax
        movl 0(%ebp), %eax
        test $1, %eax
        jnz not_a_character
        test $2, %eax
        je not_a_character
        cmpl $2 + 256<<2, %eax
        jnb not_a_character
        dec %eax
        # inlined integer subtract
        call ensure_integer
        xchg %eax, (%esp)
        call ensure_integer
        sub %eax, (%esp)
        pop %eax
        inc %eax
        # fetching heap var pointer 2
        push %eax
        movl -24(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_string_Gtnumber_2_11), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # inlined integer add
        call ensure_integer
        xchg %eax, (%esp)
        call ensure_integer
        pop %ebx
        add %ebx, %eax
        dec %eax
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # 1+
        call ensure_integer
        add $1<<2, %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_string_Gtnumber_13), %eax
        # apply procedure
        # Tail call; nargs = 3
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 8(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push -8(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        jmp *%ebx
_string_Gtnumber_2_9:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _string_Gtnumber_2_7, .-_string_Gtnumber_2_7
_string_Gtnumber_2_6:
        # allocate bytes: 24
        push %eax
        movl (arena_pointer), %eax
        add $24, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_string_Gtnumber_2_7, 4(%ebx)
        movl $3, 8(%ebx)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        movl %eax, 16(%ebx)
        pop %eax
        # fetching heap var pointer 2
        push %eax
        movl -24(%ebp), %eax
        movl %eax, 20(%ebx)
        pop %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
_string_Gtnumber_2_5:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _string_Gtnumber_2_3, .-_string_Gtnumber_2_3
_string_Gtnumber_2_1:
        push %eax
        movl $_string_Gtnumber_2_2, %eax
        # initialize global variable with value
        movl %eax, (_string_Gtnumber_13)
        pop %eax
        .section .data
_string_Gtnumber_2_11:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _10Star_1
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_10Star_2:
        .long 0xca11ab1e
        .long _10Star_3
        .long 0
        .text
        .type _10Star_3, @function
_10Star_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_10Star_4), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_10Star_5), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # inlined integer add
        call ensure_integer
        xchg %eax, (%esp)
        call ensure_integer
        pop %ebx
        add %ebx, %eax
        dec %eax
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _10Star_3, .-_10Star_3
_10Star_1:
        push %eax
        movl $_10Star_2, %eax
        # initialize global variable with value
        movl %eax, (_string_Gtnumber_2_11)
        pop %eax
        .section .data
_10Star_4:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _2Star_1
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_2Star_2:
        .long 0xca11ab1e
        .long _2Star_3
        .long 0
        .text
        .type _2Star_3, @function
_2Star_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl 0(%ebp), %eax
        # inlined integer add
        call ensure_integer
        xchg %eax, (%esp)
        call ensure_integer
        pop %ebx
        add %ebx, %eax
        dec %eax
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _2Star_3, .-_2Star_3
_2Star_1:
        push %eax
        movl $_2Star_2, %eax
        # initialize global variable with value
        movl %eax, (_10Star_4)
        pop %eax
        .section .data
_10Star_5:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _8Star_1
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_8Star_2:
        .long 0xca11ab1e
        .long _8Star_3
        .long 0
        .text
        .type _8Star_3, @function
_8Star_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_10Star_4), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_10Star_4), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_10Star_4), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _8Star_3, .-_8Star_3
_8Star_1:
        push %eax
        movl $_8Star_2, %eax
        # initialize global variable with value
        movl %eax, (_10Star_5)
        pop %eax
        .section .data
_newline_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _newline_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_newline_3:
        .long 0xca11ab1e
        .long _newline_4
        .long 0
        .text
        .type _newline_4, @function
_newline_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $0, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_newline_5:
        .long 0xbabb1e
        .long 1
        .ascii "\n"
        .text
        push %eax
        movl $_newline_5, %eax
        # get procedure
        push %eax
        movl (_display_2), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _newline_4, .-_newline_4
_newline_2:
        push %eax
        movl $_newline_3, %eax
        # initialize global variable with value
        movl %eax, (_newline_1)
        pop %eax
        .section .data
_string_Gtnumber_8:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _error_1
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_error_2:
        .long 0xca11ab1e
        .long _error_3
        .long 0
        .text
        .type _error_3, @function
_error_3:
        # make space for variadic argument list
        pop %ebx
        push %ebx
        push %ebx
        # push desired %esp on return
        lea 8(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        call package_up_variadic_args
        # discarding useless value in %eax
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_error_4:
        .long 0xbabb1e
        .long 7
        .ascii "error: "
        .text
        push %eax
        movl $_error_4, %eax
        # get procedure
        push %eax
        movl (_display_stderr_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # jump past the body of the lambda
        jmp _error_5
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_error_6:
        .long 0xca11ab1e
        .long _error_7
        .long 0
        .text
        .type _error_7, @function
_error_7:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl (_display_stderr_2), %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_error_8), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_error_9:
        .long 0xbabb1e
        .long 1
        .ascii " "
        .text
        push %eax
        movl $_error_9, %eax
        # get procedure
        push %eax
        movl (_display_stderr_2), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _error_7, .-_error_7
_error_5:
        push %eax
        movl $_error_6, %eax
        # get procedure
        push %eax
        movl (_for_each_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_error_10:
        .long 0xbabb1e
        .long 1
        .ascii "\n"
        .text
        push %eax
        movl $_error_10, %eax
        # get procedure
        push %eax
        movl (_display_stderr_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl $1 + 1<<2, %eax
        # get procedure
        push %eax
        movl (_exit_2), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _error_3, .-_error_3
_error_1:
        push %eax
        movl $_error_2, %eax
        # initialize global variable with value
        movl %eax, (_string_Gtnumber_8)
        pop %eax
        .section .data
_escape_char_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _escape_char_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_escape_char_3:
        .long 0xca11ab1e
        .long _escape_char_4
        .long 0
        .text
        .type _escape_char_4, @function
_escape_char_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $3, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 4(%ebp), %eax
        push %eax
        movl $2 + 256<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _escape_char_5
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_char_Gtstring_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        jmp _escape_char_6
_escape_char_5:
        # %ifeq
        push %eax
        movl $1 + 0<<2, %eax
        push %eax
        movl 4(%ebp), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_string_ref_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_charEqP_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _escape_char_7
        push %eax
        movl 8(%ebp), %eax
        # inlined cdr
        call ensure_cons
        movl 8(%eax), %eax
        push %eax
        movl 4(%ebp), %eax
        # inlined cdr
        call ensure_cons
        movl 8(%eax), %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_escape_char_1), %eax
        # apply procedure
        # Tail call; nargs = 3
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 8(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push -8(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        jmp *%ebx
        jmp _escape_char_8
_escape_char_7:
        push %eax
        movl 8(%ebp), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
_escape_char_8:
_escape_char_6:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _escape_char_4, .-_escape_char_4
_escape_char_2:
        push %eax
        movl $_escape_char_3, %eax
        # initialize global variable with value
        movl %eax, (_escape_char_1)
        pop %eax
        .section .data
_escape_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _escape_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_escape_3:
        .long 0xca11ab1e
        .long _escape_4
        .long 0
        .text
        .type _escape_4, @function
_escape_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $4, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 4(%ebp), %eax
        push %eax
        movl 0(%ebp), %eax
        # string-length inlined primitive
        call ensure_string
        lea 8(%eax), %ebx
        push %ebx
        movl 4(%eax), %eax
        pop %ebx
        sal %eax
        sal %eax
        inc %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _escape_5
        push %eax
        movl $2 + 256<<2, %eax
        jmp _escape_6
_escape_5:
        push %eax
        movl 12(%ebp), %eax
        push %eax
        movl 8(%ebp), %eax
        push %eax
        movl 4(%ebp), %eax
        # 1+
        call ensure_integer
        add $1<<2, %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_escape_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $4, %edx
        call *%ebx
        push %eax
        movl 12(%ebp), %eax
        push %eax
        movl 8(%ebp), %eax
        push %eax
        movl 4(%ebp), %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_string_ref_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_escape_char_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_cons_2), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
_escape_6:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _escape_4, .-_escape_4
_escape_2:
        push %eax
        movl $_escape_3, %eax
        # initialize global variable with value
        movl %eax, (_escape_1)
        pop %eax
        .section .data
_backslash_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _backslash_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_backslash_3:
        .long 0xca11ab1e
        .long _backslash_4
        .long 0
        .text
        .type _backslash_4, @function
_backslash_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_backslash_6:
        .long 0xbabb1e
        .long 2
        .ascii "\\\\"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_backslash_8:
        .long 0xbabb1e
        .long 2
        .ascii "\\n"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_backslash_10:
        .long 0xbabb1e
        .long 2
        .ascii "\\\""
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_backslash_9:
        .long 0x2ce11ed
        .long _backslash_10
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_backslash_7:
        .long 0x2ce11ed
        .long _backslash_8
        .long _backslash_9
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_backslash_5:
        .long 0x2ce11ed
        .long _backslash_6
        .long _backslash_7
        .text
        push %eax
        movl $_backslash_5, %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_backslash_12:
        .long 0xbabb1e
        .long 1
        .ascii "\\"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_backslash_14:
        .long 0xbabb1e
        .long 1
        .ascii "\n"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_backslash_16:
        .long 0xbabb1e
        .long 1
        .ascii "\""
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_backslash_15:
        .long 0x2ce11ed
        .long _backslash_16
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_backslash_13:
        .long 0x2ce11ed
        .long _backslash_14
        .long _backslash_15
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_backslash_11:
        .long 0x2ce11ed
        .long _backslash_12
        .long _backslash_13
        .text
        push %eax
        movl $_backslash_11, %eax
        push %eax
        movl $1 + 0<<2, %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_escape_1), %eax
        # apply procedure
        # Tail call; nargs = 4
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 12(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push -8(%ebx)
        push -12(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $4, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _backslash_4, .-_backslash_4
_backslash_2:
        push %eax
        movl $_backslash_3, %eax
        # initialize global variable with value
        movl %eax, (_backslash_1)
        pop %eax
        .section .data
_write_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _write_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_write_3:
        .long 0xca11ab1e
        .long _write_4
        .long 0
        .text
        .type _write_4, @function
_write_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl (_display_2), %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_error_8), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _write_4, .-_write_4
_write_2:
        push %eax
        movl $_write_3, %eax
        # initialize global variable with value
        movl %eax, (_write_1)
        pop %eax
        .section .data
_error_8:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _wthunk_1
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_wthunk_2:
        .long 0xca11ab1e
        .long _wthunk_3
        .long 0
        .text
        .type _wthunk_3, @function
_wthunk_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $2, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # move arg from stack to heap: x
        push %eax
        movl 0(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # %ifeq
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_stringP_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _wthunk_4
        # %ifeq
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_pairP_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        # jump past the body of the lambda
        jmp _wthunk_8
        .text
        .type _wthunk_9, @function
_wthunk_9:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 x
        push 12(%eax)
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _wthunk_10
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_nullP_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        jmp _wthunk_11
_wthunk_10:
        push %eax
        movl 0(%ebp), %eax
_wthunk_11:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _wthunk_9, .-_wthunk_9
_wthunk_8:
        # allocate bytes: 16
        push %eax
        movl (arena_pointer), %eax
        add $16, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_wthunk_9, 4(%ebx)
        movl $1, 8(%ebx)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _wthunk_6
        # %ifeq
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_symbolP_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _wthunk_12
        # %ifeq
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_numberP_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _wthunk_14
        # %ifeq
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        push %eax
        movl $2 + 257<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _wthunk_16
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_wthunk_18:
        .long 0xbabb1e
        .long 2
        .ascii "#t"
        .text
        push %eax
        movl $_wthunk_18, %eax
        # get procedure
        push %eax
        movl 4(%ebp), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        jmp _wthunk_17
_wthunk_16:
        # %ifeq
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _wthunk_19
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_wthunk_21:
        .long 0xbabb1e
        .long 2
        .ascii "#f"
        .text
        push %eax
        movl $_wthunk_21, %eax
        # get procedure
        push %eax
        movl 4(%ebp), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        jmp _wthunk_20
_wthunk_19:
        # %ifeq
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        push %eax
        movl $2 + 10<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _wthunk_22
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_wthunk_24:
        .long 0xbabb1e
        .long 9
        .ascii "#\\newline"
        .text
        push %eax
        movl $_wthunk_24, %eax
        # get procedure
        push %eax
        movl 4(%ebp), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        jmp _wthunk_23
_wthunk_22:
        # %ifeq
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        push %eax
        movl $2 + 32<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _wthunk_25
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_wthunk_27:
        .long 0xbabb1e
        .long 7
        .ascii "#\\space"
        .text
        push %eax
        movl $_wthunk_27, %eax
        # get procedure
        push %eax
        movl 4(%ebp), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        jmp _wthunk_26
_wthunk_25:
        # %ifeq
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        push %eax
        movl $2 + 9<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _wthunk_28
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_wthunk_30:
        .long 0xbabb1e
        .long 5
        .ascii "#\\tab"
        .text
        push %eax
        movl $_wthunk_30, %eax
        # get procedure
        push %eax
        movl 4(%ebp), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        jmp _wthunk_29
_wthunk_28:
        # %ifeq
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_charP_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _wthunk_31
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_wthunk_33:
        .long 0xbabb1e
        .long 23
        .ascii "don't know how to write"
        .text
        push %eax
        movl $_wthunk_33, %eax
        # get procedure
        push %eax
        movl (_string_Gtnumber_8), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        jmp _wthunk_32
_wthunk_31:
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_wthunk_34:
        .long 0xbabb1e
        .long 2
        .ascii "#\\"
        .text
        push %eax
        movl $_wthunk_34, %eax
        # get procedure
        push %eax
        movl 4(%ebp), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_char_Gtstring_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl 4(%ebp), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
_wthunk_32:
_wthunk_29:
_wthunk_26:
_wthunk_23:
_wthunk_20:
_wthunk_17:
        jmp _wthunk_15
_wthunk_14:
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_number_Gtstring_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl 4(%ebp), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
_wthunk_15:
        jmp _wthunk_13
_wthunk_12:
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        call ensure_symbol
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl 4(%ebp), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
_wthunk_13:
        jmp _wthunk_7
_wthunk_6:
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_wthunk_35:
        .long 0xbabb1e
        .long 1
        .ascii "("
        .text
        push %eax
        movl $_wthunk_35, %eax
        # get procedure
        push %eax
        movl 4(%ebp), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl 4(%ebp), %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_wthunk_36), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
_wthunk_7:
        jmp _wthunk_5
_wthunk_4:
        push %eax
        movl 4(%ebp), %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_wthunk_37), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
_wthunk_5:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _wthunk_3, .-_wthunk_3
_wthunk_1:
        push %eax
        movl $_wthunk_2, %eax
        # initialize global variable with value
        movl %eax, (_error_8)
        pop %eax
        .section .data
_wthunk_37:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _wstring_1
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_wstring_2:
        .long 0xca11ab1e
        .long _wstring_3
        .long 0
        .text
        .type _wstring_3, @function
_wstring_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $2, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_wstring_4:
        .long 0xbabb1e
        .long 1
        .ascii "\""
        .text
        push %eax
        movl $_wstring_4, %eax
        # get procedure
        push %eax
        movl 4(%ebp), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_backslash_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl 4(%ebp), %eax
        # get procedure
        push %eax
        movl (_for_each_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_wstring_5:
        .long 0xbabb1e
        .long 1
        .ascii "\""
        .text
        push %eax
        movl $_wstring_5, %eax
        # get procedure
        push %eax
        movl 4(%ebp), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _wstring_3, .-_wstring_3
_wstring_1:
        push %eax
        movl $_wstring_2, %eax
        # initialize global variable with value
        movl %eax, (_wthunk_37)
        pop %eax
        .section .data
_wthunk_36:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _wlist_1
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_wlist_2:
        .long 0xca11ab1e
        .long _wlist_3
        .long 0
        .text
        .type _wlist_3, @function
_wlist_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $2, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl $2 + 256<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _wlist_4
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_wlist_6:
        .long 0xbabb1e
        .long 1
        .ascii ")"
        .text
        push %eax
        movl $_wlist_6, %eax
        # get procedure
        push %eax
        movl 4(%ebp), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        jmp _wlist_5
_wlist_4:
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_pairP_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _wlist_7
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_wlist_9:
        .long 0xbabb1e
        .long 2
        .ascii ". "
        .text
        push %eax
        movl $_wlist_9, %eax
        # get procedure
        push %eax
        movl 4(%ebp), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl 4(%ebp), %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_error_8), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_wlist_10:
        .long 0xbabb1e
        .long 1
        .ascii ")"
        .text
        push %eax
        movl $_wlist_10, %eax
        # get procedure
        push %eax
        movl 4(%ebp), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        jmp _wlist_8
_wlist_7:
        push %eax
        movl 4(%ebp), %eax
        push %eax
        movl 0(%ebp), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_error_8), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        # inlined cdr
        call ensure_cons
        movl 8(%eax), %eax
        push %eax
        movl $2 + 256<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _wlist_11
        push %eax
        movl $2 + 258<<2, %eax
        jmp _wlist_12
_wlist_11:
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_wlist_13:
        .long 0xbabb1e
        .long 1
        .ascii " "
        .text
        push %eax
        movl $_wlist_13, %eax
        # get procedure
        push %eax
        movl 4(%ebp), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
_wlist_12:
        pop %eax
        push %eax
        movl 4(%ebp), %eax
        push %eax
        movl 0(%ebp), %eax
        # inlined cdr
        call ensure_cons
        movl 8(%eax), %eax
        # get procedure
        push %eax
        movl (_wthunk_36), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
_wlist_8:
_wlist_5:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _wlist_3, .-_wlist_3
_wlist_1:
        push %eax
        movl $_wlist_2, %eax
        # initialize global variable with value
        movl %eax, (_wthunk_36)
        pop %eax
        # (end of standard library prologue)
        .section .data
_double_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _double_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_double_3:
        .long 0xca11ab1e
        .long _double_4
        .long 0
        .text
        .type _double_4, @function
_double_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl 0(%ebp), %eax
        # inlined integer add
        call ensure_integer
        xchg %eax, (%esp)
        call ensure_integer
        pop %ebx
        add %ebx, %eax
        dec %eax
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _double_4, .-_double_4
_double_2:
        push %eax
        movl $_double_3, %eax
        # initialize global variable with value
        movl %eax, (_double_1)
        pop %eax
        .section .data
_quadruple_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _quadruple_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_quadruple_3:
        .long 0xca11ab1e
        .long _quadruple_4
        .long 0
        .text
        .type _quadruple_4, @function
_quadruple_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_double_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_double_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _quadruple_4, .-_quadruple_4
_quadruple_2:
        push %eax
        movl $_quadruple_3, %eax
        # initialize global variable with value
        movl %eax, (_quadruple_1)
        pop %eax
        push %eax
        movl $2 + 256<<2, %eax
        movl %eax, (_1Plus_1)
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _quadruple_5
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_quadruple_6:
        .long 0xca11ab1e
        .long _quadruple_7
        .long 0
        .text
        .type _quadruple_7, @function
_quadruple_7:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl $1 + 1<<2, %eax
        push %eax
        movl 0(%ebp), %eax
        # inlined integer add
        call ensure_integer
        xchg %eax, (%esp)
        call ensure_integer
        pop %ebx
        add %ebx, %eax
        dec %eax
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _quadruple_7, .-_quadruple_7
_quadruple_5:
        push %eax
        movl $_quadruple_6, %eax
        # initialize global variable with value
        movl %eax, (_1Plus_1)
        pop %eax
        push %eax
        movl $2 + 256<<2, %eax
        movl %eax, (_1__1)
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _quadruple_8
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_quadruple_9:
        .long 0xca11ab1e
        .long _quadruple_10
        .long 0
        .text
        .type _quadruple_10, @function
_quadruple_10:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl $1 + 1<<2, %eax
        push %eax
        movl 0(%ebp), %eax
        # inlined integer subtract
        call ensure_integer
        xchg %eax, (%esp)
        call ensure_integer
        sub %eax, (%esp)
        pop %eax
        inc %eax
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _quadruple_10, .-_quadruple_10
_quadruple_8:
        push %eax
        movl $_quadruple_9, %eax
        # initialize global variable with value
        movl %eax, (_1__1)
        pop %eax
        push %eax
        movl $2 + 256<<2, %eax
        movl %eax, (_reduce_1)
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _quadruple_11
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_quadruple_12:
        .long 0xca11ab1e
        .long _quadruple_13
        .long 0
        .text
        .type _quadruple_13, @function
_quadruple_13:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $3, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 4(%ebp), %eax
        push %eax
        movl $2 + 256<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _quadruple_14
        push %eax
        movl 8(%ebp), %eax
        jmp _quadruple_15
_quadruple_14:
        push %eax
        movl 8(%ebp), %eax
        push %eax
        movl 4(%ebp), %eax
        # inlined cdr
        call ensure_cons
        movl 8(%eax), %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_reduce_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        call *%ebx
        push %eax
        movl 4(%ebp), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl 0(%ebp), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
_quadruple_15:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _quadruple_13, .-_quadruple_13
_quadruple_11:
        push %eax
        movl $_quadruple_12, %eax
        # initialize global variable with value
        movl %eax, (_reduce_1)
        pop %eax
        .section .data
_filter_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _filter_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_filter_3:
        .long 0xca11ab1e
        .long _filter_4
        .long 0
        .text
        .type _filter_4, @function
_filter_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $2, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # move arg from stack to heap: fn
        push %eax
        movl 0(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # %ifeq
        push %eax
        movl 4(%ebp), %eax
        push %eax
        movl $2 + 256<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _filter_5
        push %eax
        movl $2 + 256<<2, %eax
        jmp _filter_6
_filter_5:
        push %eax
        movl 4(%ebp), %eax
        # inlined cdr
        call ensure_cons
        movl 8(%eax), %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_filter_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        push %eax
        movl 4(%ebp), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        # get procedure
        # jump past the body of the lambda
        jmp _filter_7
        .text
        .type _filter_8, @function
_filter_8:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $2, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 fn
        push 12(%eax)
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _filter_9
        push %eax
        movl 4(%ebp), %eax
        jmp _filter_10
_filter_9:
        push %eax
        movl 4(%ebp), %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_cons_2), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
_filter_10:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _filter_8, .-_filter_8
_filter_7:
        # allocate bytes: 16
        push %eax
        movl (arena_pointer), %eax
        add $16, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_filter_8, 4(%ebx)
        movl $1, 8(%ebx)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
_filter_6:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _filter_4, .-_filter_4
_filter_2:
        push %eax
        movl $_filter_3, %eax
        # initialize global variable with value
        movl %eax, (_filter_1)
        pop %eax
        push %eax
        movl $2 + 256<<2, %eax
        movl %eax, (_char_Gtstring_1)
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _filter_11
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_filter_12:
        .long 0xca11ab1e
        .long _filter_13
        .long 0
        .text
        .type _filter_13, @function
_filter_13:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # move arg from stack to heap: char
        push %eax
        movl 0(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        push %eax
        movl $1 + 1<<2, %eax
        # get procedure
        push %eax
        movl (_make_string_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        # jump past the body of the lambda
        jmp _filter_14
        .text
        .type _filter_15, @function
_filter_15:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 char
        push 12(%eax)
        # discarding useless value in %eax
        pop %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        push %eax
        movl $1 + 0<<2, %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_string_setBang_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        call *%ebx
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _filter_15, .-_filter_15
_filter_14:
        # allocate bytes: 16
        push %eax
        movl (arena_pointer), %eax
        add $16, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_filter_15, 4(%ebx)
        movl $1, 8(%ebx)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _filter_13, .-_filter_13
_filter_11:
        push %eax
        movl $_filter_12, %eax
        # initialize global variable with value
        movl %eax, (_char_Gtstring_1)
        pop %eax
        .section .data
_assert_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _assert_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_assert_3:
        .long 0xca11ab1e
        .long _assert_4
        .long 0
        .text
        .type _assert_4, @function
_assert_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $2, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _assert_5
        push %eax
        movl 4(%ebp), %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_assert_7:
        .long 0xbabb1e
        .long 15
        .ascii "surprise! error"
        .text
        push %eax
        movl $_assert_7, %eax
        # get procedure
        push %eax
        movl (_string_Gtnumber_8), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        jmp _assert_6
_assert_5:
        push %eax
        movl $2 + 256<<2, %eax
_assert_6:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _assert_4, .-_assert_4
_assert_2:
        push %eax
        movl $_assert_3, %eax
        # initialize global variable with value
        movl %eax, (_assert_1)
        pop %eax
        push %eax
        movl $2 + 256<<2, %eax
        movl %eax, (_string_append_7)
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _assert_8
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_assert_9:
        .long 0xca11ab1e
        .long _assert_10
        .long 0
        .text
        .type _assert_10, @function
_assert_10:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $5, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 8(%ebp), %eax
        push %eax
        movl $1 + 0<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _assert_11
        push %eax
        movl $2 + 258<<2, %eax
        jmp _assert_12
_assert_11:
        push %eax
        movl 4(%ebp), %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_string_ref_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        push %eax
        movl 16(%ebp), %eax
        push %eax
        movl 12(%ebp), %eax
        # get procedure
        push %eax
        movl (_string_setBang_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        call *%ebx
        pop %eax
        push %eax
        movl 16(%ebp), %eax
        # 1+
        call ensure_integer
        add $1<<2, %eax
        push %eax
        movl 12(%ebp), %eax
        push %eax
        movl 8(%ebp), %eax
        call ensure_integer
        add $-1<<2, %eax
        push %eax
        movl 4(%ebp), %eax
        # 1+
        call ensure_integer
        add $1<<2, %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_string_append_7), %eax
        # apply procedure
        # Tail call; nargs = 5
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 16(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push -8(%ebx)
        push -12(%ebx)
        push -16(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $5, %edx
        jmp *%ebx
_assert_12:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _assert_10, .-_assert_10
_assert_8:
        push %eax
        movl $_assert_9, %eax
        # initialize global variable with value
        movl %eax, (_string_append_7)
        pop %eax
        .section .data
_assembly_diversions_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        push %eax
        movl $2 + 258<<2, %eax
        # initialize global variable with value
        movl %eax, (_assembly_diversions_1)
        pop %eax
        .section .data
_diverted_assembly_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        push %eax
        movl $2 + 256<<2, %eax
        # initialize global variable with value
        movl %eax, (_diverted_assembly_1)
        pop %eax
        .section .data
_asm_display_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _asm_display_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_asm_display_3:
        .long 0xca11ab1e
        .long _asm_display_4
        .long 0
        .text
        .type _asm_display_4, @function
_asm_display_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl (_assembly_diversions_1), %eax
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _asm_display_5
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_display_2), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        jmp _asm_display_6
_asm_display_5:
        push %eax
        movl (_diverted_assembly_1), %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_cons_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        movl %eax, (_diverted_assembly_1)
_asm_display_6:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _asm_display_4, .-_asm_display_4
_asm_display_2:
        push %eax
        movl $_asm_display_3, %eax
        # initialize global variable with value
        movl %eax, (_asm_display_1)
        pop %eax
        .section .data
_push_assembly_diversion_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _push_assembly_diversion_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_push_assembly_diversion_3:
        .long 0xca11ab1e
        .long _push_assembly_diversion_4
        .long 0
        .text
        .type _push_assembly_diversion_4, @function
_push_assembly_diversion_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $0, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_push_assembly_diversion_5:
        .long 0xbabb1e
        .long 16
        .ascii "already diverted"
        .text
        push %eax
        movl $_push_assembly_diversion_5, %eax
        push %eax
        movl (_assembly_diversions_1), %eax
        # get procedure
        push %eax
        movl (_not_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_assert_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl $2 + 257<<2, %eax
        movl %eax, (_assembly_diversions_1)
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _push_assembly_diversion_4, .-_push_assembly_diversion_4
_push_assembly_diversion_2:
        push %eax
        movl $_push_assembly_diversion_3, %eax
        # initialize global variable with value
        movl %eax, (_push_assembly_diversion_1)
        pop %eax
        .section .data
_pop_diverted_assembly_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _pop_diverted_assembly_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_pop_diverted_assembly_3:
        .long 0xca11ab1e
        .long _pop_diverted_assembly_4
        .long 0
        .text
        .type _pop_diverted_assembly_4, @function
_pop_diverted_assembly_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $0, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl (_diverted_assembly_1), %eax
        # get procedure
        push %eax
        movl (_reverse_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_pop_diverted_assembly_5), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        # jump past the body of the lambda
        jmp _pop_diverted_assembly_6
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_pop_diverted_assembly_7:
        .long 0xca11ab1e
        .long _pop_diverted_assembly_8
        .long 0
        .text
        .type _pop_diverted_assembly_8, @function
_pop_diverted_assembly_8:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl $2 + 258<<2, %eax
        movl %eax, (_assembly_diversions_1)
        pop %eax
        push %eax
        movl $2 + 256<<2, %eax
        movl %eax, (_diverted_assembly_1)
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _pop_diverted_assembly_8, .-_pop_diverted_assembly_8
_pop_diverted_assembly_6:
        push %eax
        movl $_pop_diverted_assembly_7, %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _pop_diverted_assembly_4, .-_pop_diverted_assembly_4
_pop_diverted_assembly_2:
        push %eax
        movl $_pop_diverted_assembly_3, %eax
        # initialize global variable with value
        movl %eax, (_pop_diverted_assembly_1)
        pop %eax
        .section .data
_emit_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _emit_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_emit_3:
        .long 0xca11ab1e
        .long _emit_4
        .long 0
        .text
        .type _emit_4, @function
_emit_4:
        # make space for variadic argument list
        pop %ebx
        push %ebx
        push %ebx
        # push desired %esp on return
        lea 8(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        call package_up_variadic_args
        # discarding useless value in %eax
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_emit_5:
        .long 0xbabb1e
        .long 1
        .ascii "\n"
        .text
        push %eax
        movl $_emit_5, %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_cons_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_pop_diverted_assembly_5), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_asm_display_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _emit_4, .-_emit_4
_emit_2:
        push %eax
        movl $_emit_3, %eax
        # initialize global variable with value
        movl %eax, (_emit_1)
        pop %eax
        .section .data
_pop_diverted_assembly_5:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _asm_flatten_1
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_asm_flatten_2:
        .long 0xca11ab1e
        .long _asm_flatten_3
        .long 0
        .text
        .type _asm_flatten_3, @function
_asm_flatten_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # move arg from stack to heap: stuff
        push %eax
        movl 0(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_asm_flatten_4), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_make_string_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        # jump past the body of the lambda
        jmp _asm_flatten_5
        .text
        .type _asm_flatten_6, @function
_asm_flatten_6:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 stuff
        push 12(%eax)
        # discarding useless value in %eax
        pop %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        push %eax
        movl $1 + 0<<2, %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_asm_flatten_7), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        call *%ebx
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _asm_flatten_6, .-_asm_flatten_6
_asm_flatten_5:
        # allocate bytes: 16
        push %eax
        movl (arena_pointer), %eax
        add $16, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_asm_flatten_6, 4(%ebx)
        movl $1, 8(%ebx)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _asm_flatten_3, .-_asm_flatten_3
_asm_flatten_1:
        push %eax
        movl $_asm_flatten_2, %eax
        # initialize global variable with value
        movl %eax, (_pop_diverted_assembly_5)
        pop %eax
        .section .data
_asm_flatten_4:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _asm_flatten_size_1
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_asm_flatten_size_2:
        .long 0xca11ab1e
        .long _asm_flatten_size_3
        .long 0
        .text
        .type _asm_flatten_size_3, @function
_asm_flatten_size_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl $2 + 256<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _asm_flatten_size_4
        push %eax
        movl $1 + 0<<2, %eax
        jmp _asm_flatten_size_5
_asm_flatten_size_4:
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_pairP_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _asm_flatten_size_6
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_stringP_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _asm_flatten_size_8
        push %eax
        movl 0(%ebp), %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_asm_flatten_size_10:
        .long 0xbabb1e
        .long 12
        .ascii "flatten-size"
        .text
        push %eax
        movl $_asm_flatten_size_10, %eax
        # get procedure
        push %eax
        movl (_string_Gtnumber_8), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        jmp _asm_flatten_size_9
_asm_flatten_size_8:
        push %eax
        movl 0(%ebp), %eax
        # string-length inlined primitive
        call ensure_string
        lea 8(%eax), %ebx
        push %ebx
        movl 4(%eax), %eax
        pop %ebx
        sal %eax
        sal %eax
        inc %eax
_asm_flatten_size_9:
        jmp _asm_flatten_size_7
_asm_flatten_size_6:
        push %eax
        movl 0(%ebp), %eax
        # inlined cdr
        call ensure_cons
        movl 8(%eax), %eax
        # get procedure
        push %eax
        movl (_asm_flatten_4), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl 0(%ebp), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_asm_flatten_4), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # inlined integer add
        call ensure_integer
        xchg %eax, (%esp)
        call ensure_integer
        pop %ebx
        add %ebx, %eax
        dec %eax
_asm_flatten_size_7:
_asm_flatten_size_5:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _asm_flatten_size_3, .-_asm_flatten_size_3
_asm_flatten_size_1:
        push %eax
        movl $_asm_flatten_size_2, %eax
        # initialize global variable with value
        movl %eax, (_asm_flatten_4)
        pop %eax
        .section .data
_asm_flatten_7:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _asm_flatten_inner_1
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_asm_flatten_inner_2:
        .long 0xca11ab1e
        .long _asm_flatten_inner_3
        .long 0
        .text
        .type _asm_flatten_inner_3, @function
_asm_flatten_inner_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $3, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 8(%ebp), %eax
        push %eax
        movl $2 + 256<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _asm_flatten_inner_4
        push %eax
        movl 4(%ebp), %eax
        jmp _asm_flatten_inner_5
_asm_flatten_inner_4:
        # %ifeq
        push %eax
        movl 8(%ebp), %eax
        # get procedure
        push %eax
        movl (_pairP_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _asm_flatten_inner_6
        # %ifeq
        push %eax
        movl 8(%ebp), %eax
        # get procedure
        push %eax
        movl (_stringP_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _asm_flatten_inner_8
        push %eax
        movl 8(%ebp), %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_asm_flatten_inner_10:
        .long 0xbabb1e
        .long 10
        .ascii "flattening"
        .text
        push %eax
        movl $_asm_flatten_inner_10, %eax
        # get procedure
        push %eax
        movl (_string_Gtnumber_8), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        jmp _asm_flatten_inner_9
_asm_flatten_inner_8:
        push %eax
        movl 4(%ebp), %eax
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl 8(%ebp), %eax
        # string-length inlined primitive
        call ensure_string
        lea 8(%eax), %ebx
        push %ebx
        movl 4(%eax), %eax
        pop %ebx
        sal %eax
        sal %eax
        inc %eax
        push %eax
        movl $1 + 0<<2, %eax
        push %eax
        movl 8(%ebp), %eax
        # get procedure
        push %eax
        movl (_string_append_7), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $5, %edx
        call *%ebx
        pop %eax
        push %eax
        movl 8(%ebp), %eax
        # string-length inlined primitive
        call ensure_string
        lea 8(%eax), %ebx
        push %ebx
        movl 4(%eax), %eax
        pop %ebx
        sal %eax
        sal %eax
        inc %eax
        push %eax
        movl 4(%ebp), %eax
        # inlined integer add
        call ensure_integer
        xchg %eax, (%esp)
        call ensure_integer
        pop %ebx
        add %ebx, %eax
        dec %eax
_asm_flatten_inner_9:
        jmp _asm_flatten_inner_7
_asm_flatten_inner_6:
        push %eax
        movl 8(%ebp), %eax
        # inlined cdr
        call ensure_cons
        movl 8(%eax), %eax
        push %eax
        movl 8(%ebp), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        push %eax
        movl 4(%ebp), %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_asm_flatten_7), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        call *%ebx
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_asm_flatten_7), %eax
        # apply procedure
        # Tail call; nargs = 3
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 8(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push -8(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        jmp *%ebx
_asm_flatten_inner_7:
_asm_flatten_inner_5:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _asm_flatten_inner_3, .-_asm_flatten_inner_3
_asm_flatten_inner_1:
        push %eax
        movl $_asm_flatten_inner_2, %eax
        # initialize global variable with value
        movl %eax, (_asm_flatten_7)
        pop %eax
        .section .data
_memo1_asm_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _memo1_asm_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_memo1_asm_3:
        .long 0xca11ab1e
        .long _memo1_asm_4
        .long 0
        .text
        .type _memo1_asm_4, @function
_memo1_asm_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # move arg from stack to heap: proc
        push %eax
        movl 0(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        push %eax
        movl $2 + 256<<2, %eax
        # get procedure
        # jump past the body of the lambda
        jmp _memo1_asm_5
        .text
        .type _memo1_asm_6, @function
_memo1_asm_6:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 proc
        push 12(%eax)
        # discarding useless value in %eax
        pop %eax
        # move arg from stack to heap: results
        push %eax
        movl 0(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # jump past the body of the lambda
        jmp _memo1_asm_7
        .text
        .type _memo1_asm_8, @function
_memo1_asm_8:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 proc
        push 12(%eax)
        # fetch artifact from closure: 1 results
        push 16(%eax)
        # discarding useless value in %eax
        pop %eax
        # move arg from stack to heap: arg
        push %eax
        movl 0(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # fetching heap var pointer 2
        push %eax
        movl -24(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_assq_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        # jump past the body of the lambda
        jmp _memo1_asm_9
        .text
        .type _memo1_asm_10, @function
_memo1_asm_10:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 results
        push 12(%eax)
        # fetch artifact from closure: 1 proc
        push 16(%eax)
        # fetch artifact from closure: 2 arg
        push 20(%eax)
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _memo1_asm_11
        # get procedure
        push %eax
        movl (_push_assembly_diversion_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        pop %eax
        # fetching heap var pointer 2
        push %eax
        movl -24(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        # jump past the body of the lambda
        jmp _memo1_asm_13
        .text
        .type _memo1_asm_14, @function
_memo1_asm_14:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 arg
        push 12(%eax)
        # fetch artifact from closure: 1 results
        push 16(%eax)
        # discarding useless value in %eax
        pop %eax
        # move arg from stack to heap: result
        push %eax
        movl 0(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # get procedure
        push %eax
        movl (_pop_diverted_assembly_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        # get procedure
        # jump past the body of the lambda
        jmp _memo1_asm_15
        .text
        .type _memo1_asm_16, @function
_memo1_asm_16:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 arg
        push 12(%eax)
        # fetch artifact from closure: 1 results
        push 16(%eax)
        # fetch artifact from closure: 2 result
        push 20(%eax)
        # discarding useless value in %eax
        pop %eax
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # fetching heap var pointer 2
        push %eax
        movl -24(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        push %eax
        movl 0(%ebp), %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_list_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_cons_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        movl (%esp), %ebx
        movl %ebx, 4(%eax)
        pop %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_asm_display_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        # fetching heap var pointer 2
        push %eax
        movl -24(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _memo1_asm_16, .-_memo1_asm_16
_memo1_asm_15:
        # allocate bytes: 24
        push %eax
        movl (arena_pointer), %eax
        add $24, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_memo1_asm_16, 4(%ebx)
        movl $3, 8(%ebx)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        movl %eax, 16(%ebx)
        pop %eax
        # fetching heap var pointer 2
        push %eax
        movl -24(%ebp), %eax
        movl %eax, 20(%ebx)
        pop %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _memo1_asm_14, .-_memo1_asm_14
_memo1_asm_13:
        # allocate bytes: 20
        push %eax
        movl (arena_pointer), %eax
        add $20, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_memo1_asm_14, 4(%ebx)
        movl $2, 8(%ebx)
        # fetching heap var pointer 2
        push %eax
        movl -24(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl %eax, 16(%ebx)
        pop %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        jmp _memo1_asm_12
_memo1_asm_11:
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_cadr_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_asm_display_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_caddr_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
_memo1_asm_12:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _memo1_asm_10, .-_memo1_asm_10
_memo1_asm_9:
        # allocate bytes: 24
        push %eax
        movl (arena_pointer), %eax
        add $24, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_memo1_asm_10, 4(%ebx)
        movl $3, 8(%ebx)
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl %eax, 16(%ebx)
        pop %eax
        # fetching heap var pointer 2
        push %eax
        movl -24(%ebp), %eax
        movl %eax, 20(%ebx)
        pop %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _memo1_asm_8, .-_memo1_asm_8
_memo1_asm_7:
        # allocate bytes: 20
        push %eax
        movl (arena_pointer), %eax
        add $20, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_memo1_asm_8, 4(%ebx)
        movl $2, 8(%ebx)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        movl %eax, 16(%ebx)
        pop %eax
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _memo1_asm_6, .-_memo1_asm_6
_memo1_asm_5:
        # allocate bytes: 16
        push %eax
        movl (arena_pointer), %eax
        add $16, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_memo1_asm_6, 4(%ebx)
        movl $1, 8(%ebx)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _memo1_asm_4, .-_memo1_asm_4
_memo1_asm_2:
        push %eax
        movl $_memo1_asm_3, %eax
        # initialize global variable with value
        movl %eax, (_memo1_asm_1)
        pop %eax
        .section .data
_memo0_asm_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _memo0_asm_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_memo0_asm_3:
        .long 0xca11ab1e
        .long _memo0_asm_4
        .long 0
        .text
        .type _memo0_asm_4, @function
_memo0_asm_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # move arg from stack to heap: proc
        push %eax
        movl 0(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # jump past the body of the lambda
        jmp _memo0_asm_5
        .text
        .type _memo0_asm_6, @function
_memo0_asm_6:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $0, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 proc
        push 12(%eax)
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl $2 + 258<<2, %eax
        push %eax
        movl $2 + 258<<2, %eax
        # get procedure
        # jump past the body of the lambda
        jmp _memo0_asm_7
        .text
        .type _memo0_asm_8, @function
_memo0_asm_8:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $2, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 proc
        push 12(%eax)
        # discarding useless value in %eax
        pop %eax
        # move arg from stack to heap: output
        push %eax
        movl 0(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # move arg from stack to heap: result
        push %eax
        movl 4(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # %ifeq
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _memo0_asm_9
        # get procedure
        push %eax
        movl (_push_assembly_diversion_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        pop %eax
        # get procedure
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        # get procedure
        # jump past the body of the lambda
        jmp _memo0_asm_11
        .text
        .type _memo0_asm_12, @function
_memo0_asm_12:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 output
        push 12(%eax)
        # fetch artifact from closure: 1 result
        push 16(%eax)
        # discarding useless value in %eax
        pop %eax
        # get procedure
        push %eax
        movl (_pop_diverted_assembly_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl (%esp), %ebx
        movl %ebx, 4(%eax)
        pop %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        movl (%esp), %ebx
        movl %ebx, 4(%eax)
        pop %eax
        pop %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_asm_display_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _memo0_asm_12, .-_memo0_asm_12
_memo0_asm_11:
        # allocate bytes: 20
        push %eax
        movl (arena_pointer), %eax
        add $20, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_memo0_asm_12, 4(%ebx)
        movl $2, 8(%ebx)
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # fetching heap var pointer 2
        push %eax
        movl -24(%ebp), %eax
        movl %eax, 16(%ebx)
        pop %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        jmp _memo0_asm_10
_memo0_asm_9:
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_asm_display_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        # fetching heap var pointer 2
        push %eax
        movl -24(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
_memo0_asm_10:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _memo0_asm_8, .-_memo0_asm_8
_memo0_asm_7:
        # allocate bytes: 16
        push %eax
        movl (arena_pointer), %eax
        add $16, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_memo0_asm_8, 4(%ebx)
        movl $1, 8(%ebx)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _memo0_asm_6, .-_memo0_asm_6
_memo0_asm_5:
        # allocate bytes: 16
        push %eax
        movl (arena_pointer), %eax
        add $16, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_memo0_asm_6, 4(%ebx)
        movl $1, 8(%ebx)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _memo0_asm_4, .-_memo0_asm_4
_memo0_asm_2:
        push %eax
        movl $_memo0_asm_3, %eax
        # initialize global variable with value
        movl %eax, (_memo0_asm_1)
        pop %eax
        .section .data
_insn_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _insn_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_insn_3:
        .long 0xca11ab1e
        .long _insn_4
        .long 0
        .text
        .type _insn_4, @function
_insn_4:
        # make space for variadic argument list
        pop %ebx
        push %ebx
        push %ebx
        # push desired %esp on return
        lea 8(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        call package_up_variadic_args
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_insn_5:
        .long 0xbabb1e
        .long 8
        .ascii "        "
        .text
        push %eax
        movl $_insn_5, %eax
        # get procedure
        push %eax
        movl (_cons_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_emit_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _insn_4, .-_insn_4
_insn_2:
        push %eax
        movl $_insn_3, %eax
        # initialize global variable with value
        movl %eax, (_insn_1)
        pop %eax
        .section .data
_comment_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _comment_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_comment_3:
        .long 0xca11ab1e
        .long _comment_4
        .long 0
        .text
        .type _comment_4, @function
_comment_4:
        # make space for variadic argument list
        pop %ebx
        push %ebx
        push %ebx
        # push desired %esp on return
        lea 8(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        call package_up_variadic_args
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_comment_5:
        .long 0xbabb1e
        .long 2
        .ascii "# "
        .text
        push %eax
        movl $_comment_5, %eax
        # get procedure
        push %eax
        movl (_insn_1), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _comment_4, .-_comment_4
_comment_2:
        push %eax
        movl $_comment_3, %eax
        # initialize global variable with value
        movl %eax, (_comment_1)
        pop %eax
        .section .data
_twoarg_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _twoarg_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_twoarg_3:
        .long 0xca11ab1e
        .long _twoarg_4
        .long 0
        .text
        .type _twoarg_4, @function
_twoarg_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # move arg from stack to heap: mnemonic
        push %eax
        movl 0(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # jump past the body of the lambda
        jmp _twoarg_5
        .text
        .type _twoarg_6, @function
_twoarg_6:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $2, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 mnemonic
        push 12(%eax)
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 4(%ebp), %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_twoarg_7:
        .long 0xbabb1e
        .long 2
        .ascii ", "
        .text
        push %eax
        movl $_twoarg_7, %eax
        push %eax
        movl 0(%ebp), %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_twoarg_8:
        .long 0xbabb1e
        .long 1
        .ascii " "
        .text
        push %eax
        movl $_twoarg_8, %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_insn_1), %eax
        # apply procedure
        # Tail call; nargs = 5
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 16(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push -8(%ebx)
        push -12(%ebx)
        push -16(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $5, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _twoarg_6, .-_twoarg_6
_twoarg_5:
        # allocate bytes: 16
        push %eax
        movl (arena_pointer), %eax
        add $16, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_twoarg_6, 4(%ebx)
        movl $1, 8(%ebx)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _twoarg_4, .-_twoarg_4
_twoarg_2:
        push %eax
        movl $_twoarg_3, %eax
        # initialize global variable with value
        movl %eax, (_twoarg_1)
        pop %eax
        .section .data
_mov_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_mov_2:
        .long 0xbabb1e
        .long 4
        .ascii "movl"
        .text
        push %eax
        movl $_mov_2, %eax
        # get procedure
        push %eax
        movl (_twoarg_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # initialize global variable with value
        movl %eax, (_mov_1)
        pop %eax
        .section .data
_movb_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_movb_2:
        .long 0xbabb1e
        .long 4
        .ascii "movb"
        .text
        push %eax
        movl $_movb_2, %eax
        # get procedure
        push %eax
        movl (_twoarg_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # initialize global variable with value
        movl %eax, (_movb_1)
        pop %eax
        .section .data
_movzbl_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_movzbl_2:
        .long 0xbabb1e
        .long 6
        .ascii "movzbl"
        .text
        push %eax
        movl $_movzbl_2, %eax
        # get procedure
        push %eax
        movl (_twoarg_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # initialize global variable with value
        movl %eax, (_movzbl_1)
        pop %eax
        .section .data
_test_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_test_2:
        .long 0xbabb1e
        .long 4
        .ascii "test"
        .text
        push %eax
        movl $_test_2, %eax
        # get procedure
        push %eax
        movl (_twoarg_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # initialize global variable with value
        movl %eax, (_test_1)
        pop %eax
        .section .data
_cmp_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_cmp_2:
        .long 0xbabb1e
        .long 4
        .ascii "cmpl"
        .text
        push %eax
        movl $_cmp_2, %eax
        # get procedure
        push %eax
        movl (_twoarg_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # initialize global variable with value
        movl %eax, (_cmp_1)
        pop %eax
        .section .data
_lea_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_lea_2:
        .long 0xbabb1e
        .long 3
        .ascii "lea"
        .text
        push %eax
        movl $_lea_2, %eax
        # get procedure
        push %eax
        movl (_twoarg_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # initialize global variable with value
        movl %eax, (_lea_1)
        pop %eax
        .section .data
_add_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_add_2:
        .long 0xbabb1e
        .long 3
        .ascii "add"
        .text
        push %eax
        movl $_add_2, %eax
        # get procedure
        push %eax
        movl (_twoarg_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # initialize global variable with value
        movl %eax, (_add_1)
        pop %eax
        .section .data
_sub_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sub_2:
        .long 0xbabb1e
        .long 3
        .ascii "sub"
        .text
        push %eax
        movl $_sub_2, %eax
        # get procedure
        push %eax
        movl (_twoarg_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # initialize global variable with value
        movl %eax, (_sub_1)
        pop %eax
        .section .data
_xchg_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_xchg_2:
        .long 0xbabb1e
        .long 4
        .ascii "xchg"
        .text
        push %eax
        movl $_xchg_2, %eax
        # get procedure
        push %eax
        movl (_twoarg_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # initialize global variable with value
        movl %eax, (_xchg_1)
        pop %eax
        .section .data
_asm_and_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_asm_and_2:
        .long 0xbabb1e
        .long 3
        .ascii "and"
        .text
        push %eax
        movl $_asm_and_2, %eax
        # get procedure
        push %eax
        movl (_twoarg_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # initialize global variable with value
        movl %eax, (_asm_and_1)
        pop %eax
        .section .data
_onearg_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _onearg_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_onearg_3:
        .long 0xca11ab1e
        .long _onearg_4
        .long 0
        .text
        .type _onearg_4, @function
_onearg_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # move arg from stack to heap: mnemonic
        push %eax
        movl 0(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # jump past the body of the lambda
        jmp _onearg_5
        .text
        .type _onearg_6, @function
_onearg_6:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 mnemonic
        push 12(%eax)
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_onearg_7:
        .long 0xbabb1e
        .long 1
        .ascii " "
        .text
        push %eax
        movl $_onearg_7, %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_insn_1), %eax
        # apply procedure
        # Tail call; nargs = 3
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 8(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push -8(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _onearg_6, .-_onearg_6
_onearg_5:
        # allocate bytes: 16
        push %eax
        movl (arena_pointer), %eax
        add $16, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_onearg_6, 4(%ebx)
        movl $1, 8(%ebx)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _onearg_4, .-_onearg_4
_onearg_2:
        push %eax
        movl $_onearg_3, %eax
        # initialize global variable with value
        movl %eax, (_onearg_1)
        pop %eax
        .section .data
_asm_push_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_asm_push_2:
        .long 0xbabb1e
        .long 4
        .ascii "push"
        .text
        push %eax
        movl $_asm_push_2, %eax
        # get procedure
        push %eax
        movl (_onearg_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # initialize global variable with value
        movl %eax, (_asm_push_1)
        pop %eax
        .section .data
_asm_pop_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_asm_pop_2:
        .long 0xbabb1e
        .long 3
        .ascii "pop"
        .text
        push %eax
        movl $_asm_pop_2, %eax
        # get procedure
        push %eax
        movl (_onearg_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # initialize global variable with value
        movl %eax, (_asm_pop_1)
        pop %eax
        .section .data
_jmp_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_jmp_2:
        .long 0xbabb1e
        .long 3
        .ascii "jmp"
        .text
        push %eax
        movl $_jmp_2, %eax
        # get procedure
        push %eax
        movl (_onearg_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # initialize global variable with value
        movl %eax, (_jmp_1)
        pop %eax
        .section .data
_jnz_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_jnz_2:
        .long 0xbabb1e
        .long 3
        .ascii "jnz"
        .text
        push %eax
        movl $_jnz_2, %eax
        # get procedure
        push %eax
        movl (_onearg_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # initialize global variable with value
        movl %eax, (_jnz_1)
        pop %eax
        .section .data
_je_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_je_2:
        .long 0xbabb1e
        .long 2
        .ascii "je"
        .text
        push %eax
        movl $_je_2, %eax
        # get procedure
        push %eax
        movl (_onearg_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # initialize global variable with value
        movl %eax, (_je_1)
        pop %eax
        .section .data
_jz_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        push %eax
        movl (_je_1), %eax
        # initialize global variable with value
        movl %eax, (_jz_1)
        pop %eax
        .section .data
_jnb_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_jnb_2:
        .long 0xbabb1e
        .long 3
        .ascii "jnb"
        .text
        push %eax
        movl $_jnb_2, %eax
        # get procedure
        push %eax
        movl (_onearg_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # initialize global variable with value
        movl %eax, (_jnb_1)
        pop %eax
        .section .data
_jl_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_jl_2:
        .long 0xbabb1e
        .long 2
        .ascii "jl"
        .text
        push %eax
        movl $_jl_2, %eax
        # get procedure
        push %eax
        movl (_onearg_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # initialize global variable with value
        movl %eax, (_jl_1)
        pop %eax
        .section .data
_js_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_js_2:
        .long 0xbabb1e
        .long 2
        .ascii "js"
        .text
        push %eax
        movl $_js_2, %eax
        # get procedure
        push %eax
        movl (_onearg_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # initialize global variable with value
        movl %eax, (_js_1)
        pop %eax
        .section .data
_ja_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_ja_2:
        .long 0xbabb1e
        .long 2
        .ascii "ja"
        .text
        push %eax
        movl $_ja_2, %eax
        # get procedure
        push %eax
        movl (_onearg_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # initialize global variable with value
        movl %eax, (_ja_1)
        pop %eax
        .section .data
_call_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_call_2:
        .long 0xbabb1e
        .long 4
        .ascii "call"
        .text
        push %eax
        movl $_call_2, %eax
        # get procedure
        push %eax
        movl (_onearg_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # initialize global variable with value
        movl %eax, (_call_1)
        pop %eax
        .section .data
_int_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_int_2:
        .long 0xbabb1e
        .long 3
        .ascii "int"
        .text
        push %eax
        movl $_int_2, %eax
        # get procedure
        push %eax
        movl (_onearg_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # initialize global variable with value
        movl %eax, (_int_1)
        pop %eax
        .section .data
_inc_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_inc_2:
        .long 0xbabb1e
        .long 3
        .ascii "inc"
        .text
        push %eax
        movl $_inc_2, %eax
        # get procedure
        push %eax
        movl (_onearg_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # initialize global variable with value
        movl %eax, (_inc_1)
        pop %eax
        .section .data
_dec_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_dec_2:
        .long 0xbabb1e
        .long 3
        .ascii "dec"
        .text
        push %eax
        movl $_dec_2, %eax
        # get procedure
        push %eax
        movl (_onearg_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # initialize global variable with value
        movl %eax, (_dec_1)
        pop %eax
        .section .data
_idiv_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_idiv_2:
        .long 0xbabb1e
        .long 4
        .ascii "idiv"
        .text
        push %eax
        movl $_idiv_2, %eax
        # get procedure
        push %eax
        movl (_onearg_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # initialize global variable with value
        movl %eax, (_idiv_1)
        pop %eax
        .section .data
_sal_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sal_2:
        .long 0xbabb1e
        .long 3
        .ascii "sal"
        .text
        push %eax
        movl $_sal_2, %eax
        # get procedure
        push %eax
        movl (_onearg_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # initialize global variable with value
        movl %eax, (_sal_1)
        pop %eax
        .section .data
_sar_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sar_2:
        .long 0xbabb1e
        .long 3
        .ascii "sar"
        .text
        push %eax
        movl $_sar_2, %eax
        # get procedure
        push %eax
        movl (_onearg_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # initialize global variable with value
        movl %eax, (_sar_1)
        pop %eax
        .section .data
_ret_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _ret_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_ret_3:
        .long 0xca11ab1e
        .long _ret_4
        .long 0
        .text
        .type _ret_4, @function
_ret_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $0, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_ret_5:
        .long 0xbabb1e
        .long 3
        .ascii "ret"
        .text
        push %eax
        movl $_ret_5, %eax
        # get procedure
        push %eax
        movl (_insn_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _ret_4, .-_ret_4
_ret_2:
        push %eax
        movl $_ret_3, %eax
        # initialize global variable with value
        movl %eax, (_ret_1)
        pop %eax
        .section .data
_rep_stosb_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _rep_stosb_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_rep_stosb_3:
        .long 0xca11ab1e
        .long _rep_stosb_4
        .long 0
        .text
        .type _rep_stosb_4, @function
_rep_stosb_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $0, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_rep_stosb_5:
        .long 0xbabb1e
        .long 9
        .ascii "rep stosb"
        .text
        push %eax
        movl $_rep_stosb_5, %eax
        # get procedure
        push %eax
        movl (_insn_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _rep_stosb_4, .-_rep_stosb_4
_rep_stosb_2:
        push %eax
        movl $_rep_stosb_3, %eax
        # initialize global variable with value
        movl %eax, (_rep_stosb_1)
        pop %eax
        .section .data
_repe_cmpsb_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _repe_cmpsb_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_repe_cmpsb_3:
        .long 0xca11ab1e
        .long _repe_cmpsb_4
        .long 0
        .text
        .type _repe_cmpsb_4, @function
_repe_cmpsb_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $0, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_repe_cmpsb_5:
        .long 0xbabb1e
        .long 10
        .ascii "repe cmpsb"
        .text
        push %eax
        movl $_repe_cmpsb_5, %eax
        # get procedure
        push %eax
        movl (_insn_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _repe_cmpsb_4, .-_repe_cmpsb_4
_repe_cmpsb_2:
        push %eax
        movl $_repe_cmpsb_3, %eax
        # initialize global variable with value
        movl %eax, (_repe_cmpsb_1)
        pop %eax
        .section .data
_eax_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_eax_2:
        .long 0xbabb1e
        .long 4
        .ascii "%eax"
        .text
        push %eax
        movl $_eax_2, %eax
        # initialize global variable with value
        movl %eax, (_eax_1)
        pop %eax
        .section .data
_ebx_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_ebx_2:
        .long 0xbabb1e
        .long 4
        .ascii "%ebx"
        .text
        push %eax
        movl $_ebx_2, %eax
        # initialize global variable with value
        movl %eax, (_ebx_1)
        pop %eax
        .section .data
_ecx_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_ecx_2:
        .long 0xbabb1e
        .long 4
        .ascii "%ecx"
        .text
        push %eax
        movl $_ecx_2, %eax
        # initialize global variable with value
        movl %eax, (_ecx_1)
        pop %eax
        .section .data
_edx_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_edx_2:
        .long 0xbabb1e
        .long 4
        .ascii "%edx"
        .text
        push %eax
        movl $_edx_2, %eax
        # initialize global variable with value
        movl %eax, (_edx_1)
        pop %eax
        .section .data
_ebp_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_ebp_2:
        .long 0xbabb1e
        .long 4
        .ascii "%ebp"
        .text
        push %eax
        movl $_ebp_2, %eax
        # initialize global variable with value
        movl %eax, (_ebp_1)
        pop %eax
        .section .data
_esp_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_esp_2:
        .long 0xbabb1e
        .long 4
        .ascii "%esp"
        .text
        push %eax
        movl $_esp_2, %eax
        # initialize global variable with value
        movl %eax, (_esp_1)
        pop %eax
        .section .data
_esi_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_esi_2:
        .long 0xbabb1e
        .long 4
        .ascii "%esi"
        .text
        push %eax
        movl $_esi_2, %eax
        # initialize global variable with value
        movl %eax, (_esi_1)
        pop %eax
        .section .data
_edi_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_edi_2:
        .long 0xbabb1e
        .long 4
        .ascii "%edi"
        .text
        push %eax
        movl $_edi_2, %eax
        # initialize global variable with value
        movl %eax, (_edi_1)
        pop %eax
        .section .data
_al_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_al_2:
        .long 0xbabb1e
        .long 3
        .ascii "%al"
        .text
        push %eax
        movl $_al_2, %eax
        # initialize global variable with value
        movl %eax, (_al_1)
        pop %eax
        .section .data
_const_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _const_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_const_3:
        .long 0xca11ab1e
        .long _const_4
        .long 0
        .text
        .type _const_4, @function
_const_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_const_5:
        .long 0xbabb1e
        .long 1
        .ascii "$"
        .text
        push %eax
        movl $_const_5, %eax
        # get procedure
        push %eax
        movl (_list_1), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _const_4, .-_const_4
_const_2:
        push %eax
        movl $_const_3, %eax
        # initialize global variable with value
        movl %eax, (_const_1)
        pop %eax
        .section .data
_indirect_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _indirect_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_indirect_3:
        .long 0xca11ab1e
        .long _indirect_4
        .long 0
        .text
        .type _indirect_4, @function
_indirect_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_indirect_5:
        .long 0xbabb1e
        .long 1
        .ascii ")"
        .text
        push %eax
        movl $_indirect_5, %eax
        push %eax
        movl 0(%ebp), %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_indirect_6:
        .long 0xbabb1e
        .long 1
        .ascii "("
        .text
        push %eax
        movl $_indirect_6, %eax
        # get procedure
        push %eax
        movl (_list_1), %eax
        # apply procedure
        # Tail call; nargs = 3
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 8(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push -8(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _indirect_4, .-_indirect_4
_indirect_2:
        push %eax
        movl $_indirect_3, %eax
        # initialize global variable with value
        movl %eax, (_indirect_1)
        pop %eax
        .section .data
_offset_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _offset_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_offset_3:
        .long 0xca11ab1e
        .long _offset_4
        .long 0
        .text
        .type _offset_4, @function
_offset_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $2, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_indirect_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl 4(%ebp), %eax
        # get procedure
        push %eax
        movl (_number_Gtstring_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_list_1), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _offset_4, .-_offset_4
_offset_2:
        push %eax
        movl $_offset_3, %eax
        # initialize global variable with value
        movl %eax, (_offset_1)
        pop %eax
        .section .data
_absolute_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _absolute_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_absolute_3:
        .long 0xca11ab1e
        .long _absolute_4
        .long 0
        .text
        .type _absolute_4, @function
_absolute_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_absolute_5:
        .long 0xbabb1e
        .long 1
        .ascii "*"
        .text
        push %eax
        movl $_absolute_5, %eax
        # get procedure
        push %eax
        movl (_list_1), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _absolute_4, .-_absolute_4
_absolute_2:
        push %eax
        movl $_absolute_3, %eax
        # initialize global variable with value
        movl %eax, (_absolute_1)
        pop %eax
        .section .data
_index_register_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _index_register_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_index_register_3:
        .long 0xca11ab1e
        .long _index_register_4
        .long 0
        .text
        .type _index_register_4, @function
_index_register_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $3, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 8(%ebp), %eax
        # get procedure
        push %eax
        movl (_number_Gtstring_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_index_register_5:
        .long 0xbabb1e
        .long 1
        .ascii ","
        .text
        push %eax
        movl $_index_register_5, %eax
        push %eax
        movl 4(%ebp), %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_index_register_6:
        .long 0xbabb1e
        .long 1
        .ascii ","
        .text
        push %eax
        movl $_index_register_6, %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_list_1), %eax
        # apply procedure
        # Tail call; nargs = 5
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 16(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push -8(%ebx)
        push -12(%ebx)
        push -16(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $5, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _index_register_4, .-_index_register_4
_index_register_2:
        push %eax
        movl $_index_register_3, %eax
        # initialize global variable with value
        movl %eax, (_index_register_1)
        pop %eax
        .section .data
_syscall_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _syscall_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_syscall_3:
        .long 0xca11ab1e
        .long _syscall_4
        .long 0
        .text
        .type _syscall_4, @function
_syscall_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $0, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_syscall_5:
        .long 0xbabb1e
        .long 4
        .ascii "0x80"
        .text
        push %eax
        movl $_syscall_5, %eax
        # get procedure
        push %eax
        movl (_const_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_int_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _syscall_4, .-_syscall_4
_syscall_2:
        push %eax
        movl $_syscall_3, %eax
        # initialize global variable with value
        movl %eax, (_syscall_1)
        pop %eax
        .section .data
_section_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _section_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_section_3:
        .long 0xca11ab1e
        .long _section_4
        .long 0
        .text
        .type _section_4, @function
_section_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_section_5:
        .long 0xbabb1e
        .long 9
        .ascii ".section "
        .text
        push %eax
        movl $_section_5, %eax
        # get procedure
        push %eax
        movl (_insn_1), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _section_4, .-_section_4
_section_2:
        push %eax
        movl $_section_3, %eax
        # initialize global variable with value
        movl %eax, (_section_1)
        pop %eax
        .section .data
_rodata_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _rodata_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_rodata_3:
        .long 0xca11ab1e
        .long _rodata_4
        .long 0
        .text
        .type _rodata_4, @function
_rodata_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $0, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_rodata_5:
        .long 0xbabb1e
        .long 7
        .ascii ".rodata"
        .text
        push %eax
        movl $_rodata_5, %eax
        # get procedure
        push %eax
        movl (_section_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _rodata_4, .-_rodata_4
_rodata_2:
        push %eax
        movl $_rodata_3, %eax
        # initialize global variable with value
        movl %eax, (_rodata_1)
        pop %eax
        .section .data
_text_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _text_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_text_3:
        .long 0xca11ab1e
        .long _text_4
        .long 0
        .text
        .type _text_4, @function
_text_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $0, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_text_5:
        .long 0xbabb1e
        .long 5
        .ascii ".text"
        .text
        push %eax
        movl $_text_5, %eax
        # get procedure
        push %eax
        movl (_insn_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _text_4, .-_text_4
_text_2:
        push %eax
        movl $_text_3, %eax
        # initialize global variable with value
        movl %eax, (_text_1)
        pop %eax
        .section .data
_label_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _label_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_label_3:
        .long 0xca11ab1e
        .long _label_4
        .long 0
        .text
        .type _label_4, @function
_label_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_label_5:
        .long 0xbabb1e
        .long 1
        .ascii ":"
        .text
        push %eax
        movl $_label_5, %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_emit_1), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _label_4, .-_label_4
_label_2:
        push %eax
        movl $_label_3, %eax
        # initialize global variable with value
        movl %eax, (_label_1)
        pop %eax
        .section .data
_global_label_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _global_label_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_global_label_3:
        .long 0xca11ab1e
        .long _global_label_4
        .long 0
        .text
        .type _global_label_4, @function
_global_label_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_global_label_5:
        .long 0xbabb1e
        .long 7
        .ascii ".globl "
        .text
        push %eax
        movl $_global_label_5, %eax
        # get procedure
        push %eax
        movl (_insn_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_label_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _global_label_4, .-_global_label_4
_global_label_2:
        push %eax
        movl $_global_label_3, %eax
        # initialize global variable with value
        movl %eax, (_global_label_1)
        pop %eax
        .section .data
_old_label_prefixes_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        push %eax
        movl $2 + 256<<2, %eax
        # initialize global variable with value
        movl %eax, (_old_label_prefixes_1)
        pop %eax
        .section .data
_constcounter_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        push %eax
        movl $1 + 0<<2, %eax
        # initialize global variable with value
        movl %eax, (_constcounter_1)
        pop %eax
        .section .data
_label_prefix_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_label_prefix_2:
        .long 0xbabb1e
        .long 1
        .ascii "k"
        .text
        push %eax
        movl $_label_prefix_2, %eax
        # initialize global variable with value
        movl %eax, (_label_prefix_1)
        pop %eax
        .section .data
_set_label_prefix_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _set_label_prefix_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_label_prefix_3:
        .long 0xca11ab1e
        .long _set_label_prefix_4
        .long 0
        .text
        .type _set_label_prefix_4, @function
_set_label_prefix_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_label_prefix_6:
        .long 0xbabb1e
        .long 4
        .ascii "Plus"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_label_prefix_8:
        .long 0xbabb1e
        .long 1
        .ascii "_"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_label_prefix_10:
        .long 0xbabb1e
        .long 2
        .ascii "Eq"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_label_prefix_12:
        .long 0xbabb1e
        .long 1
        .ascii "P"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_label_prefix_14:
        .long 0xbabb1e
        .long 2
        .ascii "Gt"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_label_prefix_16:
        .long 0xbabb1e
        .long 2
        .ascii "Lt"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_label_prefix_18:
        .long 0xbabb1e
        .long 4
        .ascii "Bang"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_label_prefix_20:
        .long 0xbabb1e
        .long 4
        .ascii "Star"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_label_prefix_22:
        .long 0xbabb1e
        .long 5
        .ascii "Slash"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_label_prefix_24:
        .long 0xbabb1e
        .long 2
        .ascii "Co"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_label_prefix_26:
        .long 0xbabb1e
        .long 2
        .ascii "At"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_label_prefix_28:
        .long 0xbabb1e
        .long 5
        .ascii "Caret"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_label_prefix_30:
        .long 0xbabb1e
        .long 5
        .ascii "Tilde"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_label_prefix_32:
        .long 0xbabb1e
        .long 6
        .ascii "Dollar"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_label_prefix_34:
        .long 0xbabb1e
        .long 3
        .ascii "Pct"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_label_prefix_36:
        .long 0xbabb1e
        .long 3
        .ascii "And"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_label_prefix_35:
        .long 0x2ce11ed
        .long _set_label_prefix_36
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_label_prefix_33:
        .long 0x2ce11ed
        .long _set_label_prefix_34
        .long _set_label_prefix_35
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_label_prefix_31:
        .long 0x2ce11ed
        .long _set_label_prefix_32
        .long _set_label_prefix_33
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_label_prefix_29:
        .long 0x2ce11ed
        .long _set_label_prefix_30
        .long _set_label_prefix_31
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_label_prefix_27:
        .long 0x2ce11ed
        .long _set_label_prefix_28
        .long _set_label_prefix_29
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_label_prefix_25:
        .long 0x2ce11ed
        .long _set_label_prefix_26
        .long _set_label_prefix_27
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_label_prefix_23:
        .long 0x2ce11ed
        .long _set_label_prefix_24
        .long _set_label_prefix_25
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_label_prefix_21:
        .long 0x2ce11ed
        .long _set_label_prefix_22
        .long _set_label_prefix_23
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_label_prefix_19:
        .long 0x2ce11ed
        .long _set_label_prefix_20
        .long _set_label_prefix_21
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_label_prefix_17:
        .long 0x2ce11ed
        .long _set_label_prefix_18
        .long _set_label_prefix_19
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_label_prefix_15:
        .long 0x2ce11ed
        .long _set_label_prefix_16
        .long _set_label_prefix_17
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_label_prefix_13:
        .long 0x2ce11ed
        .long _set_label_prefix_14
        .long _set_label_prefix_15
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_label_prefix_11:
        .long 0x2ce11ed
        .long _set_label_prefix_12
        .long _set_label_prefix_13
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_label_prefix_9:
        .long 0x2ce11ed
        .long _set_label_prefix_10
        .long _set_label_prefix_11
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_label_prefix_7:
        .long 0x2ce11ed
        .long _set_label_prefix_8
        .long _set_label_prefix_9
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_label_prefix_5:
        .long 0x2ce11ed
        .long _set_label_prefix_6
        .long _set_label_prefix_7
        .text
        push %eax
        movl $_set_label_prefix_5, %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_label_prefix_38:
        .long 0xbabb1e
        .long 1
        .ascii "+"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_label_prefix_40:
        .long 0xbabb1e
        .long 1
        .ascii "-"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_label_prefix_42:
        .long 0xbabb1e
        .long 1
        .ascii "="
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_label_prefix_44:
        .long 0xbabb1e
        .long 1
        .ascii "?"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_label_prefix_46:
        .long 0xbabb1e
        .long 1
        .ascii ">"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_label_prefix_48:
        .long 0xbabb1e
        .long 1
        .ascii "<"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_label_prefix_50:
        .long 0xbabb1e
        .long 1
        .ascii "!"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_label_prefix_52:
        .long 0xbabb1e
        .long 1
        .ascii "*"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_label_prefix_54:
        .long 0xbabb1e
        .long 1
        .ascii "/"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_label_prefix_56:
        .long 0xbabb1e
        .long 1
        .ascii ":"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_label_prefix_58:
        .long 0xbabb1e
        .long 1
        .ascii "@"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_label_prefix_60:
        .long 0xbabb1e
        .long 1
        .ascii "^"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_label_prefix_62:
        .long 0xbabb1e
        .long 1
        .ascii "~"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_label_prefix_64:
        .long 0xbabb1e
        .long 1
        .ascii "$"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_label_prefix_66:
        .long 0xbabb1e
        .long 1
        .ascii "%"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_label_prefix_68:
        .long 0xbabb1e
        .long 1
        .ascii "&"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_label_prefix_67:
        .long 0x2ce11ed
        .long _set_label_prefix_68
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_label_prefix_65:
        .long 0x2ce11ed
        .long _set_label_prefix_66
        .long _set_label_prefix_67
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_label_prefix_63:
        .long 0x2ce11ed
        .long _set_label_prefix_64
        .long _set_label_prefix_65
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_label_prefix_61:
        .long 0x2ce11ed
        .long _set_label_prefix_62
        .long _set_label_prefix_63
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_label_prefix_59:
        .long 0x2ce11ed
        .long _set_label_prefix_60
        .long _set_label_prefix_61
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_label_prefix_57:
        .long 0x2ce11ed
        .long _set_label_prefix_58
        .long _set_label_prefix_59
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_label_prefix_55:
        .long 0x2ce11ed
        .long _set_label_prefix_56
        .long _set_label_prefix_57
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_label_prefix_53:
        .long 0x2ce11ed
        .long _set_label_prefix_54
        .long _set_label_prefix_55
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_label_prefix_51:
        .long 0x2ce11ed
        .long _set_label_prefix_52
        .long _set_label_prefix_53
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_label_prefix_49:
        .long 0x2ce11ed
        .long _set_label_prefix_50
        .long _set_label_prefix_51
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_label_prefix_47:
        .long 0x2ce11ed
        .long _set_label_prefix_48
        .long _set_label_prefix_49
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_label_prefix_45:
        .long 0x2ce11ed
        .long _set_label_prefix_46
        .long _set_label_prefix_47
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_label_prefix_43:
        .long 0x2ce11ed
        .long _set_label_prefix_44
        .long _set_label_prefix_45
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_label_prefix_41:
        .long 0x2ce11ed
        .long _set_label_prefix_42
        .long _set_label_prefix_43
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_label_prefix_39:
        .long 0x2ce11ed
        .long _set_label_prefix_40
        .long _set_label_prefix_41
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_label_prefix_37:
        .long 0x2ce11ed
        .long _set_label_prefix_38
        .long _set_label_prefix_39
        .text
        push %eax
        movl $_set_label_prefix_37, %eax
        push %eax
        movl $1 + 0<<2, %eax
        push %eax
        movl 0(%ebp), %eax
        call ensure_symbol
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_escape_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $4, %edx
        call *%ebx
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_label_prefix_69:
        .long 0xbabb1e
        .long 1
        .ascii "_"
        .text
        push %eax
        movl $_set_label_prefix_69, %eax
        # get procedure
        push %eax
        movl (_cons_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_pop_diverted_assembly_5), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        # jump past the body of the lambda
        jmp _set_label_prefix_70
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_label_prefix_71:
        .long 0xca11ab1e
        .long _set_label_prefix_72
        .long 0
        .text
        .type _set_label_prefix_72, @function
_set_label_prefix_72:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # move arg from stack to heap: new-label-prefix
        push %eax
        movl 0(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_string_Gtsymbol_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        # jump past the body of the lambda
        jmp _set_label_prefix_73
        .text
        .type _set_label_prefix_74, @function
_set_label_prefix_74:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 new-label-prefix
        push 12(%eax)
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl (_old_label_prefixes_1), %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_memq_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _set_label_prefix_75
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        movl %eax, (_label_prefix_1)
        pop %eax
        push %eax
        movl (_old_label_prefixes_1), %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_cons_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        movl %eax, (_old_label_prefixes_1)
        pop %eax
        push %eax
        movl $1 + 0<<2, %eax
        movl %eax, (_constcounter_1)
        jmp _set_label_prefix_76
_set_label_prefix_75:
        push %eax
        movl $2 + 258<<2, %eax
_set_label_prefix_76:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _set_label_prefix_74, .-_set_label_prefix_74
_set_label_prefix_73:
        # allocate bytes: 16
        push %eax
        movl (arena_pointer), %eax
        add $16, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_set_label_prefix_74, 4(%ebx)
        movl $1, 8(%ebx)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _set_label_prefix_72, .-_set_label_prefix_72
_set_label_prefix_70:
        push %eax
        movl $_set_label_prefix_71, %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _set_label_prefix_4, .-_set_label_prefix_4
_set_label_prefix_2:
        push %eax
        movl $_set_label_prefix_3, %eax
        # initialize global variable with value
        movl %eax, (_set_label_prefix_1)
        pop %eax
        .section .data
_new_label_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _new_label_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_new_label_3:
        .long 0xca11ab1e
        .long _new_label_4
        .long 0
        .text
        .type _new_label_4, @function
_new_label_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $0, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl (_constcounter_1), %eax
        # 1+
        call ensure_integer
        add $1<<2, %eax
        movl %eax, (_constcounter_1)
        pop %eax
        push %eax
        movl (_constcounter_1), %eax
        # get procedure
        push %eax
        movl (_number_Gtstring_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_new_label_5:
        .long 0xbabb1e
        .long 1
        .ascii "_"
        .text
        push %eax
        movl $_new_label_5, %eax
        push %eax
        movl (_label_prefix_1), %eax
        # get procedure
        push %eax
        movl (_list_1), %eax
        # apply procedure
        # Tail call; nargs = 3
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 8(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push -8(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _new_label_4, .-_new_label_4
_new_label_2:
        push %eax
        movl $_new_label_3, %eax
        # initialize global variable with value
        movl %eax, (_new_label_1)
        pop %eax
        push %eax
        movl $2 + 256<<2, %eax
        movl %eax, (_escape_char_1)
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _new_label_6
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_new_label_7:
        .long 0xca11ab1e
        .long _new_label_8
        .long 0
        .text
        .type _new_label_8, @function
_new_label_8:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $3, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 4(%ebp), %eax
        push %eax
        movl $2 + 256<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _new_label_9
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_char_Gtstring_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        jmp _new_label_10
_new_label_9:
        # %ifeq
        push %eax
        movl $1 + 0<<2, %eax
        push %eax
        movl 4(%ebp), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_string_ref_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_charEqP_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _new_label_11
        push %eax
        movl 8(%ebp), %eax
        # inlined cdr
        call ensure_cons
        movl 8(%eax), %eax
        push %eax
        movl 4(%ebp), %eax
        # inlined cdr
        call ensure_cons
        movl 8(%eax), %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_escape_char_1), %eax
        # apply procedure
        # Tail call; nargs = 3
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 8(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push -8(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        jmp *%ebx
        jmp _new_label_12
_new_label_11:
        push %eax
        movl 8(%ebp), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
_new_label_12:
_new_label_10:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _new_label_8, .-_new_label_8
_new_label_6:
        push %eax
        movl $_new_label_7, %eax
        # initialize global variable with value
        movl %eax, (_escape_char_1)
        pop %eax
        push %eax
        movl $2 + 256<<2, %eax
        movl %eax, (_escape_1)
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _new_label_13
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_new_label_14:
        .long 0xca11ab1e
        .long _new_label_15
        .long 0
        .text
        .type _new_label_15, @function
_new_label_15:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $4, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 4(%ebp), %eax
        push %eax
        movl 0(%ebp), %eax
        # string-length inlined primitive
        call ensure_string
        lea 8(%eax), %ebx
        push %ebx
        movl 4(%eax), %eax
        pop %ebx
        sal %eax
        sal %eax
        inc %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _new_label_16
        push %eax
        movl $2 + 256<<2, %eax
        jmp _new_label_17
_new_label_16:
        push %eax
        movl 12(%ebp), %eax
        push %eax
        movl 8(%ebp), %eax
        push %eax
        movl 4(%ebp), %eax
        # 1+
        call ensure_integer
        add $1<<2, %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_escape_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $4, %edx
        call *%ebx
        push %eax
        movl 12(%ebp), %eax
        push %eax
        movl 8(%ebp), %eax
        push %eax
        movl 4(%ebp), %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_string_ref_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_escape_char_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_cons_2), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
_new_label_17:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _new_label_15, .-_new_label_15
_new_label_13:
        push %eax
        movl $_new_label_14, %eax
        # initialize global variable with value
        movl %eax, (_escape_1)
        pop %eax
        push %eax
        movl $2 + 256<<2, %eax
        movl %eax, (_backslash_1)
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _new_label_18
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_new_label_19:
        .long 0xca11ab1e
        .long _new_label_20
        .long 0
        .text
        .type _new_label_20, @function
_new_label_20:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_new_label_22:
        .long 0xbabb1e
        .long 2
        .ascii "\\\\"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_new_label_24:
        .long 0xbabb1e
        .long 2
        .ascii "\\n"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_new_label_26:
        .long 0xbabb1e
        .long 2
        .ascii "\\\""
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_new_label_25:
        .long 0x2ce11ed
        .long _new_label_26
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_new_label_23:
        .long 0x2ce11ed
        .long _new_label_24
        .long _new_label_25
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_new_label_21:
        .long 0x2ce11ed
        .long _new_label_22
        .long _new_label_23
        .text
        push %eax
        movl $_new_label_21, %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_new_label_28:
        .long 0xbabb1e
        .long 1
        .ascii "\\"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_new_label_30:
        .long 0xbabb1e
        .long 1
        .ascii "\n"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_new_label_32:
        .long 0xbabb1e
        .long 1
        .ascii "\""
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_new_label_31:
        .long 0x2ce11ed
        .long _new_label_32
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_new_label_29:
        .long 0x2ce11ed
        .long _new_label_30
        .long _new_label_31
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_new_label_27:
        .long 0x2ce11ed
        .long _new_label_28
        .long _new_label_29
        .text
        push %eax
        movl $_new_label_27, %eax
        push %eax
        movl $1 + 0<<2, %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_escape_1), %eax
        # apply procedure
        # Tail call; nargs = 4
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 12(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push -8(%ebx)
        push -12(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $4, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _new_label_20, .-_new_label_20
_new_label_18:
        push %eax
        movl $_new_label_19, %eax
        # initialize global variable with value
        movl %eax, (_backslash_1)
        pop %eax
        .section .data
_asm_represent_string_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _asm_represent_string_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_asm_represent_string_3:
        .long 0xca11ab1e
        .long _asm_represent_string_4
        .long 0
        .text
        .type _asm_represent_string_4, @function
_asm_represent_string_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_asm_represent_string_5:
        .long 0xbabb1e
        .long 1
        .ascii "\""
        .text
        push %eax
        movl $_asm_represent_string_5, %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_backslash_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_asm_represent_string_6:
        .long 0xbabb1e
        .long 1
        .ascii "\""
        .text
        push %eax
        movl $_asm_represent_string_6, %eax
        # get procedure
        push %eax
        movl (_list_1), %eax
        # apply procedure
        # Tail call; nargs = 3
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 8(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push -8(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _asm_represent_string_4, .-_asm_represent_string_4
_asm_represent_string_2:
        push %eax
        movl $_asm_represent_string_3, %eax
        # initialize global variable with value
        movl %eax, (_asm_represent_string_1)
        pop %eax
        .section .data
_ascii_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _ascii_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_ascii_3:
        .long 0xca11ab1e
        .long _ascii_4
        .long 0
        .text
        .type _ascii_4, @function
_ascii_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_asm_represent_string_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_ascii_5:
        .long 0xbabb1e
        .long 7
        .ascii ".ascii "
        .text
        push %eax
        movl $_ascii_5, %eax
        # get procedure
        push %eax
        movl (_insn_1), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _ascii_4, .-_ascii_4
_ascii_2:
        push %eax
        movl $_ascii_3, %eax
        # initialize global variable with value
        movl %eax, (_ascii_1)
        pop %eax
        .section .data
_rodatum_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _rodatum_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_rodatum_3:
        .long 0xca11ab1e
        .long _rodatum_4
        .long 0
        .text
        .type _rodatum_4, @function
_rodatum_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # get procedure
        push %eax
        movl (_rodata_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_rodatum_5:
        .long 0xbabb1e
        .long 39
        .ascii "align pointers so they end in binary 00"
        .text
        push %eax
        movl $_rodatum_5, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_rodatum_6:
        .long 0xbabb1e
        .long 8
        .ascii ".align 4"
        .text
        push %eax
        movl $_rodatum_6, %eax
        # get procedure
        push %eax
        movl (_insn_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_label_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _rodatum_4, .-_rodatum_4
_rodatum_2:
        push %eax
        movl $_rodatum_3, %eax
        # initialize global variable with value
        movl %eax, (_rodatum_1)
        pop %eax
        .section .data
_compile_word_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _compile_word_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_word_3:
        .long 0xca11ab1e
        .long _compile_word_4
        .long 0
        .text
        .type _compile_word_4, @function
_compile_word_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_word_5:
        .long 0xbabb1e
        .long 6
        .ascii ".long "
        .text
        push %eax
        movl $_compile_word_5, %eax
        # get procedure
        push %eax
        movl (_insn_1), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _compile_word_4, .-_compile_word_4
_compile_word_2:
        push %eax
        movl $_compile_word_3, %eax
        # initialize global variable with value
        movl %eax, (_compile_word_1)
        pop %eax
        .section .data
_tos_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        push %eax
        movl (_eax_1), %eax
        # initialize global variable with value
        movl %eax, (_tos_1)
        pop %eax
        .section .data
_nos_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        push %eax
        movl (_esp_1), %eax
        # get procedure
        push %eax
        movl (_indirect_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # initialize global variable with value
        movl %eax, (_nos_1)
        pop %eax
        .section .data
_push_const_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _push_const_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_push_const_3:
        .long 0xca11ab1e
        .long _push_const_4
        .long 0
        .text
        .type _push_const_4, @function
_push_const_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl (_tos_1), %eax
        # get procedure
        push %eax
        movl (_asm_push_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_tos_1), %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_const_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _push_const_4, .-_push_const_4
_push_const_2:
        push %eax
        movl $_push_const_3, %eax
        # initialize global variable with value
        movl %eax, (_push_const_1)
        pop %eax
        .section .data
_pop_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _pop_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_pop_3:
        .long 0xca11ab1e
        .long _pop_4
        .long 0
        .text
        .type _pop_4, @function
_pop_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $0, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl (_tos_1), %eax
        # get procedure
        push %eax
        movl (_asm_pop_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _pop_4, .-_pop_4
_pop_2:
        push %eax
        movl $_pop_3, %eax
        # initialize global variable with value
        movl %eax, (_pop_1)
        pop %eax
        .section .data
_dup_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _dup_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_dup_3:
        .long 0xca11ab1e
        .long _dup_4
        .long 0
        .text
        .type _dup_4, @function
_dup_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $0, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl (_tos_1), %eax
        # get procedure
        push %eax
        movl (_asm_push_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _dup_4, .-_dup_4
_dup_2:
        push %eax
        movl $_dup_3, %eax
        # initialize global variable with value
        movl %eax, (_dup_1)
        pop %eax
        .section .data
_swap_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _swap_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_swap_3:
        .long 0xca11ab1e
        .long _swap_4
        .long 0
        .text
        .type _swap_4, @function
_swap_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $0, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl (_nos_1), %eax
        push %eax
        movl (_tos_1), %eax
        # get procedure
        push %eax
        movl (_xchg_1), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _swap_4, .-_swap_4
_swap_2:
        push %eax
        movl $_swap_3, %eax
        # initialize global variable with value
        movl %eax, (_swap_1)
        pop %eax
        .section .data
_stuff_to_put_in_the_header_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _stuff_to_put_in_the_header_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_stuff_to_put_in_the_header_3:
        .long 0xca11ab1e
        .long _stuff_to_put_in_the_header_4
        .long 0
        .text
        .type _stuff_to_put_in_the_header_4, @function
_stuff_to_put_in_the_header_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $0, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl $2 + 258<<2, %eax
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _stuff_to_put_in_the_header_4, .-_stuff_to_put_in_the_header_4
_stuff_to_put_in_the_header_2:
        push %eax
        movl $_stuff_to_put_in_the_header_3, %eax
        # initialize global variable with value
        movl %eax, (_stuff_to_put_in_the_header_1)
        pop %eax
        .section .data
_concatenate_thunks_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _concatenate_thunks_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_concatenate_thunks_3:
        .long 0xca11ab1e
        .long _concatenate_thunks_4
        .long 0
        .text
        .type _concatenate_thunks_4, @function
_concatenate_thunks_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $2, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # move arg from stack to heap: a
        push %eax
        movl 0(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # move arg from stack to heap: b
        push %eax
        movl 4(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # jump past the body of the lambda
        jmp _concatenate_thunks_5
        .text
        .type _concatenate_thunks_6, @function
_concatenate_thunks_6:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $0, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 a
        push 12(%eax)
        # fetch artifact from closure: 1 b
        push 16(%eax)
        # discarding useless value in %eax
        pop %eax
        # get procedure
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        pop %eax
        # get procedure
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # apply procedure
        # Tail call; nargs = 0
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea -4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _concatenate_thunks_6, .-_concatenate_thunks_6
_concatenate_thunks_5:
        # allocate bytes: 20
        push %eax
        movl (arena_pointer), %eax
        add $20, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_concatenate_thunks_6, 4(%ebx)
        movl $2, 8(%ebx)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        movl %eax, 16(%ebx)
        pop %eax
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _concatenate_thunks_4, .-_concatenate_thunks_4
_concatenate_thunks_2:
        push %eax
        movl $_concatenate_thunks_3, %eax
        # initialize global variable with value
        movl %eax, (_concatenate_thunks_1)
        pop %eax
        .section .data
_add_to_header_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _add_to_header_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_add_to_header_3:
        .long 0xca11ab1e
        .long _add_to_header_4
        .long 0
        .text
        .type _add_to_header_4, @function
_add_to_header_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl (_stuff_to_put_in_the_header_1), %eax
        # get procedure
        push %eax
        movl (_concatenate_thunks_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        movl %eax, (_stuff_to_put_in_the_header_1)
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _add_to_header_4, .-_add_to_header_4
_add_to_header_2:
        push %eax
        movl $_add_to_header_3, %eax
        # initialize global variable with value
        movl %eax, (_add_to_header_1)
        pop %eax
        .section .data
_define_error_routine_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _define_error_routine_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_define_error_routine_3:
        .long 0xca11ab1e
        .long _define_error_routine_4
        .long 0
        .text
        .type _define_error_routine_4, @function
_define_error_routine_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $2, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # move arg from stack to heap: labelname
        push %eax
        movl 0(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # move arg from stack to heap: message
        push %eax
        movl 4(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # jump past the body of the lambda
        jmp _define_error_routine_5
        .text
        .type _define_error_routine_6, @function
_define_error_routine_6:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $0, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 labelname
        push 12(%eax)
        # fetch artifact from closure: 1 message
        push 16(%eax)
        # discarding useless value in %eax
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_define_error_routine_7:
        .long 0xbabb1e
        .long 1
        .ascii "\n"
        .text
        push %eax
        movl $_define_error_routine_7, %eax
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_string_append_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_define_error_routine_8:
        .long 0xbabb1e
        .long 7
        .ascii "error: "
        .text
        push %eax
        movl $_define_error_routine_8, %eax
        # get procedure
        push %eax
        movl (_string_append_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_define_error_routine_9), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        # jump past the body of the lambda
        jmp _define_error_routine_10
        .text
        .type _define_error_routine_11, @function
_define_error_routine_11:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 labelname
        push 12(%eax)
        # discarding useless value in %eax
        pop %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_label_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_tos_1), %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_const_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_define_error_routine_12:
        .long 0xbabb1e
        .long 12
        .ascii "report_error"
        .text
        push %eax
        movl $_define_error_routine_12, %eax
        # get procedure
        push %eax
        movl (_jmp_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _define_error_routine_11, .-_define_error_routine_11
_define_error_routine_10:
        # allocate bytes: 16
        push %eax
        movl (arena_pointer), %eax
        add $16, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_define_error_routine_11, 4(%ebx)
        movl $1, 8(%ebx)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _define_error_routine_6, .-_define_error_routine_6
_define_error_routine_5:
        # allocate bytes: 20
        push %eax
        movl (arena_pointer), %eax
        add $20, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_define_error_routine_6, 4(%ebx)
        movl $2, 8(%ebx)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        movl %eax, 16(%ebx)
        pop %eax
        # get procedure
        push %eax
        movl (_add_to_header_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _define_error_routine_4, .-_define_error_routine_4
_define_error_routine_2:
        push %eax
        movl $_define_error_routine_3, %eax
        # initialize global variable with value
        movl %eax, (_define_error_routine_1)
        pop %eax
        # jump past the body of the lambda
        jmp _define_error_routine_13
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_define_error_routine_14:
        .long 0xca11ab1e
        .long _define_error_routine_15
        .long 0
        .text
        .type _define_error_routine_15, @function
_define_error_routine_15:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $0, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_define_error_routine_16:
        .long 0xbabb1e
        .long 12
        .ascii "report_error"
        .text
        push %eax
        movl $_define_error_routine_16, %eax
        # get procedure
        push %eax
        movl (_label_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_define_error_routine_17), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_define_error_routine_18:
        .long 0xbabb1e
        .long 12
        .ascii "fd 2: stderr"
        .text
        push %eax
        movl $_define_error_routine_18, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_ebx_1), %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_define_error_routine_19:
        .long 0xbabb1e
        .long 1
        .ascii "2"
        .text
        push %eax
        movl $_define_error_routine_19, %eax
        # get procedure
        push %eax
        movl (_const_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_define_error_routine_20), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_ebx_1), %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_define_error_routine_21:
        .long 0xbabb1e
        .long 1
        .ascii "1"
        .text
        push %eax
        movl $_define_error_routine_21, %eax
        # get procedure
        push %eax
        movl (_const_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_eax_1), %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_define_error_routine_22:
        .long 0xbabb1e
        .long 1
        .ascii "1"
        .text
        push %eax
        movl $_define_error_routine_22, %eax
        # get procedure
        push %eax
        movl (_const_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_syscall_1), %eax
        # apply procedure
        # Tail call; nargs = 0
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea -4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _define_error_routine_15, .-_define_error_routine_15
_define_error_routine_13:
        push %eax
        movl $_define_error_routine_14, %eax
        # get procedure
        push %eax
        movl (_add_to_header_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        .section .data
_compile_tag_check_procedure_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _compile_tag_check_procedure_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_tag_check_procedure_3:
        .long 0xca11ab1e
        .long _compile_tag_check_procedure_4
        .long 0
        .text
        .type _compile_tag_check_procedure_4, @function
_compile_tag_check_procedure_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl $1 + 0<<2, %eax
        # get procedure
        push %eax
        movl (_compile_tag_check_procedure_5), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_tos_1), %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_tag_check_procedure_6:
        .long 0xbabb1e
        .long 1
        .ascii "3"
        .text
        push %eax
        movl $_compile_tag_check_procedure_6, %eax
        # get procedure
        push %eax
        movl (_const_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_asm_and_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_tos_1), %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_const_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_cmp_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_tag_check_procedure_7:
        .long 0xbabb1e
        .long 11
        .ascii "return_true"
        .text
        push %eax
        movl $_compile_tag_check_procedure_7, %eax
        # get procedure
        push %eax
        movl (_je_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_tag_check_procedure_8:
        .long 0xbabb1e
        .long 12
        .ascii "return_false"
        .text
        push %eax
        movl $_compile_tag_check_procedure_8, %eax
        # get procedure
        push %eax
        movl (_jmp_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _compile_tag_check_procedure_4, .-_compile_tag_check_procedure_4
_compile_tag_check_procedure_2:
        push %eax
        movl $_compile_tag_check_procedure_3, %eax
        # initialize global variable with value
        movl %eax, (_compile_tag_check_procedure_1)
        pop %eax
        .section .data
_procedure_magic_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_procedure_magic_2:
        .long 0xbabb1e
        .long 10
        .ascii "0xca11ab1e"
        .text
        push %eax
        movl $_procedure_magic_2, %eax
        # initialize global variable with value
        movl %eax, (_procedure_magic_1)
        pop %eax
        .section .data
_compile_apply_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _compile_apply_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_apply_3:
        .long 0xca11ab1e
        .long _compile_apply_4
        .long 0
        .text
        .type _compile_apply_4, @function
_compile_apply_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # get procedure
        push %eax
        movl (_compile_apply_5), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_ebx_1), %eax
        push %eax
        movl $1 + 4<<2, %eax
        push %eax
        movl (_tos_1), %eax
        # get procedure
        push %eax
        movl (_offset_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_edx_1), %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_number_Gtstring_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_const_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_ebx_1), %eax
        # get procedure
        push %eax
        movl (_absolute_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_call_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _compile_apply_4, .-_compile_apply_4
_compile_apply_2:
        push %eax
        movl $_compile_apply_3, %eax
        # get procedure
        push %eax
        movl (_memo1_asm_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # initialize global variable with value
        movl %eax, (_compile_apply_1)
        pop %eax
        .section .data
_compile_tail_apply_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _compile_tail_apply_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_tail_apply_3:
        .long 0xca11ab1e
        .long _compile_tail_apply_4
        .long 0
        .text
        .type _compile_tail_apply_4, @function
_compile_tail_apply_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_number_Gtstring_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_tail_apply_5:
        .long 0xbabb1e
        .long 19
        .ascii "Tail call; nargs = "
        .text
        push %eax
        movl $_compile_tail_apply_5, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_tail_apply_6:
        .long 0xbabb1e
        .long 42
        .ascii "Note %esp points at the last thing pushed,"
        .text
        push %eax
        movl $_compile_tail_apply_6, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_tail_apply_7:
        .long 0xbabb1e
        .long 60
        .ascii "not the next thing to push.  So for 1 arg, we want %ebx=%esp"
        .text
        push %eax
        movl $_compile_tail_apply_7, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_ebx_1), %eax
        push %eax
        movl 0(%ebp), %eax
        call ensure_integer
        add $-1<<2, %eax
        # get procedure
        push %eax
        movl (_quadruple_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl (_esp_1), %eax
        # get procedure
        push %eax
        movl (_offset_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_lea_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_edx_1), %eax
        # get procedure
        push %eax
        movl (_compile_tail_apply_8), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl $1 + 0<<2, %eax
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl (_ebx_1), %eax
        # get procedure
        push %eax
        movl (_compile_tail_apply_9), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_edx_1), %eax
        # get procedure
        push %eax
        movl (_asm_push_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_compile_apply_5), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_ebx_1), %eax
        push %eax
        movl $1 + 4<<2, %eax
        push %eax
        movl (_tos_1), %eax
        # get procedure
        push %eax
        movl (_offset_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_edx_1), %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_number_Gtstring_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_const_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_ebx_1), %eax
        # get procedure
        push %eax
        movl (_absolute_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_jmp_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _compile_tail_apply_4, .-_compile_tail_apply_4
_compile_tail_apply_2:
        push %eax
        movl $_compile_tail_apply_3, %eax
        # get procedure
        push %eax
        movl (_memo1_asm_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # initialize global variable with value
        movl %eax, (_compile_tail_apply_1)
        pop %eax
        .section .data
_compile_tail_apply_9:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _copy_args_1
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_copy_args_2:
        .long 0xca11ab1e
        .long _copy_args_3
        .long 0
        .text
        .type _copy_args_3, @function
_copy_args_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $3, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 4(%ebp), %eax
        push %eax
        movl 8(%ebp), %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _copy_args_4
        push %eax
        movl $2 + 258<<2, %eax
        jmp _copy_args_5
_copy_args_4:
        push %eax
        movl 8(%ebp), %eax
        # get procedure
        push %eax
        movl (_quadruple_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $1 + 0<<2, %eax
        # inlined integer subtract
        call ensure_integer
        xchg %eax, (%esp)
        call ensure_integer
        sub %eax, (%esp)
        pop %eax
        inc %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_offset_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_asm_push_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl 8(%ebp), %eax
        # 1+
        call ensure_integer
        add $1<<2, %eax
        push %eax
        movl 4(%ebp), %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_compile_tail_apply_9), %eax
        # apply procedure
        # Tail call; nargs = 3
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 8(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push -8(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        jmp *%ebx
_copy_args_5:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _copy_args_3, .-_copy_args_3
_copy_args_1:
        push %eax
        movl $_copy_args_2, %eax
        # initialize global variable with value
        movl %eax, (_compile_tail_apply_9)
        pop %eax
        # jump past the body of the lambda
        jmp _copy_args_6
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_copy_args_7:
        .long 0xca11ab1e
        .long _copy_args_8
        .long 0
        .text
        .type _copy_args_8, @function
_copy_args_8:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $0, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_copy_args_9:
        .long 0xbabb1e
        .long 24
        .ascii "package_up_variadic_args"
        .text
        push %eax
        movl $_copy_args_9, %eax
        # get procedure
        push %eax
        movl (_label_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_copy_args_10:
        .long 0xbabb1e
        .long 46
        .ascii "we have %ebp pointing at args, %edx with count"
        .text
        push %eax
        movl $_copy_args_10, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_copy_args_11:
        .long 0xbabb1e
        .long 53
        .ascii "saved %ebp in %eax.  zero-iterations case: return nil"
        .text
        push %eax
        movl $_copy_args_11, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_copy_args_12), %eax
        # get procedure
        push %eax
        movl (_push_const_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_copy_args_13:
        .long 0xbabb1e
        .long 13
        .ascii "variadic_loop"
        .text
        push %eax
        movl $_copy_args_13, %eax
        # get procedure
        push %eax
        movl (_label_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_edx_1), %eax
        # get procedure
        push %eax
        movl (_dec_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_copy_args_14:
        .long 0xbabb1e
        .long 58
        .ascii "fucking dec doesn't update carry flag, so jump if negative"
        .text
        push %eax
        movl $_copy_args_14, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_copy_args_15:
        .long 0xbabb1e
        .long 17
        .ascii "variadic_loop_end"
        .text
        push %eax
        movl $_copy_args_15, %eax
        # get procedure
        push %eax
        movl (_js_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_copy_args_16:
        .long 0xbabb1e
        .long 45
        .ascii "calling cons clobbers registers, so push %edx"
        .text
        push %eax
        movl $_copy_args_16, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_edx_1), %eax
        # get procedure
        push %eax
        movl (_asm_push_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_copy_args_17:
        .long 0xbabb1e
        .long 22
        .ascii "now push args for cons"
        .text
        push %eax
        movl $_copy_args_17, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_eax_1), %eax
        # get procedure
        push %eax
        movl (_asm_push_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl $1 + 4<<2, %eax
        push %eax
        movl $1 + 4<<2, %eax
        push %eax
        movl (_edx_1), %eax
        push %eax
        movl (_ebp_1), %eax
        # get procedure
        push %eax
        movl (_index_register_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_offset_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_asm_push_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_copy_args_18:
        .long 0xbabb1e
        .long 28
        .ascii "give cons its argument count"
        .text
        push %eax
        movl $_copy_args_18, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_edx_1), %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_copy_args_19:
        .long 0xbabb1e
        .long 1
        .ascii "2"
        .text
        push %eax
        movl $_copy_args_19, %eax
        # get procedure
        push %eax
        movl (_const_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_copy_args_20:
        .long 0xbabb1e
        .long 4
        .ascii "cons"
        .text
        push %eax
        movl $_copy_args_20, %eax
        # get procedure
        push %eax
        movl (_call_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_copy_args_21:
        .long 0xbabb1e
        .long 52
        .ascii "now the args are popped and we have new list in %eax"
        .text
        push %eax
        movl $_copy_args_21, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_edx_1), %eax
        # get procedure
        push %eax
        movl (_asm_pop_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_copy_args_22:
        .long 0xbabb1e
        .long 13
        .ascii "variadic_loop"
        .text
        push %eax
        movl $_copy_args_22, %eax
        # get procedure
        push %eax
        movl (_jmp_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_copy_args_23:
        .long 0xbabb1e
        .long 17
        .ascii "variadic_loop_end"
        .text
        push %eax
        movl $_copy_args_23, %eax
        # get procedure
        push %eax
        movl (_label_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_copy_args_24:
        .long 0xbabb1e
        .long 62
        .ascii "now we pretend procedure was called with the list as first arg"
        .text
        push %eax
        movl $_copy_args_24, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_ebp_1), %eax
        # get procedure
        push %eax
        movl (_indirect_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl (_eax_1), %eax
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_copy_args_25:
        .long 0xbabb1e
        .long 58
        .ascii "restore %eax to value on entry to package_up_variadic_args"
        .text
        push %eax
        movl $_copy_args_25, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_pop_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_ret_1), %eax
        # apply procedure
        # Tail call; nargs = 0
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea -4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _copy_args_8, .-_copy_args_8
_copy_args_6:
        push %eax
        movl $_copy_args_7, %eax
        # get procedure
        push %eax
        movl (_add_to_header_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        .section .data
_compile_variadic_prologue_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _compile_variadic_prologue_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_variadic_prologue_3:
        .long 0xca11ab1e
        .long _compile_variadic_prologue_4
        .long 0
        .text
        .type _compile_variadic_prologue_4, @function
_compile_variadic_prologue_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $0, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_variadic_prologue_5:
        .long 0xbabb1e
        .long 37
        .ascii "make space for variadic argument list"
        .text
        push %eax
        movl $_compile_variadic_prologue_5, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_ebx_1), %eax
        # get procedure
        push %eax
        movl (_asm_pop_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_ebx_1), %eax
        # get procedure
        push %eax
        movl (_asm_push_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_ebx_1), %eax
        # get procedure
        push %eax
        movl (_asm_push_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_variadic_prologue_6:
        .long 0xbabb1e
        .long 27
        .ascii "push desired %esp on return"
        .text
        push %eax
        movl $_compile_variadic_prologue_6, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_ebx_1), %eax
        push %eax
        movl $1 + 8<<2, %eax
        push %eax
        movl $1 + 4<<2, %eax
        push %eax
        movl (_edx_1), %eax
        push %eax
        movl (_esp_1), %eax
        # get procedure
        push %eax
        movl (_index_register_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_offset_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_lea_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_ebx_1), %eax
        # get procedure
        push %eax
        movl (_asm_push_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_ebp_1), %eax
        # get procedure
        push %eax
        movl (_asm_push_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_ebp_1), %eax
        push %eax
        movl $1 + 12<<2, %eax
        push %eax
        movl (_esp_1), %eax
        # get procedure
        push %eax
        movl (_offset_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_lea_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_variadic_prologue_7:
        .long 0xbabb1e
        .long 24
        .ascii "package_up_variadic_args"
        .text
        push %eax
        movl $_compile_variadic_prologue_7, %eax
        # get procedure
        push %eax
        movl (_call_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _compile_variadic_prologue_4, .-_compile_variadic_prologue_4
_compile_variadic_prologue_2:
        push %eax
        movl $_compile_variadic_prologue_3, %eax
        # initialize global variable with value
        movl %eax, (_compile_variadic_prologue_1)
        pop %eax
        .section .data
_compile_procedure_prologue_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _compile_procedure_prologue_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_procedure_prologue_3:
        .long 0xca11ab1e
        .long _compile_procedure_prologue_4
        .long 0
        .text
        .type _compile_procedure_prologue_4, @function
_compile_procedure_prologue_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl $2 + 256<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _compile_procedure_prologue_5
        # get procedure
        push %eax
        movl (_compile_variadic_prologue_1), %eax
        # apply procedure
        # Tail call; nargs = 0
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea -4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        jmp *%ebx
        jmp _compile_procedure_prologue_6
_compile_procedure_prologue_5:
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_procedure_prologue_7:
        .long 0xbabb1e
        .long 50
        .ascii "compute desired %esp on return in %ebx and push it"
        .text
        push %eax
        movl $_compile_procedure_prologue_7, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_procedure_prologue_8:
        .long 0xbabb1e
        .long 51
        .ascii "the extra offset of 4 skips over the return address"
        .text
        push %eax
        movl $_compile_procedure_prologue_8, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_ebx_1), %eax
        push %eax
        movl $1 + 4<<2, %eax
        push %eax
        movl $1 + 4<<2, %eax
        push %eax
        movl (_edx_1), %eax
        push %eax
        movl (_esp_1), %eax
        # get procedure
        push %eax
        movl (_index_register_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_offset_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_lea_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_ebx_1), %eax
        # get procedure
        push %eax
        movl (_asm_push_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_ebp_1), %eax
        # get procedure
        push %eax
        movl (_asm_push_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_ebp_1), %eax
        push %eax
        movl $1 + 12<<2, %eax
        push %eax
        movl (_esp_1), %eax
        # get procedure
        push %eax
        movl (_offset_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_lea_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_edx_1), %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_number_Gtstring_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_const_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_cmp_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_procedure_prologue_9:
        .long 0xbabb1e
        .long 20
        .ascii "argument_count_wrong"
        .text
        push %eax
        movl $_compile_procedure_prologue_9, %eax
        # get procedure
        push %eax
        movl (_jnz_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
_compile_procedure_prologue_6:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _compile_procedure_prologue_4, .-_compile_procedure_prologue_4
_compile_procedure_prologue_2:
        push %eax
        movl $_compile_procedure_prologue_3, %eax
        # get procedure
        push %eax
        movl (_memo1_asm_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # initialize global variable with value
        movl %eax, (_compile_procedure_prologue_1)
        pop %eax
        .section .data
_compile_procedure_epilogue_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _compile_procedure_epilogue_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_procedure_epilogue_3:
        .long 0xca11ab1e
        .long _compile_procedure_epilogue_4
        .long 0
        .text
        .type _compile_procedure_epilogue_4, @function
_compile_procedure_epilogue_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $0, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_procedure_epilogue_5:
        .long 0xbabb1e
        .long 18
        .ascii "procedure epilogue"
        .text
        push %eax
        movl $_compile_procedure_epilogue_5, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_procedure_epilogue_6:
        .long 0xbabb1e
        .long 18
        .ascii "get return address"
        .text
        push %eax
        movl $_compile_procedure_epilogue_6, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_edx_1), %eax
        # get procedure
        push %eax
        movl (_compile_tail_apply_8), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_edx_1), %eax
        # get procedure
        push %eax
        movl (_absolute_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_jmp_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _compile_procedure_epilogue_4, .-_compile_procedure_epilogue_4
_compile_procedure_epilogue_2:
        push %eax
        movl $_compile_procedure_epilogue_3, %eax
        # get procedure
        push %eax
        movl (_memo0_asm_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # initialize global variable with value
        movl %eax, (_compile_procedure_epilogue_1)
        pop %eax
        .section .data
_compile_tail_apply_8:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _pop_stack_frame_1
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_pop_stack_frame_2:
        .long 0xca11ab1e
        .long _pop_stack_frame_3
        .long 0
        .text
        .type _pop_stack_frame_3, @function
_pop_stack_frame_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl $1 + -4<<2, %eax
        push %eax
        movl (_ebp_1), %eax
        # get procedure
        push %eax
        movl (_offset_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_esp_1), %eax
        push %eax
        movl $1 + -8<<2, %eax
        push %eax
        movl (_ebp_1), %eax
        # get procedure
        push %eax
        movl (_offset_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_ebp_1), %eax
        push %eax
        movl $1 + -12<<2, %eax
        push %eax
        movl (_ebp_1), %eax
        # get procedure
        push %eax
        movl (_offset_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _pop_stack_frame_3, .-_pop_stack_frame_3
_pop_stack_frame_1:
        push %eax
        movl $_pop_stack_frame_2, %eax
        # initialize global variable with value
        movl %eax, (_compile_tail_apply_8)
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_pop_stack_frame_4:
        .long 0xbabb1e
        .long 25
        .ascii "wrong number of arguments"
        .text
        push %eax
        movl $_pop_stack_frame_4, %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_pop_stack_frame_5:
        .long 0xbabb1e
        .long 20
        .ascii "argument_count_wrong"
        .text
        push %eax
        movl $_pop_stack_frame_5, %eax
        # get procedure
        push %eax
        movl (_define_error_routine_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .data
_compile_procedure_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _compile_procedure_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_procedure_3:
        .long 0xca11ab1e
        .long _compile_procedure_4
        .long 0
        .text
        .type _compile_procedure_4, @function
_compile_procedure_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $3, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # get procedure
        push %eax
        movl (_text_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_procedure_5:
        .long 0xbabb1e
        .long 11
        .ascii ", @function"
        .text
        push %eax
        movl $_compile_procedure_5, %eax
        push %eax
        movl 0(%ebp), %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_procedure_6:
        .long 0xbabb1e
        .long 6
        .ascii ".type "
        .text
        push %eax
        movl $_compile_procedure_6, %eax
        # get procedure
        push %eax
        movl (_insn_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        call *%ebx
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_label_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl 4(%ebp), %eax
        # get procedure
        push %eax
        movl (_compile_procedure_prologue_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl 8(%ebp), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_compile_procedure_epilogue_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_procedure_7:
        .long 0xbabb1e
        .long 4
        .ascii ", .-"
        .text
        push %eax
        movl $_compile_procedure_7, %eax
        push %eax
        movl 0(%ebp), %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_procedure_8:
        .long 0xbabb1e
        .long 6
        .ascii ".size "
        .text
        push %eax
        movl $_compile_procedure_8, %eax
        # get procedure
        push %eax
        movl (_insn_1), %eax
        # apply procedure
        # Tail call; nargs = 4
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 12(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push -8(%ebx)
        push -12(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $4, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _compile_procedure_4, .-_compile_procedure_4
_compile_procedure_2:
        push %eax
        movl $_compile_procedure_3, %eax
        # initialize global variable with value
        movl %eax, (_compile_procedure_1)
        pop %eax
        .section .data
_compile_procedure_labeled_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _compile_procedure_labeled_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_procedure_labeled_3:
        .long 0xca11ab1e
        .long _compile_procedure_labeled_4
        .long 0
        .text
        .type _compile_procedure_labeled_4, @function
_compile_procedure_labeled_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $3, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # move arg from stack to heap: labelname
        push %eax
        movl 0(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # move arg from stack to heap: nargs
        push %eax
        movl 4(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # move arg from stack to heap: body
        push %eax
        movl 8(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # get procedure
        push %eax
        movl (_new_label_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        # get procedure
        # jump past the body of the lambda
        jmp _compile_procedure_labeled_5
        .text
        .type _compile_procedure_labeled_6, @function
_compile_procedure_labeled_6:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 labelname
        push 12(%eax)
        # fetch artifact from closure: 1 nargs
        push 16(%eax)
        # fetch artifact from closure: 2 body
        push 20(%eax)
        # discarding useless value in %eax
        pop %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_rodatum_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_procedure_magic_1), %eax
        # get procedure
        push %eax
        movl (_compile_word_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_compile_word_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_procedure_labeled_7:
        .long 0xbabb1e
        .long 1
        .ascii "0"
        .text
        push %eax
        movl $_compile_procedure_labeled_7, %eax
        # get procedure
        push %eax
        movl (_compile_word_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        # fetching heap var pointer 2
        push %eax
        movl -24(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_compile_procedure_1), %eax
        # apply procedure
        # Tail call; nargs = 3
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 8(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push -8(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _compile_procedure_labeled_6, .-_compile_procedure_labeled_6
_compile_procedure_labeled_5:
        # allocate bytes: 24
        push %eax
        movl (arena_pointer), %eax
        add $24, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_compile_procedure_labeled_6, 4(%ebx)
        movl $3, 8(%ebx)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        movl %eax, 16(%ebx)
        pop %eax
        # fetching heap var pointer 2
        push %eax
        movl -24(%ebp), %eax
        movl %eax, 20(%ebx)
        pop %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _compile_procedure_labeled_4, .-_compile_procedure_labeled_4
_compile_procedure_labeled_2:
        push %eax
        movl $_compile_procedure_labeled_3, %eax
        # initialize global variable with value
        movl %eax, (_compile_procedure_labeled_1)
        pop %eax
        .section .data
_define_global_procedure_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _define_global_procedure_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_define_global_procedure_3:
        .long 0xca11ab1e
        .long _define_global_procedure_4
        .long 0
        .text
        .type _define_global_procedure_4, @function
_define_global_procedure_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $3, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # move arg from stack to heap: symbolname
        push %eax
        movl 0(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # move arg from stack to heap: nargs
        push %eax
        movl 4(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # move arg from stack to heap: body
        push %eax
        movl 8(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # jump past the body of the lambda
        jmp _define_global_procedure_5
        .text
        .type _define_global_procedure_6, @function
_define_global_procedure_6:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $0, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 symbolname
        push 12(%eax)
        # fetch artifact from closure: 1 nargs
        push 16(%eax)
        # fetch artifact from closure: 2 body
        push 20(%eax)
        # discarding useless value in %eax
        pop %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_set_label_prefix_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_new_label_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        # get procedure
        # jump past the body of the lambda
        jmp _define_global_procedure_7
        .text
        .type _define_global_procedure_8, @function
_define_global_procedure_8:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 symbolname
        push 12(%eax)
        # fetch artifact from closure: 1 nargs
        push 16(%eax)
        # fetch artifact from closure: 2 body
        push 20(%eax)
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_define_global_procedure_9), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        # fetching heap var pointer 2
        push %eax
        movl -24(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_compile_procedure_labeled_1), %eax
        # apply procedure
        # Tail call; nargs = 3
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 8(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push -8(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _define_global_procedure_8, .-_define_global_procedure_8
_define_global_procedure_7:
        # allocate bytes: 24
        push %eax
        movl (arena_pointer), %eax
        add $24, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_define_global_procedure_8, 4(%ebx)
        movl $3, 8(%ebx)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        movl %eax, 16(%ebx)
        pop %eax
        # fetching heap var pointer 2
        push %eax
        movl -24(%ebp), %eax
        movl %eax, 20(%ebx)
        pop %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _define_global_procedure_6, .-_define_global_procedure_6
_define_global_procedure_5:
        # allocate bytes: 24
        push %eax
        movl (arena_pointer), %eax
        add $24, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_define_global_procedure_6, 4(%ebx)
        movl $3, 8(%ebx)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        movl %eax, 16(%ebx)
        pop %eax
        # fetching heap var pointer 2
        push %eax
        movl -24(%ebp), %eax
        movl %eax, 20(%ebx)
        pop %eax
        # get procedure
        push %eax
        movl (_add_to_header_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _define_global_procedure_4, .-_define_global_procedure_4
_define_global_procedure_2:
        push %eax
        movl $_define_global_procedure_3, %eax
        # initialize global variable with value
        movl %eax, (_define_global_procedure_1)
        pop %eax
        .section .data
_if_not_right_magic_jump_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _if_not_right_magic_jump_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_if_not_right_magic_jump_3:
        .long 0xca11ab1e
        .long _if_not_right_magic_jump_4
        .long 0
        .text
        .type _if_not_right_magic_jump_4, @function
_if_not_right_magic_jump_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $2, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_if_not_right_magic_jump_5:
        .long 0xbabb1e
        .long 29
        .ascii "test whether %eax has magic: "
        .text
        push %eax
        movl $_if_not_right_magic_jump_5, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_if_not_right_magic_jump_6:
        .long 0xbabb1e
        .long 56
        .ascii "first, ensure that it's a pointer, not something unboxed"
        .text
        push %eax
        movl $_if_not_right_magic_jump_6, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_tos_1), %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_if_not_right_magic_jump_7:
        .long 0xbabb1e
        .long 1
        .ascii "3"
        .text
        push %eax
        movl $_if_not_right_magic_jump_7, %eax
        # get procedure
        push %eax
        movl (_const_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_test_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl 4(%ebp), %eax
        # get procedure
        push %eax
        movl (_jnz_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_if_not_right_magic_jump_8:
        .long 0xbabb1e
        .long 26
        .ascii "now, test its magic number"
        .text
        push %eax
        movl $_if_not_right_magic_jump_8, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_tos_1), %eax
        # get procedure
        push %eax
        movl (_indirect_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_const_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_cmp_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl 4(%ebp), %eax
        # get procedure
        push %eax
        movl (_jnz_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _if_not_right_magic_jump_4, .-_if_not_right_magic_jump_4
_if_not_right_magic_jump_2:
        push %eax
        movl $_if_not_right_magic_jump_3, %eax
        # initialize global variable with value
        movl %eax, (_if_not_right_magic_jump_1)
        pop %eax
        .section .data
_call_ensure_magic_routine_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _call_ensure_magic_routine_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_call_ensure_magic_routine_3:
        .long 0xca11ab1e
        .long _call_ensure_magic_routine_4
        .long 0
        .text
        .type _call_ensure_magic_routine_4, @function
_call_ensure_magic_routine_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $3, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # move arg from stack to heap: magic
        push %eax
        movl 0(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # move arg from stack to heap: routine-label
        push %eax
        movl 4(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # move arg from stack to heap: errmsg
        push %eax
        movl 8(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # get procedure
        push %eax
        movl (_new_label_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        # get procedure
        # jump past the body of the lambda
        jmp _call_ensure_magic_routine_5
        .text
        .type _call_ensure_magic_routine_6, @function
_call_ensure_magic_routine_6:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 errmsg
        push 12(%eax)
        # fetch artifact from closure: 1 routine-label
        push 16(%eax)
        # fetch artifact from closure: 2 magic
        push 20(%eax)
        # discarding useless value in %eax
        pop %eax
        # move arg from stack to heap: errlabel
        push %eax
        movl 0(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # fetching heap var pointer 3
        push %eax
        movl -28(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_define_error_routine_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        # jump past the body of the lambda
        jmp _call_ensure_magic_routine_7
        .text
        .type _call_ensure_magic_routine_8, @function
_call_ensure_magic_routine_8:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $0, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 routine-label
        push 12(%eax)
        # fetch artifact from closure: 1 magic
        push 16(%eax)
        # fetch artifact from closure: 2 errlabel
        push 20(%eax)
        # discarding useless value in %eax
        pop %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_label_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        # fetching heap var pointer 2
        push %eax
        movl -24(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_if_not_right_magic_jump_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_ret_1), %eax
        # apply procedure
        # Tail call; nargs = 0
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea -4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _call_ensure_magic_routine_8, .-_call_ensure_magic_routine_8
_call_ensure_magic_routine_7:
        # allocate bytes: 24
        push %eax
        movl (arena_pointer), %eax
        add $24, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_call_ensure_magic_routine_8, 4(%ebx)
        movl $3, 8(%ebx)
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # fetching heap var pointer 2
        push %eax
        movl -24(%ebp), %eax
        movl %eax, 16(%ebx)
        pop %eax
        # fetching heap var pointer 3
        push %eax
        movl -28(%ebp), %eax
        movl %eax, 20(%ebx)
        pop %eax
        # get procedure
        push %eax
        movl (_add_to_header_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _call_ensure_magic_routine_6, .-_call_ensure_magic_routine_6
_call_ensure_magic_routine_5:
        # allocate bytes: 24
        push %eax
        movl (arena_pointer), %eax
        add $24, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_call_ensure_magic_routine_6, 4(%ebx)
        movl $3, 8(%ebx)
        # fetching heap var pointer 2
        push %eax
        movl -24(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        movl %eax, 16(%ebx)
        pop %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl %eax, 20(%ebx)
        pop %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        # jump past the body of the lambda
        jmp _call_ensure_magic_routine_9
        .text
        .type _call_ensure_magic_routine_10, @function
_call_ensure_magic_routine_10:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $0, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 routine-label
        push 12(%eax)
        # discarding useless value in %eax
        pop %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_call_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _call_ensure_magic_routine_10, .-_call_ensure_magic_routine_10
_call_ensure_magic_routine_9:
        # allocate bytes: 16
        push %eax
        movl (arena_pointer), %eax
        add $16, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_call_ensure_magic_routine_10, 4(%ebx)
        movl $1, 8(%ebx)
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _call_ensure_magic_routine_4, .-_call_ensure_magic_routine_4
_call_ensure_magic_routine_2:
        push %eax
        movl $_call_ensure_magic_routine_3, %eax
        # initialize global variable with value
        movl %eax, (_call_ensure_magic_routine_1)
        pop %eax
        # jump past the body of the lambda
        jmp _call_ensure_magic_routine_11
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_call_ensure_magic_routine_12:
        .long 0xca11ab1e
        .long _call_ensure_magic_routine_13
        .long 0
        .text
        .type _call_ensure_magic_routine_13, @function
_call_ensure_magic_routine_13:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $0, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_call_ensure_magic_routine_14:
        .long 0xbabb1e
        .long 11
        .ascii "return_true"
        .text
        push %eax
        movl $_call_ensure_magic_routine_14, %eax
        # get procedure
        push %eax
        movl (_label_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_tos_1), %eax
        push %eax
        movl (_call_ensure_magic_routine_15), %eax
        # get procedure
        push %eax
        movl (_const_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_compile_procedure_epilogue_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_call_ensure_magic_routine_16:
        .long 0xbabb1e
        .long 12
        .ascii "return_false"
        .text
        push %eax
        movl $_call_ensure_magic_routine_16, %eax
        # get procedure
        push %eax
        movl (_label_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_tos_1), %eax
        push %eax
        movl (_call_ensure_magic_routine_17), %eax
        # get procedure
        push %eax
        movl (_const_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_compile_procedure_epilogue_1), %eax
        # apply procedure
        # Tail call; nargs = 0
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea -4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _call_ensure_magic_routine_13, .-_call_ensure_magic_routine_13
_call_ensure_magic_routine_11:
        push %eax
        movl $_call_ensure_magic_routine_12, %eax
        # get procedure
        push %eax
        movl (_add_to_header_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        .section .data
_define_magic_check_primitive_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _define_magic_check_primitive_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_define_magic_check_primitive_3:
        .long 0xca11ab1e
        .long _define_magic_check_primitive_4
        .long 0
        .text
        .type _define_magic_check_primitive_4, @function
_define_magic_check_primitive_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $2, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # move arg from stack to heap: magic
        push %eax
        movl 4(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # jump past the body of the lambda
        jmp _define_magic_check_primitive_5
        .text
        .type _define_magic_check_primitive_6, @function
_define_magic_check_primitive_6:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $0, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 magic
        push 12(%eax)
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl $1 + 0<<2, %eax
        # get procedure
        push %eax
        movl (_compile_tag_check_procedure_5), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_define_magic_check_primitive_7:
        .long 0xbabb1e
        .long 12
        .ascii "return_false"
        .text
        push %eax
        movl $_define_magic_check_primitive_7, %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_if_not_right_magic_jump_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_define_magic_check_primitive_8:
        .long 0xbabb1e
        .long 11
        .ascii "return_true"
        .text
        push %eax
        movl $_define_magic_check_primitive_8, %eax
        # get procedure
        push %eax
        movl (_jmp_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _define_magic_check_primitive_6, .-_define_magic_check_primitive_6
_define_magic_check_primitive_5:
        # allocate bytes: 16
        push %eax
        movl (arena_pointer), %eax
        add $16, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_define_magic_check_primitive_6, 4(%ebx)
        movl $1, 8(%ebx)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        push %eax
        movl $1 + 1<<2, %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_define_global_procedure_1), %eax
        # apply procedure
        # Tail call; nargs = 3
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 8(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push -8(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _define_magic_check_primitive_4, .-_define_magic_check_primitive_4
_define_magic_check_primitive_2:
        push %eax
        movl $_define_magic_check_primitive_3, %eax
        # initialize global variable with value
        movl %eax, (_define_magic_check_primitive_1)
        pop %eax
        push %eax
        movl (_procedure_magic_1), %eax
        push %eax
        movl $_define_magic_check_primitive_9, %eax
        # get procedure
        push %eax
        movl (_define_magic_check_primitive_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .data
_compile_apply_5:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_ensure_procedure_1:
        .long 0xbabb1e
        .long 15
        .ascii "not a procedure"
        .text
        push %eax
        movl $_ensure_procedure_1, %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_ensure_procedure_2:
        .long 0xbabb1e
        .long 16
        .ascii "ensure_procedure"
        .text
        push %eax
        movl $_ensure_procedure_2, %eax
        push %eax
        movl (_procedure_magic_1), %eax
        # get procedure
        push %eax
        movl (_call_ensure_magic_routine_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        call *%ebx
        # initialize global variable with value
        movl %eax, (_compile_apply_5)
        pop %eax
        .section .data
_compile_tag_check_procedure_5:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _get_procedure_arg_1
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_get_procedure_arg_2:
        .long 0xca11ab1e
        .long _get_procedure_arg_3
        .long 0
        .text
        .type _get_procedure_arg_3, @function
_get_procedure_arg_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl (_tos_1), %eax
        # get procedure
        push %eax
        movl (_asm_push_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_tos_1), %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_quadruple_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl (_ebp_1), %eax
        # get procedure
        push %eax
        movl (_offset_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _get_procedure_arg_3, .-_get_procedure_arg_3
_get_procedure_arg_1:
        push %eax
        movl $_get_procedure_arg_2, %eax
        # get procedure
        push %eax
        movl (_memo1_asm_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # initialize global variable with value
        movl %eax, (_compile_tag_check_procedure_5)
        pop %eax
        .section .data
_set_procedure_arg_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _set_procedure_arg_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_procedure_arg_3:
        .long 0xca11ab1e
        .long _set_procedure_arg_4
        .long 0
        .text
        .type _set_procedure_arg_4, @function
_set_procedure_arg_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_quadruple_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl (_ebp_1), %eax
        # get procedure
        push %eax
        movl (_offset_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        push %eax
        movl (_tos_1), %eax
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _set_procedure_arg_4, .-_set_procedure_arg_4
_set_procedure_arg_2:
        push %eax
        movl $_set_procedure_arg_3, %eax
        # initialize global variable with value
        movl %eax, (_set_procedure_arg_1)
        pop %eax
        .section .data
_set_subtract_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _set_subtract_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_subtract_3:
        .long 0xca11ab1e
        .long _set_subtract_4
        .long 0
        .text
        .type _set_subtract_4, @function
_set_subtract_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $2, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # move arg from stack to heap: b
        push %eax
        movl 4(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        push %eax
        movl 0(%ebp), %eax
        # jump past the body of the lambda
        jmp _set_subtract_5
        .text
        .type _set_subtract_6, @function
_set_subtract_6:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 b
        push 12(%eax)
        # discarding useless value in %eax
        pop %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_memq_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_not_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _set_subtract_6, .-_set_subtract_6
_set_subtract_5:
        # allocate bytes: 16
        push %eax
        movl (arena_pointer), %eax
        add $16, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_set_subtract_6, 4(%ebx)
        movl $1, 8(%ebx)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # get procedure
        push %eax
        movl (_filter_1), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _set_subtract_4, .-_set_subtract_4
_set_subtract_2:
        push %eax
        movl $_set_subtract_3, %eax
        # initialize global variable with value
        movl %eax, (_set_subtract_1)
        pop %eax
        .section .data
_set_equal_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _set_equal_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_equal_3:
        .long 0xca11ab1e
        .long _set_equal_4
        .long 0
        .text
        .type _set_equal_4, @function
_set_equal_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $2, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl 4(%ebp), %eax
        # get procedure
        push %eax
        movl (_set_subtract_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        push %eax
        movl 4(%ebp), %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_set_subtract_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_eqP_1), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _set_equal_4, .-_set_equal_4
_set_equal_2:
        push %eax
        movl $_set_equal_3, %eax
        # initialize global variable with value
        movl %eax, (_set_equal_1)
        pop %eax
        .section .data
_add_if_not_present_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _add_if_not_present_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_add_if_not_present_3:
        .long 0xca11ab1e
        .long _add_if_not_present_4
        .long 0
        .text
        .type _add_if_not_present_4, @function
_add_if_not_present_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $2, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 4(%ebp), %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_memq_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _add_if_not_present_5
        push %eax
        movl 4(%ebp), %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_cons_2), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        jmp _add_if_not_present_6
_add_if_not_present_5:
        push %eax
        movl 4(%ebp), %eax
_add_if_not_present_6:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _add_if_not_present_4, .-_add_if_not_present_4
_add_if_not_present_2:
        push %eax
        movl $_add_if_not_present_3, %eax
        # initialize global variable with value
        movl %eax, (_add_if_not_present_1)
        pop %eax
        .section .data
_set_union_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _set_union_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_union_3:
        .long 0xca11ab1e
        .long _set_union_4
        .long 0
        .text
        .type _set_union_4, @function
_set_union_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $2, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 4(%ebp), %eax
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl (_add_if_not_present_1), %eax
        # get procedure
        push %eax
        movl (_reduce_1), %eax
        # apply procedure
        # Tail call; nargs = 3
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 8(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push -8(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _set_union_4, .-_set_union_4
_set_union_2:
        push %eax
        movl $_set_union_3, %eax
        # initialize global variable with value
        movl %eax, (_set_union_1)
        pop %eax
        .section .data
_set_intersect_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _set_intersect_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_intersect_3:
        .long 0xca11ab1e
        .long _set_intersect_4
        .long 0
        .text
        .type _set_intersect_4, @function
_set_intersect_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $2, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # move arg from stack to heap: b
        push %eax
        movl 4(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        push %eax
        movl 0(%ebp), %eax
        # jump past the body of the lambda
        jmp _set_intersect_5
        .text
        .type _set_intersect_6, @function
_set_intersect_6:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 b
        push 12(%eax)
        # discarding useless value in %eax
        pop %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_memq_1), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _set_intersect_6, .-_set_intersect_6
_set_intersect_5:
        # allocate bytes: 16
        push %eax
        movl (arena_pointer), %eax
        add $16, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_set_intersect_6, 4(%ebx)
        movl $1, 8(%ebx)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # get procedure
        push %eax
        movl (_filter_1), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _set_intersect_4, .-_set_intersect_4
_set_intersect_2:
        push %eax
        movl $_set_intersect_3, %eax
        # initialize global variable with value
        movl %eax, (_set_intersect_1)
        pop %eax
        .section .data
_set_union_all_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _set_union_all_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_union_all_3:
        .long 0xca11ab1e
        .long _set_union_all_4
        .long 0
        .text
        .type _set_union_all_4, @function
_set_union_all_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl $2 + 256<<2, %eax
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl (_set_union_1), %eax
        # get procedure
        push %eax
        movl (_reduce_1), %eax
        # apply procedure
        # Tail call; nargs = 3
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 8(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push -8(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _set_union_all_4, .-_set_union_all_4
_set_union_all_2:
        push %eax
        movl $_set_union_all_3, %eax
        # initialize global variable with value
        movl %eax, (_set_union_all_1)
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_union_all_5:
        .long 0xbabb1e
        .long 18
        .ascii "empty set equality"
        .text
        push %eax
        movl $_set_union_all_5, %eax
        push %eax
        movl $2 + 256<<2, %eax
        push %eax
        movl $2 + 256<<2, %eax
        # get procedure
        push %eax
        movl (_set_equal_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_assert_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_union_all_6:
        .long 0xbabb1e
        .long 26
        .ascii "set equality with one item"
        .text
        push %eax
        movl $_set_union_all_6, %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_union_all_7:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long 2 + 256<<2
        .text
        push %eax
        movl $_set_union_all_7, %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_union_all_9:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long 2 + 256<<2
        .text
        push %eax
        movl $_set_union_all_9, %eax
        # get procedure
        push %eax
        movl (_set_equal_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_assert_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_union_all_10:
        .long 0xbabb1e
        .long 28
        .ascii "set inequality with one item"
        .text
        push %eax
        movl $_set_union_all_10, %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_union_all_11:
        .long 0x2ce11ed
        .long _set_union_all_12
        .long 2 + 256<<2
        .text
        push %eax
        movl $_set_union_all_11, %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_union_all_13:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long 2 + 256<<2
        .text
        push %eax
        movl $_set_union_all_13, %eax
        # get procedure
        push %eax
        movl (_set_equal_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_not_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_assert_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_union_all_14:
        .long 0xbabb1e
        .long 21
        .ascii "set inequality () (a)"
        .text
        push %eax
        movl $_set_union_all_14, %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_union_all_15:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long 2 + 256<<2
        .text
        push %eax
        movl $_set_union_all_15, %eax
        push %eax
        movl $2 + 256<<2, %eax
        # get procedure
        push %eax
        movl (_set_equal_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_not_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_assert_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_union_all_16:
        .long 0xbabb1e
        .long 21
        .ascii "set inequality (a) ()"
        .text
        push %eax
        movl $_set_union_all_16, %eax
        push %eax
        movl $2 + 256<<2, %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_union_all_17:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long 2 + 256<<2
        .text
        push %eax
        movl $_set_union_all_17, %eax
        # get procedure
        push %eax
        movl (_set_equal_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_not_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_assert_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_union_all_18:
        .long 0xbabb1e
        .long 22
        .ascii "set equality (a a) (a)"
        .text
        push %eax
        movl $_set_union_all_18, %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_union_all_19:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long 2 + 256<<2
        .text
        push %eax
        movl $_set_union_all_19, %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_union_all_21:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_union_all_20:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long _set_union_all_21
        .text
        push %eax
        movl $_set_union_all_20, %eax
        # get procedure
        push %eax
        movl (_set_equal_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_assert_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_union_all_22:
        .long 0xbabb1e
        .long 28
        .ascii "set equality sequence varies"
        .text
        push %eax
        movl $_set_union_all_22, %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_union_all_24:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_union_all_23:
        .long 0x2ce11ed
        .long _set_union_all_12
        .long _set_union_all_24
        .text
        push %eax
        movl $_set_union_all_23, %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_union_all_26:
        .long 0x2ce11ed
        .long _set_union_all_12
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_union_all_25:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long _set_union_all_26
        .text
        push %eax
        movl $_set_union_all_25, %eax
        # get procedure
        push %eax
        movl (_set_equal_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_assert_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_union_all_27:
        .long 0xbabb1e
        .long 16
        .ascii "add to empty set"
        .text
        push %eax
        movl $_set_union_all_27, %eax
        push %eax
        movl $1 + 1<<2, %eax
        push %eax
        movl $2 + 256<<2, %eax
        push %eax
        movl $_set_union_all_8, %eax
        # get procedure
        push %eax
        movl (_add_if_not_present_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_length_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_Eq_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_assert_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_union_all_28:
        .long 0xbabb1e
        .long 13
        .ascii "redundant add"
        .text
        push %eax
        movl $_set_union_all_28, %eax
        push %eax
        movl $1 + 1<<2, %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_union_all_29:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long 2 + 256<<2
        .text
        push %eax
        movl $_set_union_all_29, %eax
        push %eax
        movl $_set_union_all_8, %eax
        # get procedure
        push %eax
        movl (_add_if_not_present_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_length_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_Eq_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_assert_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_union_all_30:
        .long 0xbabb1e
        .long 16
        .ascii "nonredundant add"
        .text
        push %eax
        movl $_set_union_all_30, %eax
        push %eax
        movl $1 + 2<<2, %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_union_all_31:
        .long 0x2ce11ed
        .long _set_union_all_12
        .long 2 + 256<<2
        .text
        push %eax
        movl $_set_union_all_31, %eax
        push %eax
        movl $_set_union_all_8, %eax
        # get procedure
        push %eax
        movl (_add_if_not_present_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_length_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_Eq_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_assert_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .data
_sample_abcd_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_abcd_5:
        .long 0x2ce11ed
        .long _sample_abcd_6
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_abcd_3:
        .long 0x2ce11ed
        .long _sample_abcd_4
        .long _sample_abcd_5
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_abcd_2:
        .long 0x2ce11ed
        .long _set_union_all_12
        .long _sample_abcd_3
        .text
        push %eax
        movl $_sample_abcd_2, %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_abcd_9:
        .long 0x2ce11ed
        .long _sample_abcd_4
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_abcd_8:
        .long 0x2ce11ed
        .long _set_union_all_12
        .long _sample_abcd_9
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_abcd_7:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long _sample_abcd_8
        .text
        push %eax
        movl $_sample_abcd_7, %eax
        # get procedure
        push %eax
        movl (_set_union_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # initialize global variable with value
        movl %eax, (_sample_abcd_1)
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_abcd_10:
        .long 0xbabb1e
        .long 9
        .ascii "set union"
        .text
        push %eax
        movl $_sample_abcd_10, %eax
        push %eax
        movl $1 + 4<<2, %eax
        push %eax
        movl (_sample_abcd_1), %eax
        # get procedure
        push %eax
        movl (_length_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_Eq_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_assert_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_abcd_11:
        .long 0xbabb1e
        .long 17
        .ascii "member from set 1"
        .text
        push %eax
        movl $_sample_abcd_11, %eax
        push %eax
        movl (_sample_abcd_1), %eax
        push %eax
        movl $_set_union_all_8, %eax
        # get procedure
        push %eax
        movl (_memq_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_assert_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_abcd_12:
        .long 0xbabb1e
        .long 17
        .ascii "member from set 2"
        .text
        push %eax
        movl $_sample_abcd_12, %eax
        push %eax
        movl (_sample_abcd_1), %eax
        push %eax
        movl $_sample_abcd_6, %eax
        # get procedure
        push %eax
        movl (_memq_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_assert_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_abcd_13:
        .long 0xbabb1e
        .long 14
        .ascii "nil not in set"
        .text
        push %eax
        movl $_sample_abcd_13, %eax
        push %eax
        movl (_sample_abcd_1), %eax
        push %eax
        movl $2 + 256<<2, %eax
        # get procedure
        push %eax
        movl (_memq_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_not_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_assert_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .data
_assert_set_equal_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _assert_set_equal_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_assert_set_equal_3:
        .long 0xca11ab1e
        .long _assert_set_equal_4
        .long 0
        .text
        .type _assert_set_equal_4, @function
_assert_set_equal_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $2, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 4(%ebp), %eax
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl $_assert_set_equal_5, %eax
        # get procedure
        push %eax
        movl (_list_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        call *%ebx
        push %eax
        movl 4(%ebp), %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_set_equal_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_assert_1), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _assert_set_equal_4, .-_assert_set_equal_4
_assert_set_equal_2:
        push %eax
        movl $_assert_set_equal_3, %eax
        # initialize global variable with value
        movl %eax, (_assert_set_equal_1)
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_assert_set_equal_7:
        .long 0x2ce11ed
        .long _sample_abcd_4
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_assert_set_equal_6:
        .long 0x2ce11ed
        .long _set_union_all_12
        .long _assert_set_equal_7
        .text
        push %eax
        movl $_assert_set_equal_6, %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_assert_set_equal_10:
        .long 0x2ce11ed
        .long _sample_abcd_6
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_assert_set_equal_9:
        .long 0x2ce11ed
        .long _sample_abcd_4
        .long _assert_set_equal_10
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_assert_set_equal_8:
        .long 0x2ce11ed
        .long _set_union_all_12
        .long _assert_set_equal_9
        .text
        push %eax
        movl $_assert_set_equal_8, %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_assert_set_equal_13:
        .long 0x2ce11ed
        .long _sample_abcd_4
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_assert_set_equal_12:
        .long 0x2ce11ed
        .long _set_union_all_12
        .long _assert_set_equal_13
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_assert_set_equal_11:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long _assert_set_equal_12
        .text
        push %eax
        movl $_assert_set_equal_11, %eax
        # get procedure
        push %eax
        movl (_set_intersect_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_assert_set_equal_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .data
_captured_vars_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _captured_vars_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_captured_vars_3:
        .long 0xca11ab1e
        .long _captured_vars_4
        .long 0
        .text
        .type _captured_vars_4, @function
_captured_vars_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_captured_vars_5), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl (_captured_vars_6), %eax
        # get procedure
        push %eax
        movl (_map_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_set_union_all_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _captured_vars_4, .-_captured_vars_4
_captured_vars_2:
        push %eax
        movl $_captured_vars_3, %eax
        # initialize global variable with value
        movl %eax, (_captured_vars_1)
        pop %eax
        .section .data
_captured_vars_5:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _lambdas_1
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_lambdas_2:
        .long 0xca11ab1e
        .long _lambdas_3
        .long 0
        .text
        .type _lambdas_3, @function
_lambdas_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_pairP_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _lambdas_4
        push %eax
        movl $2 + 256<<2, %eax
        jmp _lambdas_5
_lambdas_4:
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        push %eax
        movl $_lambdas_8, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _lambdas_6
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_list_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        jmp _lambdas_7
_lambdas_6:
        push %eax
        movl $2 + 256<<2, %eax
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl (_captured_vars_5), %eax
        # get procedure
        push %eax
        movl (_map_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        push %eax
        movl (_append_1), %eax
        # get procedure
        push %eax
        movl (_reduce_1), %eax
        # apply procedure
        # Tail call; nargs = 3
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 8(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push -8(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        jmp *%ebx
_lambdas_7:
_lambdas_5:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _lambdas_3, .-_lambdas_3
_lambdas_1:
        push %eax
        movl $_lambdas_2, %eax
        # initialize global variable with value
        movl %eax, (_captured_vars_5)
        pop %eax
        .section .data
_all_captured_vars_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _all_captured_vars_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_all_captured_vars_3:
        .long 0xca11ab1e
        .long _all_captured_vars_4
        .long 0
        .text
        .type _all_captured_vars_4, @function
_all_captured_vars_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl (_captured_vars_1), %eax
        # get procedure
        push %eax
        movl (_map_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_set_union_all_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _all_captured_vars_4, .-_all_captured_vars_4
_all_captured_vars_2:
        push %eax
        movl $_all_captured_vars_3, %eax
        # initialize global variable with value
        movl %eax, (_all_captured_vars_1)
        pop %eax
        .section .data
_vars_bound_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _vars_bound_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_vars_bound_3:
        .long 0xca11ab1e
        .long _vars_bound_4
        .long 0
        .text
        .type _vars_bound_4, @function
_vars_bound_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_symbolP_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _vars_bound_5
        push %eax
        movl 0(%ebp), %eax
        jmp _vars_bound_6
_vars_bound_5:
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_list_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
_vars_bound_6:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _vars_bound_4, .-_vars_bound_4
_vars_bound_2:
        push %eax
        movl $_vars_bound_3, %eax
        # initialize global variable with value
        movl %eax, (_vars_bound_1)
        pop %eax
        .section .data
_free_vars_lambda_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _free_vars_lambda_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_free_vars_lambda_3:
        .long 0xca11ab1e
        .long _free_vars_lambda_4
        .long 0
        .text
        .type _free_vars_lambda_4, @function
_free_vars_lambda_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $2, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_vars_bound_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl 4(%ebp), %eax
        # get procedure
        push %eax
        movl (_free_vars_lambda_5), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_set_subtract_1), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _free_vars_lambda_4, .-_free_vars_lambda_4
_free_vars_lambda_2:
        push %eax
        movl $_free_vars_lambda_3, %eax
        # initialize global variable with value
        movl %eax, (_free_vars_lambda_1)
        pop %eax
        .section .data
_captured_vars_6:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _free_vars_1
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_free_vars_2:
        .long 0xca11ab1e
        .long _free_vars_3
        .long 0
        .text
        .type _free_vars_3, @function
_free_vars_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # move arg from stack to heap: expr
        push %eax
        movl 0(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # %ifeq
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_symbolP_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _free_vars_4
        # %ifeq
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_pairP_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _free_vars_6
        push %eax
        movl $2 + 256<<2, %eax
        jmp _free_vars_7
_free_vars_6:
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        # get procedure
        # jump past the body of the lambda
        jmp _free_vars_8
        .text
        .type _free_vars_9, @function
_free_vars_9:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 expr
        push 12(%eax)
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl $_lambdas_8, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _free_vars_10
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_cddr_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_cadr_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_free_vars_lambda_1), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        jmp _free_vars_11
_free_vars_10:
        # %ifeq
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_free_vars_16:
        .long 0x2ce11ed
        .long _free_vars_17
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_free_vars_14:
        .long 0x2ce11ed
        .long _free_vars_15
        .long _free_vars_16
        .text
        push %eax
        movl $_free_vars_14, %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_memv_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _free_vars_12
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl $_free_vars_20, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _free_vars_18
        push %eax
        movl $2 + 256<<2, %eax
        jmp _free_vars_19
_free_vars_18:
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl $_free_vars_23, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _free_vars_21
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_caddr_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_captured_vars_6), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_cadr_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_add_if_not_present_1), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        jmp _free_vars_22
_free_vars_21:
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_free_vars_lambda_5), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
_free_vars_22:
_free_vars_19:
        jmp _free_vars_13
_free_vars_12:
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # inlined cdr
        call ensure_cons
        movl 8(%eax), %eax
        # get procedure
        push %eax
        movl (_free_vars_lambda_5), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
_free_vars_13:
_free_vars_11:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _free_vars_9, .-_free_vars_9
_free_vars_8:
        # allocate bytes: 16
        push %eax
        movl (arena_pointer), %eax
        add $16, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_free_vars_9, 4(%ebx)
        movl $1, 8(%ebx)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
_free_vars_7:
        jmp _free_vars_5
_free_vars_4:
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_list_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
_free_vars_5:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _free_vars_3, .-_free_vars_3
_free_vars_1:
        push %eax
        movl $_free_vars_2, %eax
        # initialize global variable with value
        movl %eax, (_captured_vars_6)
        pop %eax
        .section .data
_free_vars_lambda_5:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _all_free_vars_1
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_all_free_vars_2:
        .long 0xca11ab1e
        .long _all_free_vars_3
        .long 0
        .text
        .type _all_free_vars_3, @function
_all_free_vars_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl (_captured_vars_6), %eax
        # get procedure
        push %eax
        movl (_map_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_set_union_all_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _all_free_vars_3, .-_all_free_vars_3
_all_free_vars_1:
        push %eax
        movl $_all_free_vars_2, %eax
        # initialize global variable with value
        movl %eax, (_free_vars_lambda_5)
        pop %eax
        .section .data
_artifacts_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _artifacts_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_artifacts_3:
        .long 0xca11ab1e
        .long _artifacts_4
        .long 0
        .text
        .type _artifacts_4, @function
_artifacts_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $3, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # move arg from stack to heap: env
        push %eax
        movl 8(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        push %eax
        movl 4(%ebp), %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_free_vars_lambda_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # jump past the body of the lambda
        jmp _artifacts_5
        .text
        .type _artifacts_6, @function
_artifacts_6:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 env
        push 12(%eax)
        # discarding useless value in %eax
        pop %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_assq_1), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _artifacts_6, .-_artifacts_6
_artifacts_5:
        # allocate bytes: 16
        push %eax
        movl (arena_pointer), %eax
        add $16, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_artifacts_6, 4(%ebx)
        movl $1, 8(%ebx)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # get procedure
        push %eax
        movl (_filter_1), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _artifacts_4, .-_artifacts_4
_artifacts_2:
        push %eax
        movl $_artifacts_3, %eax
        # initialize global variable with value
        movl %eax, (_artifacts_1)
        pop %eax
        .section .data
_compile_heap_args_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _compile_heap_args_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_heap_args_3:
        .long 0xca11ab1e
        .long _compile_heap_args_4
        .long 0
        .text
        .type _compile_heap_args_4, @function
_compile_heap_args_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $3, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_heap_args_5:
        .long 0xbabb1e
        .long 32
        .ascii "discarding useless value in %eax"
        .text
        push %eax
        movl $_compile_heap_args_5, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_pop_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        pop %eax
        push %eax
        movl 8(%ebp), %eax
        push %eax
        movl 4(%ebp), %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_compile_heap_args_6), %eax
        # apply procedure
        # Tail call; nargs = 3
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 8(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push -8(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _compile_heap_args_4, .-_compile_heap_args_4
_compile_heap_args_2:
        push %eax
        movl $_compile_heap_args_3, %eax
        # initialize global variable with value
        movl %eax, (_compile_heap_args_1)
        pop %eax
        .section .data
_compile_heap_args_6:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _compile_heap_args_2_1
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_heap_args_2_2:
        .long 0xca11ab1e
        .long _compile_heap_args_2_3
        .long 0
        .text
        .type _compile_heap_args_2_3, @function
_compile_heap_args_2_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $3, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # move arg from stack to heap: heap-args
        push %eax
        movl 0(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # move arg from stack to heap: heap-slots-used
        push %eax
        movl 4(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # move arg from stack to heap: env
        push %eax
        movl 8(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # %ifeq
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        push %eax
        movl $2 + 256<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _compile_heap_args_2_4
        # fetching heap var pointer 2
        push %eax
        movl -24(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        jmp _compile_heap_args_2_5
_compile_heap_args_2_4:
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        # get procedure
        # jump past the body of the lambda
        jmp _compile_heap_args_2_6
        .text
        .type _compile_heap_args_2_7, @function
_compile_heap_args_2_7:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 heap-args
        push 12(%eax)
        # fetch artifact from closure: 1 heap-slots-used
        push 16(%eax)
        # fetch artifact from closure: 2 env
        push 20(%eax)
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        call ensure_symbol
        movl 4(%eax), %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_heap_args_2_8:
        .long 0xbabb1e
        .long 29
        .ascii "move arg from stack to heap: "
        .text
        push %eax
        movl $_compile_heap_args_2_8, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        # fetching heap var pointer 2
        push %eax
        movl -24(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_compile_heap_args_2_9), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_compile_heap_args_2_10), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        pop %eax
        # fetching heap var pointer 2
        push %eax
        movl -24(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        push %eax
        movl $_compile_heap_args_2_11, %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_list_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_cons_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # 1+
        call ensure_integer
        add $1<<2, %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # inlined cdr
        call ensure_cons
        movl 8(%eax), %eax
        # get procedure
        push %eax
        movl (_compile_heap_args_6), %eax
        # apply procedure
        # Tail call; nargs = 3
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 8(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push -8(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _compile_heap_args_2_7, .-_compile_heap_args_2_7
_compile_heap_args_2_6:
        # allocate bytes: 24
        push %eax
        movl (arena_pointer), %eax
        add $24, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_compile_heap_args_2_7, 4(%ebx)
        movl $3, 8(%ebx)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        movl %eax, 16(%ebx)
        pop %eax
        # fetching heap var pointer 2
        push %eax
        movl -24(%ebp), %eax
        movl %eax, 20(%ebx)
        pop %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
_compile_heap_args_2_5:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _compile_heap_args_2_3, .-_compile_heap_args_2_3
_compile_heap_args_2_1:
        push %eax
        movl $_compile_heap_args_2_2, %eax
        # initialize global variable with value
        movl %eax, (_compile_heap_args_6)
        pop %eax
        .section .data
_push_artifacts_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _push_artifacts_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_push_artifacts_3:
        .long 0xca11ab1e
        .long _push_artifacts_4
        .long 0
        .text
        .type _push_artifacts_4, @function
_push_artifacts_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl $1 + 0<<2, %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_push_artifacts_5), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _push_artifacts_4, .-_push_artifacts_4
_push_artifacts_2:
        push %eax
        movl $_push_artifacts_3, %eax
        # initialize global variable with value
        movl %eax, (_push_artifacts_1)
        pop %eax
        .section .data
_push_artifacts_5:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _push_artifacts_2_1
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_push_artifacts_2_2:
        .long 0xca11ab1e
        .long _push_artifacts_2_3
        .long 0
        .text
        .type _push_artifacts_2_3, @function
_push_artifacts_2_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $2, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # move arg from stack to heap: artifacts
        push %eax
        movl 0(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # move arg from stack to heap: slotnum
        push %eax
        movl 4(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # %ifeq
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        push %eax
        movl $2 + 256<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _push_artifacts_2_4
        push %eax
        movl $2 + 256<<2, %eax
        jmp _push_artifacts_2_5
_push_artifacts_2_4:
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        # get procedure
        # jump past the body of the lambda
        jmp _push_artifacts_2_6
        .text
        .type _push_artifacts_2_7, @function
_push_artifacts_2_7:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 artifacts
        push 12(%eax)
        # fetch artifact from closure: 1 slotnum
        push 16(%eax)
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        call ensure_symbol
        movl 4(%eax), %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_push_artifacts_2_8:
        .long 0xbabb1e
        .long 1
        .ascii " "
        .text
        push %eax
        movl $_push_artifacts_2_8, %eax
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_number_Gtstring_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_push_artifacts_2_9:
        .long 0xbabb1e
        .long 29
        .ascii "fetch artifact from closure: "
        .text
        push %eax
        movl $_push_artifacts_2_9, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $4, %edx
        call *%ebx
        pop %eax
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_quadruple_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $1 + 12<<2, %eax
        # inlined integer add
        call ensure_integer
        xchg %eax, (%esp)
        call ensure_integer
        pop %ebx
        add %ebx, %eax
        dec %eax
        push %eax
        movl (_eax_1), %eax
        # get procedure
        push %eax
        movl (_offset_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_asm_push_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # 1+
        call ensure_integer
        add $1<<2, %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # inlined cdr
        call ensure_cons
        movl 8(%eax), %eax
        # get procedure
        push %eax
        movl (_push_artifacts_5), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        push %eax
        movl $_compile_heap_args_2_11, %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_list_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_cons_2), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _push_artifacts_2_7, .-_push_artifacts_2_7
_push_artifacts_2_6:
        # allocate bytes: 20
        push %eax
        movl (arena_pointer), %eax
        add $20, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_push_artifacts_2_7, 4(%ebx)
        movl $2, 8(%ebx)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        movl %eax, 16(%ebx)
        pop %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
_push_artifacts_2_5:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _push_artifacts_2_3, .-_push_artifacts_2_3
_push_artifacts_2_1:
        push %eax
        movl $_push_artifacts_2_2, %eax
        # initialize global variable with value
        movl %eax, (_push_artifacts_5)
        pop %eax
        .section .data
_push_closure_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _push_closure_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_push_closure_3:
        .long 0xca11ab1e
        .long _push_closure_4
        .long 0
        .text
        .type _push_closure_4, @function
_push_closure_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $3, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 4(%ebp), %eax
        # get procedure
        push %eax
        movl (_length_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_quadruple_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $1 + 12<<2, %eax
        # inlined integer add
        call ensure_integer
        xchg %eax, (%esp)
        call ensure_integer
        pop %ebx
        add %ebx, %eax
        dec %eax
        # get procedure
        push %eax
        movl (_push_closure_5), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_ebx_1), %eax
        push %eax
        movl (_tos_1), %eax
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_ebx_1), %eax
        # get procedure
        push %eax
        movl (_indirect_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl (_procedure_magic_1), %eax
        # get procedure
        push %eax
        movl (_const_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl $1 + 4<<2, %eax
        push %eax
        movl (_ebx_1), %eax
        # get procedure
        push %eax
        movl (_offset_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_const_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl $1 + 8<<2, %eax
        push %eax
        movl (_ebx_1), %eax
        # get procedure
        push %eax
        movl (_offset_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        push %eax
        movl 4(%ebp), %eax
        # get procedure
        push %eax
        movl (_length_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_number_Gtstring_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_const_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl 8(%ebp), %eax
        push %eax
        movl 4(%ebp), %eax
        push %eax
        movl $1 + 12<<2, %eax
        push %eax
        movl (_ebx_1), %eax
        # get procedure
        push %eax
        movl (_push_closure_6), %eax
        # apply procedure
        # Tail call; nargs = 4
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 12(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push -8(%ebx)
        push -12(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $4, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _push_closure_4, .-_push_closure_4
_push_closure_2:
        push %eax
        movl $_push_closure_3, %eax
        # initialize global variable with value
        movl %eax, (_push_closure_1)
        pop %eax
        .section .data
_push_closure_6:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _store_closure_artifacts_1
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_store_closure_artifacts_2:
        .long 0xca11ab1e
        .long _store_closure_artifacts_3
        .long 0
        .text
        .type _store_closure_artifacts_3, @function
_store_closure_artifacts_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $4, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 8(%ebp), %eax
        push %eax
        movl $2 + 256<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _store_closure_artifacts_4
        push %eax
        movl $2 + 258<<2, %eax
        jmp _store_closure_artifacts_5
_store_closure_artifacts_4:
        push %eax
        movl 12(%ebp), %eax
        push %eax
        movl 8(%ebp), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_assq_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_store_closure_artifacts_6), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl 4(%ebp), %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_offset_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        push %eax
        movl (_tos_1), %eax
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_pop_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        pop %eax
        push %eax
        movl 12(%ebp), %eax
        push %eax
        movl 8(%ebp), %eax
        # inlined cdr
        call ensure_cons
        movl 8(%eax), %eax
        push %eax
        movl $1 + 4<<2, %eax
        push %eax
        movl 4(%ebp), %eax
        # inlined integer add
        call ensure_integer
        xchg %eax, (%esp)
        call ensure_integer
        pop %ebx
        add %ebx, %eax
        dec %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_push_closure_6), %eax
        # apply procedure
        # Tail call; nargs = 4
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 12(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push -8(%ebx)
        push -12(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $4, %edx
        jmp *%ebx
_store_closure_artifacts_5:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _store_closure_artifacts_3, .-_store_closure_artifacts_3
_store_closure_artifacts_1:
        push %eax
        movl $_store_closure_artifacts_2, %eax
        # initialize global variable with value
        movl %eax, (_push_closure_6)
        pop %eax
        .section .data
_heap_var_magic_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_heap_var_magic_2:
        .long 0xbabb1e
        .long 9
        .ascii "0x1ce11ed"
        .text
        push %eax
        movl $_heap_var_magic_2, %eax
        # initialize global variable with value
        movl %eax, (_heap_var_magic_1)
        pop %eax
        .section .data
_compile_heap_args_2_10:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _move_var_to_heap_arg_1
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_move_var_to_heap_arg_2:
        .long 0xca11ab1e
        .long _move_var_to_heap_arg_3
        .long 0
        .text
        .type _move_var_to_heap_arg_3, @function
_move_var_to_heap_arg_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $0, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_move_var_to_heap_arg_4:
        .long 0xbabb1e
        .long 47
        .ascii "moving top of stack to newly allocated heap var"
        .text
        push %eax
        movl $_move_var_to_heap_arg_4, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl $1 + 8<<2, %eax
        # get procedure
        push %eax
        movl (_push_closure_5), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_tos_1), %eax
        # get procedure
        push %eax
        movl (_indirect_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl (_heap_var_magic_1), %eax
        # get procedure
        push %eax
        movl (_const_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl $1 + 4<<2, %eax
        push %eax
        movl (_tos_1), %eax
        # get procedure
        push %eax
        movl (_offset_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_asm_pop_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _move_var_to_heap_arg_3, .-_move_var_to_heap_arg_3
_move_var_to_heap_arg_1:
        push %eax
        movl $_move_var_to_heap_arg_2, %eax
        # initialize global variable with value
        movl %eax, (_compile_heap_args_2_10)
        pop %eax
        .section .data
_sample_closure_expression_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_closure_expression_5:
        .long 0x2ce11ed
        .long _set_union_all_12
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_closure_expression_4:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long _sample_closure_expression_5
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_closure_expression_10:
        .long 0x2ce11ed
        .long _sample_abcd_6
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_closure_expression_9:
        .long 0x2ce11ed
        .long _sample_abcd_4
        .long _sample_closure_expression_10
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_closure_expression_16:
        .long 0x2ce11ed
        .long _sample_closure_expression_17
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_closure_expression_14:
        .long 0x2ce11ed
        .long _sample_closure_expression_15
        .long _sample_closure_expression_16
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_closure_expression_24:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_closure_expression_23:
        .long 0x2ce11ed
        .long _sample_abcd_4
        .long _sample_closure_expression_24
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_closure_expression_22:
        .long 0x2ce11ed
        .long _sample_closure_expression_17
        .long _sample_closure_expression_23
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_closure_expression_21:
        .long 0x2ce11ed
        .long _sample_closure_expression_15
        .long _sample_closure_expression_22
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_closure_expression_19:
        .long 0x2ce11ed
        .long _sample_closure_expression_20
        .long _sample_closure_expression_21
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_closure_expression_18:
        .long 0x2ce11ed
        .long _sample_closure_expression_19
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_closure_expression_13:
        .long 0x2ce11ed
        .long _sample_closure_expression_14
        .long _sample_closure_expression_18
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_closure_expression_12:
        .long 0x2ce11ed
        .long _lambdas_8
        .long _sample_closure_expression_13
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_closure_expression_11:
        .long 0x2ce11ed
        .long _sample_closure_expression_12
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_closure_expression_8:
        .long 0x2ce11ed
        .long _sample_closure_expression_9
        .long _sample_closure_expression_11
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_closure_expression_7:
        .long 0x2ce11ed
        .long _lambdas_8
        .long _sample_closure_expression_8
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_closure_expression_6:
        .long 0x2ce11ed
        .long _sample_closure_expression_7
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_closure_expression_3:
        .long 0x2ce11ed
        .long _sample_closure_expression_4
        .long _sample_closure_expression_6
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_closure_expression_2:
        .long 0x2ce11ed
        .long _lambdas_8
        .long _sample_closure_expression_3
        .text
        push %eax
        movl $_sample_closure_expression_2, %eax
        # initialize global variable with value
        movl %eax, (_sample_closure_expression_1)
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_closure_expression_25:
        .long 0x2ce11ed
        .long _sample_closure_expression_20
        .long 2 + 256<<2
        .text
        push %eax
        movl $_sample_closure_expression_25, %eax
        push %eax
        movl (_sample_closure_expression_1), %eax
        # get procedure
        push %eax
        movl (_captured_vars_6), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_assert_set_equal_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_closure_expression_26:
        .long 0x2ce11ed
        .long _sample_closure_expression_20
        .long 2 + 256<<2
        .text
        push %eax
        movl $_sample_closure_expression_26, %eax
        push %eax
        movl (_sample_closure_expression_1), %eax
        # get procedure
        push %eax
        movl (_captured_vars_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_assert_set_equal_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .data
_sample_inner_lambda_1_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        push %eax
        movl (_sample_closure_expression_1), %eax
        # get procedure
        push %eax
        movl (_caddr_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # initialize global variable with value
        movl %eax, (_sample_inner_lambda_1_1)
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_inner_lambda_1_3:
        .long 0x2ce11ed
        .long _sample_closure_expression_20
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_inner_lambda_1_2:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long _sample_inner_lambda_1_3
        .text
        push %eax
        movl $_sample_inner_lambda_1_2, %eax
        push %eax
        movl (_sample_inner_lambda_1_1), %eax
        # get procedure
        push %eax
        movl (_captured_vars_6), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_assert_set_equal_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_inner_lambda_1_5:
        .long 0x2ce11ed
        .long _sample_closure_expression_20
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_inner_lambda_1_4:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long _sample_inner_lambda_1_5
        .text
        push %eax
        movl $_sample_inner_lambda_1_4, %eax
        push %eax
        movl (_sample_inner_lambda_1_1), %eax
        # get procedure
        push %eax
        movl (_captured_vars_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_assert_set_equal_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .data
_sample_inner_lambda_2_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        push %eax
        movl (_sample_inner_lambda_1_1), %eax
        # get procedure
        push %eax
        movl (_caddr_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # initialize global variable with value
        movl %eax, (_sample_inner_lambda_2_1)
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_inner_lambda_2_4:
        .long 0x2ce11ed
        .long _sample_closure_expression_20
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_inner_lambda_2_3:
        .long 0x2ce11ed
        .long _sample_abcd_4
        .long _sample_inner_lambda_2_4
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_inner_lambda_2_2:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long _sample_inner_lambda_2_3
        .text
        push %eax
        movl $_sample_inner_lambda_2_2, %eax
        push %eax
        movl (_sample_inner_lambda_2_1), %eax
        # get procedure
        push %eax
        movl (_captured_vars_6), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_assert_set_equal_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_inner_lambda_2_7:
        .long 0x2ce11ed
        .long _sample_closure_expression_20
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_inner_lambda_2_6:
        .long 0x2ce11ed
        .long _sample_abcd_4
        .long _sample_inner_lambda_2_7
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_inner_lambda_2_5:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long _sample_inner_lambda_2_6
        .text
        push %eax
        movl $_sample_inner_lambda_2_5, %eax
        push %eax
        movl (_sample_inner_lambda_2_1), %eax
        # get procedure
        push %eax
        movl (_captured_vars_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_assert_set_equal_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_inner_lambda_2_9:
        .long 0x2ce11ed
        .long _sample_abcd_4
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_inner_lambda_2_8:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long _sample_inner_lambda_2_9
        .text
        push %eax
        movl $_sample_inner_lambda_2_8, %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_inner_lambda_2_12:
        .long 0x2ce11ed
        .long _sample_inner_lambda_2_13
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_inner_lambda_2_11:
        .long 0x2ce11ed
        .long _sample_abcd_4
        .long _sample_inner_lambda_2_12
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_inner_lambda_2_16:
        .long 0x2ce11ed
        .long _sample_inner_lambda_2_13
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_inner_lambda_2_15:
        .long 0x2ce11ed
        .long _sample_abcd_6
        .long _sample_inner_lambda_2_16
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_inner_lambda_2_19:
        .long 0x2ce11ed
        .long _sample_inner_lambda_2_13
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_inner_lambda_2_18:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long _sample_inner_lambda_2_19
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_inner_lambda_2_22:
        .long 0x2ce11ed
        .long _sample_inner_lambda_2_13
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_inner_lambda_2_21:
        .long 0x2ce11ed
        .long _set_union_all_12
        .long _sample_inner_lambda_2_22
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_inner_lambda_2_20:
        .long 0x2ce11ed
        .long _sample_inner_lambda_2_21
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_inner_lambda_2_17:
        .long 0x2ce11ed
        .long _sample_inner_lambda_2_18
        .long _sample_inner_lambda_2_20
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_inner_lambda_2_14:
        .long 0x2ce11ed
        .long _sample_inner_lambda_2_15
        .long _sample_inner_lambda_2_17
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_inner_lambda_2_10:
        .long 0x2ce11ed
        .long _sample_inner_lambda_2_11
        .long _sample_inner_lambda_2_14
        .text
        push %eax
        movl $_sample_inner_lambda_2_10, %eax
        push %eax
        movl (_sample_inner_lambda_2_1), %eax
        # get procedure
        push %eax
        movl (_caddr_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_inner_lambda_2_24:
        .long 0x2ce11ed
        .long _sample_closure_expression_17
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_inner_lambda_2_23:
        .long 0x2ce11ed
        .long _sample_closure_expression_15
        .long _sample_inner_lambda_2_24
        .text
        push %eax
        movl $_sample_inner_lambda_2_23, %eax
        # get procedure
        push %eax
        movl (_artifacts_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_assert_set_equal_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .data
_sample_quoted_expr_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_quoted_expr_10:
        .long 0x2ce11ed
        .long _sample_abcd_4
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_quoted_expr_9:
        .long 0x2ce11ed
        .long _set_union_all_12
        .long _sample_quoted_expr_10
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_quoted_expr_8:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long _sample_quoted_expr_9
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_quoted_expr_7:
        .long 0x2ce11ed
        .long _sample_quoted_expr_8
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_quoted_expr_6:
        .long 0x2ce11ed
        .long _free_vars_20
        .long _sample_quoted_expr_7
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_quoted_expr_5:
        .long 0x2ce11ed
        .long _sample_quoted_expr_6
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_quoted_expr_3:
        .long 0x2ce11ed
        .long _sample_quoted_expr_4
        .long _sample_quoted_expr_5
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_quoted_expr_2:
        .long 0x2ce11ed
        .long _sample_closure_expression_20
        .long _sample_quoted_expr_3
        .text
        push %eax
        movl $_sample_quoted_expr_2, %eax
        # initialize global variable with value
        movl %eax, (_sample_quoted_expr_1)
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_quoted_expr_12:
        .long 0x2ce11ed
        .long _sample_quoted_expr_4
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_quoted_expr_11:
        .long 0x2ce11ed
        .long _sample_closure_expression_20
        .long _sample_quoted_expr_12
        .text
        push %eax
        movl $_sample_quoted_expr_11, %eax
        push %eax
        movl (_sample_quoted_expr_1), %eax
        # get procedure
        push %eax
        movl (_captured_vars_6), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_assert_set_equal_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl $2 + 256<<2, %eax
        push %eax
        movl (_sample_quoted_expr_1), %eax
        # get procedure
        push %eax
        movl (_captured_vars_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_assert_set_equal_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .data
_sample_if_expr_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_if_expr_6:
        .long 0x2ce11ed
        .long _sample_abcd_6
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_if_expr_5:
        .long 0x2ce11ed
        .long _sample_abcd_4
        .long _sample_if_expr_6
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_if_expr_4:
        .long 0x2ce11ed
        .long _set_union_all_12
        .long _sample_if_expr_5
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_if_expr_3:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long _sample_if_expr_4
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_if_expr_2:
        .long 0x2ce11ed
        .long _free_vars_17
        .long _sample_if_expr_3
        .text
        push %eax
        movl $_sample_if_expr_2, %eax
        # initialize global variable with value
        movl %eax, (_sample_if_expr_1)
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_if_expr_10:
        .long 0x2ce11ed
        .long _sample_abcd_6
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_if_expr_9:
        .long 0x2ce11ed
        .long _sample_abcd_4
        .long _sample_if_expr_10
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_if_expr_8:
        .long 0x2ce11ed
        .long _set_union_all_12
        .long _sample_if_expr_9
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_if_expr_7:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long _sample_if_expr_8
        .text
        push %eax
        movl $_sample_if_expr_7, %eax
        push %eax
        movl (_sample_if_expr_1), %eax
        # get procedure
        push %eax
        movl (_captured_vars_6), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_assert_set_equal_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl $2 + 256<<2, %eax
        push %eax
        movl (_sample_if_expr_1), %eax
        # get procedure
        push %eax
        movl (_captured_vars_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_assert_set_equal_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .data
_sample_begin_expr_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_begin_expr_5:
        .long 0x2ce11ed
        .long _sample_abcd_4
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_begin_expr_4:
        .long 0x2ce11ed
        .long _set_union_all_12
        .long _sample_begin_expr_5
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_begin_expr_3:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long _sample_begin_expr_4
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_begin_expr_2:
        .long 0x2ce11ed
        .long _free_vars_15
        .long _sample_begin_expr_3
        .text
        push %eax
        movl $_sample_begin_expr_2, %eax
        # initialize global variable with value
        movl %eax, (_sample_begin_expr_1)
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_begin_expr_8:
        .long 0x2ce11ed
        .long _sample_abcd_4
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_begin_expr_7:
        .long 0x2ce11ed
        .long _set_union_all_12
        .long _sample_begin_expr_8
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_begin_expr_6:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long _sample_begin_expr_7
        .text
        push %eax
        movl $_sample_begin_expr_6, %eax
        push %eax
        movl (_sample_begin_expr_1), %eax
        # get procedure
        push %eax
        movl (_captured_vars_6), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_assert_set_equal_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl $2 + 256<<2, %eax
        push %eax
        movl (_sample_begin_expr_1), %eax
        # get procedure
        push %eax
        movl (_captured_vars_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_assert_set_equal_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_begin_expr_12:
        .long 0x2ce11ed
        .long _sample_abcd_4
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_begin_expr_11:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long _sample_begin_expr_12
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_begin_expr_9:
        .long 0x2ce11ed
        .long _sample_begin_expr_10
        .long _sample_begin_expr_11
        .text
        push %eax
        movl $_sample_begin_expr_9, %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_begin_expr_22:
        .long 0x2ce11ed
        .long _sample_begin_expr_23
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_begin_expr_26:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_begin_expr_25:
        .long 0x2ce11ed
        .long _sample_begin_expr_10
        .long _sample_begin_expr_26
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_begin_expr_29:
        .long 0x2ce11ed
        .long _sample_abcd_4
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_begin_expr_28:
        .long 0x2ce11ed
        .long _sample_begin_expr_23
        .long _sample_begin_expr_29
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_begin_expr_27:
        .long 0x2ce11ed
        .long _sample_begin_expr_28
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_begin_expr_24:
        .long 0x2ce11ed
        .long _sample_begin_expr_25
        .long _sample_begin_expr_27
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_begin_expr_21:
        .long 0x2ce11ed
        .long _sample_begin_expr_22
        .long _sample_begin_expr_24
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_begin_expr_20:
        .long 0x2ce11ed
        .long _lambdas_8
        .long _sample_begin_expr_21
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_begin_expr_30:
        .long 0x2ce11ed
        .long _sample_abcd_6
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_begin_expr_19:
        .long 0x2ce11ed
        .long _sample_begin_expr_20
        .long _sample_begin_expr_30
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_begin_expr_18:
        .long 0x2ce11ed
        .long 2 + 258<<2
        .long _sample_begin_expr_19
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_begin_expr_16:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long _sample_begin_expr_18
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_begin_expr_15:
        .long 0x2ce11ed
        .long _free_vars_17
        .long _sample_begin_expr_16
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_begin_expr_31:
        .long 0x2ce11ed
        .long _sample_closure_expression_15
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_begin_expr_14:
        .long 0x2ce11ed
        .long _sample_begin_expr_15
        .long _sample_begin_expr_31
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_begin_expr_13:
        .long 0x2ce11ed
        .long _free_vars_15
        .long _sample_begin_expr_14
        .text
        push %eax
        movl $_sample_begin_expr_13, %eax
        # get procedure
        push %eax
        movl (_captured_vars_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_assert_set_equal_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_begin_expr_33:
        .long 0x2ce11ed
        .long _sample_begin_expr_10
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_begin_expr_32:
        .long 0x2ce11ed
        .long _sample_begin_expr_23
        .long _sample_begin_expr_33
        .text
        push %eax
        movl $_sample_begin_expr_32, %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_begin_expr_39:
        .long 0x2ce11ed
        .long _sample_begin_expr_10
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_begin_expr_38:
        .long 0x2ce11ed
        .long _sample_begin_expr_23
        .long _sample_begin_expr_39
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_begin_expr_37:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long _sample_begin_expr_38
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_begin_expr_36:
        .long 0x2ce11ed
        .long _sample_begin_expr_37
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_begin_expr_35:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long _sample_begin_expr_36
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_begin_expr_34:
        .long 0x2ce11ed
        .long _lambdas_8
        .long _sample_begin_expr_35
        .text
        push %eax
        movl $_sample_begin_expr_34, %eax
        # get procedure
        push %eax
        movl (_captured_vars_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_assert_set_equal_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .data
_heap_args_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _heap_args_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_heap_args_3:
        .long 0xca11ab1e
        .long _heap_args_4
        .long 0
        .text
        .type _heap_args_4, @function
_heap_args_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $2, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 4(%ebp), %eax
        # get procedure
        push %eax
        movl (_all_captured_vars_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_set_intersect_1), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _heap_args_4, .-_heap_args_4
_heap_args_2:
        push %eax
        movl $_heap_args_3, %eax
        # initialize global variable with value
        movl %eax, (_heap_args_1)
        pop %eax
        push %eax
        movl (_sample_closure_expression_1), %eax
        # get procedure
        push %eax
        movl (_cddr_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl (_sample_closure_expression_1), %eax
        # get procedure
        push %eax
        movl (_cadr_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_heap_args_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_heap_args_5:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long 2 + 256<<2
        .text
        push %eax
        movl $_heap_args_5, %eax
        # get procedure
        push %eax
        movl (_assert_set_equal_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_sample_inner_lambda_1_1), %eax
        # get procedure
        push %eax
        movl (_cddr_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl (_sample_inner_lambda_1_1), %eax
        # get procedure
        push %eax
        movl (_cadr_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_heap_args_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_heap_args_6:
        .long 0x2ce11ed
        .long _sample_abcd_4
        .long 2 + 256<<2
        .text
        push %eax
        movl $_heap_args_6, %eax
        # get procedure
        push %eax
        movl (_assert_set_equal_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_sample_inner_lambda_2_1), %eax
        # get procedure
        push %eax
        movl (_cddr_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl (_sample_inner_lambda_2_1), %eax
        # get procedure
        push %eax
        movl (_cadr_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_heap_args_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        push %eax
        movl $2 + 256<<2, %eax
        # get procedure
        push %eax
        movl (_assert_set_equal_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_heap_args_10:
        .long 0x2ce11ed
        .long _heap_args_11
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_heap_args_15:
        .long 0x2ce11ed
        .long _heap_args_16
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_heap_args_13:
        .long 0x2ce11ed
        .long _heap_args_14
        .long _heap_args_15
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_heap_args_19:
        .long 0x2ce11ed
        .long _heap_args_11
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_heap_args_18:
        .long 0x2ce11ed
        .long _heap_args_14
        .long _heap_args_19
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_heap_args_21:
        .long 0x2ce11ed
        .long _heap_args_22
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_heap_args_20:
        .long 0x2ce11ed
        .long _heap_args_21
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_heap_args_17:
        .long 0x2ce11ed
        .long _heap_args_18
        .long _heap_args_20
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_heap_args_12:
        .long 0x2ce11ed
        .long _heap_args_13
        .long _heap_args_17
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_heap_args_9:
        .long 0x2ce11ed
        .long _heap_args_10
        .long _heap_args_12
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_heap_args_8:
        .long 0x2ce11ed
        .long _lambdas_8
        .long _heap_args_9
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_heap_args_7:
        .long 0x2ce11ed
        .long _heap_args_8
        .long 2 + 256<<2
        .text
        push %eax
        movl $_heap_args_7, %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_heap_args_23:
        .long 0x2ce11ed
        .long _heap_args_16
        .long 2 + 256<<2
        .text
        push %eax
        movl $_heap_args_23, %eax
        # get procedure
        push %eax
        movl (_heap_args_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_heap_args_24:
        .long 0x2ce11ed
        .long _heap_args_16
        .long 2 + 256<<2
        .text
        push %eax
        movl $_heap_args_24, %eax
        # get procedure
        push %eax
        movl (_assert_set_equal_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_heap_args_27:
        .long 0x2ce11ed
        .long _set_union_all_12
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_heap_args_26:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long _heap_args_27
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_heap_args_25:
        .long 0x2ce11ed
        .long _free_vars_23
        .long _heap_args_26
        .text
        push %eax
        movl $_heap_args_25, %eax
        # get procedure
        push %eax
        movl (_captured_vars_6), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_heap_args_29:
        .long 0x2ce11ed
        .long _set_union_all_12
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_heap_args_28:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long _heap_args_29
        .text
        push %eax
        movl $_heap_args_28, %eax
        # get procedure
        push %eax
        movl (_assert_set_equal_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_heap_args_32:
        .long 0x2ce11ed
        .long _set_union_all_12
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_heap_args_31:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long _heap_args_32
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_heap_args_30:
        .long 0x2ce11ed
        .long _free_vars_23
        .long _heap_args_31
        .text
        push %eax
        movl $_heap_args_30, %eax
        # get procedure
        push %eax
        movl (_captured_vars_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $2 + 256<<2, %eax
        # get procedure
        push %eax
        movl (_assert_set_equal_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        # jump past the body of the lambda
        jmp _heap_args_33
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_heap_args_34:
        .long 0xca11ab1e
        .long _heap_args_35
        .long 0
        .text
        .type _heap_args_35, @function
_heap_args_35:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $0, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_heap_args_36:
        .long 0xbabb1e
        .long 4
        .ascii ".bss"
        .text
        push %eax
        movl $_heap_args_36, %eax
        # get procedure
        push %eax
        movl (_insn_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_heap_args_37:
        .long 0xbabb1e
        .long 9
        .ascii "the_arena"
        .text
        push %eax
        movl $_heap_args_37, %eax
        # get procedure
        push %eax
        movl (_label_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_heap_args_38:
        .long 0xbabb1e
        .long 18
        .ascii ".space 128*1048576"
        .text
        push %eax
        movl $_heap_args_38, %eax
        # get procedure
        push %eax
        movl (_insn_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_heap_args_39:
        .long 0xbabb1e
        .long 9
        .ascii "end_arena"
        .text
        push %eax
        movl $_heap_args_39, %eax
        # get procedure
        push %eax
        movl (_label_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_heap_args_40:
        .long 0xbabb1e
        .long 9
        .ascii "the_arena"
        .text
        push %eax
        movl $_heap_args_40, %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_heap_args_41:
        .long 0xbabb1e
        .long 13
        .ascii "arena_pointer"
        .text
        push %eax
        movl $_heap_args_41, %eax
        # get procedure
        push %eax
        movl (_heap_args_42), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _heap_args_35, .-_heap_args_35
_heap_args_33:
        push %eax
        movl $_heap_args_34, %eax
        # get procedure
        push %eax
        movl (_add_to_header_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        .section .data
_align4_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _align4_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_align4_3:
        .long 0xca11ab1e
        .long _align4_4
        .long 0
        .text
        .type _align4_4, @function
_align4_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_align4_5:
        .long 0xbabb1e
        .long 1
        .ascii "3"
        .text
        push %eax
        movl $_align4_5, %eax
        # get procedure
        push %eax
        movl (_const_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_add_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_align4_6:
        .long 0xbabb1e
        .long 2
        .ascii "~3"
        .text
        push %eax
        movl $_align4_6, %eax
        # get procedure
        push %eax
        movl (_const_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_asm_and_1), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _align4_4, .-_align4_4
_align4_2:
        push %eax
        movl $_align4_3, %eax
        # initialize global variable with value
        movl %eax, (_align4_1)
        pop %eax
        .section .data
_emit_malloc_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _emit_malloc_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_emit_malloc_3:
        .long 0xca11ab1e
        .long _emit_malloc_4
        .long 0
        .text
        .type _emit_malloc_4, @function
_emit_malloc_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $0, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_emit_malloc_5:
        .long 0xbabb1e
        .long 57
        .ascii "code to allocate memory; untagged number of bytes in %eax"
        .text
        push %eax
        movl $_emit_malloc_5, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_eax_1), %eax
        # get procedure
        push %eax
        movl (_align4_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_ebx_1), %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_emit_malloc_6:
        .long 0xbabb1e
        .long 13
        .ascii "arena_pointer"
        .text
        push %eax
        movl $_emit_malloc_6, %eax
        # get procedure
        push %eax
        movl (_indirect_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_emit_malloc_7:
        .long 0xbabb1e
        .long 13
        .ascii "arena_pointer"
        .text
        push %eax
        movl $_emit_malloc_7, %eax
        # get procedure
        push %eax
        movl (_indirect_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl (_eax_1), %eax
        # get procedure
        push %eax
        movl (_add_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_emit_malloc_8:
        .long 0xbabb1e
        .long 13
        .ascii "arena_pointer"
        .text
        push %eax
        movl $_emit_malloc_8, %eax
        # get procedure
        push %eax
        movl (_indirect_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_emit_malloc_9:
        .long 0xbabb1e
        .long 9
        .ascii "end_arena"
        .text
        push %eax
        movl $_emit_malloc_9, %eax
        # get procedure
        push %eax
        movl (_const_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_cmp_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_emit_malloc_10:
        .long 0xbabb1e
        .long 10
        .ascii "arena_full"
        .text
        push %eax
        movl $_emit_malloc_10, %eax
        # get procedure
        push %eax
        movl (_ja_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_eax_1), %eax
        push %eax
        movl (_ebx_1), %eax
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_emit_malloc_11:
        .long 0xbabb1e
        .long 41
        .ascii "now %eax points to newly allocated memory"
        .text
        push %eax
        movl $_emit_malloc_11, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _emit_malloc_4, .-_emit_malloc_4
_emit_malloc_2:
        push %eax
        movl $_emit_malloc_3, %eax
        # get procedure
        push %eax
        movl (_memo0_asm_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # initialize global variable with value
        movl %eax, (_emit_malloc_1)
        pop %eax
        .section .data
_push_closure_5:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _emit_malloc_n_1
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_emit_malloc_n_2:
        .long 0xca11ab1e
        .long _emit_malloc_n_3
        .long 0
        .text
        .type _emit_malloc_n_3, @function
_emit_malloc_n_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl $1 + 0<<2, %eax
        push %eax
        movl $1 + 4<<2, %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_remainder_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_emit_malloc_n_4), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_number_Gtstring_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        # jump past the body of the lambda
        jmp _emit_malloc_n_5
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_emit_malloc_n_6:
        .long 0xca11ab1e
        .long _emit_malloc_n_7
        .long 0
        .text
        .type _emit_malloc_n_7, @function
_emit_malloc_n_7:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_emit_malloc_n_8:
        .long 0xbabb1e
        .long 16
        .ascii "allocate bytes: "
        .text
        push %eax
        movl $_emit_malloc_n_8, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_tos_1), %eax
        # get procedure
        push %eax
        movl (_asm_push_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_tos_1), %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_emit_malloc_n_9:
        .long 0xbabb1e
        .long 13
        .ascii "arena_pointer"
        .text
        push %eax
        movl $_emit_malloc_n_9, %eax
        # get procedure
        push %eax
        movl (_indirect_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_emit_malloc_n_10:
        .long 0xbabb1e
        .long 13
        .ascii "arena_pointer"
        .text
        push %eax
        movl $_emit_malloc_n_10, %eax
        # get procedure
        push %eax
        movl (_indirect_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_const_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_add_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_emit_malloc_n_11:
        .long 0xbabb1e
        .long 13
        .ascii "arena_pointer"
        .text
        push %eax
        movl $_emit_malloc_n_11, %eax
        # get procedure
        push %eax
        movl (_indirect_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_emit_malloc_n_12:
        .long 0xbabb1e
        .long 9
        .ascii "end_arena"
        .text
        push %eax
        movl $_emit_malloc_n_12, %eax
        # get procedure
        push %eax
        movl (_const_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_cmp_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_emit_malloc_n_13:
        .long 0xbabb1e
        .long 10
        .ascii "arena_full"
        .text
        push %eax
        movl $_emit_malloc_n_13, %eax
        # get procedure
        push %eax
        movl (_ja_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_emit_malloc_n_14:
        .long 0xbabb1e
        .long 41
        .ascii "now %eax points to newly allocated memory"
        .text
        push %eax
        movl $_emit_malloc_n_14, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _emit_malloc_n_7, .-_emit_malloc_n_7
_emit_malloc_n_5:
        push %eax
        movl $_emit_malloc_n_6, %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _emit_malloc_n_3, .-_emit_malloc_n_3
_emit_malloc_n_1:
        push %eax
        movl $_emit_malloc_n_2, %eax
        # get procedure
        push %eax
        movl (_memo1_asm_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # initialize global variable with value
        movl %eax, (_push_closure_5)
        pop %eax
        # jump past the body of the lambda
        jmp _emit_malloc_n_15
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_emit_malloc_n_16:
        .long 0xca11ab1e
        .long _emit_malloc_n_17
        .long 0
        .text
        .type _emit_malloc_n_17, @function
_emit_malloc_n_17:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $0, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_emit_malloc_n_18:
        .long 0xbabb1e
        .long 1
        .ascii "0"
        .text
        push %eax
        movl $_emit_malloc_n_18, %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_emit_malloc_n_19:
        .long 0xbabb1e
        .long 12
        .ascii "stack_bottom"
        .text
        push %eax
        movl $_emit_malloc_n_19, %eax
        # get procedure
        push %eax
        movl (_heap_args_42), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _emit_malloc_n_17, .-_emit_malloc_n_17
_emit_malloc_n_15:
        push %eax
        movl $_emit_malloc_n_16, %eax
        # get procedure
        push %eax
        movl (_add_to_header_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        .section .data
_string_magic_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_string_magic_2:
        .long 0xbabb1e
        .long 8
        .ascii "0xbabb1e"
        .text
        push %eax
        movl $_string_magic_2, %eax
        # initialize global variable with value
        movl %eax, (_string_magic_1)
        pop %eax
        push %eax
        movl (_string_magic_1), %eax
        push %eax
        movl $_string_magic_3, %eax
        # get procedure
        push %eax
        movl (_define_magic_check_primitive_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .data
_ensure_string_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_ensure_string_2:
        .long 0xbabb1e
        .long 12
        .ascii "not a string"
        .text
        push %eax
        movl $_ensure_string_2, %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_ensure_string_3:
        .long 0xbabb1e
        .long 13
        .ascii "ensure_string"
        .text
        push %eax
        movl $_ensure_string_3, %eax
        push %eax
        movl (_string_magic_1), %eax
        # get procedure
        push %eax
        movl (_call_ensure_magic_routine_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        call *%ebx
        # initialize global variable with value
        movl %eax, (_ensure_string_1)
        pop %eax
        .section .data
_constant_string_2_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _constant_string_2_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_constant_string_2_3:
        .long 0xca11ab1e
        .long _constant_string_2_4
        .long 0
        .text
        .type _constant_string_2_4, @function
_constant_string_2_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $2, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 4(%ebp), %eax
        # get procedure
        push %eax
        movl (_rodatum_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_string_magic_1), %eax
        # get procedure
        push %eax
        movl (_compile_word_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # string-length inlined primitive
        call ensure_string
        lea 8(%eax), %ebx
        push %ebx
        movl 4(%eax), %eax
        pop %ebx
        sal %eax
        sal %eax
        inc %eax
        # get procedure
        push %eax
        movl (_number_Gtstring_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_compile_word_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_ascii_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_text_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        pop %eax
        push %eax
        movl 4(%ebp), %eax
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _constant_string_2_4, .-_constant_string_2_4
_constant_string_2_2:
        push %eax
        movl $_constant_string_2_3, %eax
        # initialize global variable with value
        movl %eax, (_constant_string_2_1)
        pop %eax
        .section .data
_define_error_routine_9:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _constant_string_1
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_constant_string_2:
        .long 0xca11ab1e
        .long _constant_string_3
        .long 0
        .text
        .type _constant_string_3, @function
_constant_string_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # get procedure
        push %eax
        movl (_new_label_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_constant_string_2_1), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _constant_string_3, .-_constant_string_3
_constant_string_1:
        push %eax
        movl $_constant_string_2, %eax
        # initialize global variable with value
        movl %eax, (_define_error_routine_9)
        pop %eax
        .section .data
_define_error_routine_17:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _extract_string_1
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_extract_string_2:
        .long 0xca11ab1e
        .long _extract_string_3
        .long 0
        .text
        .type _extract_string_3, @function
_extract_string_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $0, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # get procedure
        push %eax
        movl (_ensure_string_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_ebx_1), %eax
        push %eax
        movl $1 + 8<<2, %eax
        push %eax
        movl (_tos_1), %eax
        # get procedure
        push %eax
        movl (_offset_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_lea_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_ebx_1), %eax
        # get procedure
        push %eax
        movl (_asm_push_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_tos_1), %eax
        push %eax
        movl $1 + 4<<2, %eax
        push %eax
        movl (_tos_1), %eax
        # get procedure
        push %eax
        movl (_offset_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _extract_string_3, .-_extract_string_3
_extract_string_1:
        push %eax
        movl $_extract_string_2, %eax
        # initialize global variable with value
        movl %eax, (_define_error_routine_17)
        pop %eax
        # jump past the body of the lambda
        jmp _extract_string_4
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_extract_string_5:
        .long 0xca11ab1e
        .long _extract_string_6
        .long 0
        .text
        .type _extract_string_6, @function
_extract_string_6:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $0, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl $1 + 0<<2, %eax
        # get procedure
        push %eax
        movl (_compile_tag_check_procedure_5), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_extract_string_7), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_extract_string_8:
        .long 0xbabb1e
        .long 43
        .ascii "we need 8 bytes more than the string length"
        .text
        push %eax
        movl $_extract_string_8, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_tos_1), %eax
        # get procedure
        push %eax
        movl (_extract_string_9), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_tos_1), %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_extract_string_10:
        .long 0xbabb1e
        .long 1
        .ascii "8"
        .text
        push %eax
        movl $_extract_string_10, %eax
        # get procedure
        push %eax
        movl (_const_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_add_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_emit_malloc_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_tos_1), %eax
        # get procedure
        push %eax
        movl (_indirect_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl (_string_magic_1), %eax
        # get procedure
        push %eax
        movl (_const_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_ebx_1), %eax
        push %eax
        movl (_tos_1), %eax
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_extract_string_11:
        .long 0xbabb1e
        .long 54
        .ascii "push address to return, get string length and store it"
        .text
        push %eax
        movl $_extract_string_11, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl $1 + 0<<2, %eax
        # get procedure
        push %eax
        movl (_compile_tag_check_procedure_5), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_tos_1), %eax
        # get procedure
        push %eax
        movl (_extract_string_9), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl $1 + 4<<2, %eax
        push %eax
        movl (_ebx_1), %eax
        # get procedure
        push %eax
        movl (_offset_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        push %eax
        movl (_tos_1), %eax
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_extract_string_12:
        .long 0xbabb1e
        .long 20
        .ascii "fill string with Xes"
        .text
        push %eax
        movl $_extract_string_12, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_edi_1), %eax
        push %eax
        movl $1 + 8<<2, %eax
        push %eax
        movl (_ebx_1), %eax
        # get procedure
        push %eax
        movl (_offset_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_lea_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_ecx_1), %eax
        push %eax
        movl (_tos_1), %eax
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_eax_1), %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_extract_string_13:
        .long 0xbabb1e
        .long 2
        .ascii "'X"
        .text
        push %eax
        movl $_extract_string_13, %eax
        # get procedure
        push %eax
        movl (_const_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_rep_stosb_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_extract_string_14:
        .long 0xbabb1e
        .long 30
        .ascii "now pop and return the address"
        .text
        push %eax
        movl $_extract_string_14, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_pop_1), %eax
        # apply procedure
        # Tail call; nargs = 0
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea -4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _extract_string_6, .-_extract_string_6
_extract_string_4:
        push %eax
        movl $_extract_string_5, %eax
        push %eax
        movl $1 + 1<<2, %eax
        push %eax
        movl $_extract_string_15, %eax
        # get procedure
        push %eax
        movl (_define_global_procedure_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        call *%ebx
        pop %eax
        .section .data
_check_array_bounds_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _check_array_bounds_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_check_array_bounds_3:
        .long 0xca11ab1e
        .long _check_array_bounds_4
        .long 0
        .text
        .type _check_array_bounds_4, @function
_check_array_bounds_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $0, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_check_array_bounds_5:
        .long 0xbabb1e
        .long 47
        .ascii "verify that tagged %eax is in [0, untagged NOS)"
        .text
        push %eax
        movl $_check_array_bounds_5, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_extract_string_7), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_eax_1), %eax
        # get procedure
        push %eax
        movl (_extract_string_9), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_check_array_bounds_6:
        .long 0xbabb1e
        .long 47
        .ascii "set flags by (unsigned array index - array max)"
        .text
        push %eax
        movl $_check_array_bounds_6, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_tos_1), %eax
        push %eax
        movl (_nos_1), %eax
        # get procedure
        push %eax
        movl (_cmp_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_check_array_bounds_7:
        .long 0xbabb1e
        .long 51
        .ascii "now we expect unsigned overflow, i.e. borrow/carry."
        .text
        push %eax
        movl $_check_array_bounds_7, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_check_array_bounds_8:
        .long 0xbabb1e
        .long 19
        .ascii "index_out_of_bounds"
        .text
        push %eax
        movl $_check_array_bounds_8, %eax
        # get procedure
        push %eax
        movl (_jnb_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_check_array_bounds_9:
        .long 0xbabb1e
        .long 40
        .ascii "now discard both the index and the bound"
        .text
        push %eax
        movl $_check_array_bounds_9, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_pop_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_pop_1), %eax
        # apply procedure
        # Tail call; nargs = 0
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea -4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _check_array_bounds_4, .-_check_array_bounds_4
_check_array_bounds_2:
        push %eax
        movl $_check_array_bounds_3, %eax
        # initialize global variable with value
        movl %eax, (_check_array_bounds_1)
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_check_array_bounds_10:
        .long 0xbabb1e
        .long 25
        .ascii "array index out of bounds"
        .text
        push %eax
        movl $_check_array_bounds_10, %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_check_array_bounds_11:
        .long 0xbabb1e
        .long 19
        .ascii "index_out_of_bounds"
        .text
        push %eax
        movl $_check_array_bounds_11, %eax
        # get procedure
        push %eax
        movl (_define_error_routine_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_check_array_bounds_12:
        .long 0xbabb1e
        .long 17
        .ascii "the arena is full"
        .text
        push %eax
        movl $_check_array_bounds_12, %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_check_array_bounds_13:
        .long 0xbabb1e
        .long 10
        .ascii "arena_full"
        .text
        push %eax
        movl $_check_array_bounds_13, %eax
        # get procedure
        push %eax
        movl (_define_error_routine_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        # jump past the body of the lambda
        jmp _check_array_bounds_14
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_check_array_bounds_15:
        .long 0xca11ab1e
        .long _check_array_bounds_16
        .long 0
        .text
        .type _check_array_bounds_16, @function
_check_array_bounds_16:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $0, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_check_array_bounds_17:
        .long 0xbabb1e
        .long 31
        .ascii "string-set! primitive procedure"
        .text
        push %eax
        movl $_check_array_bounds_17, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl $1 + 0<<2, %eax
        # get procedure
        push %eax
        movl (_compile_tag_check_procedure_5), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_define_error_routine_17), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        pop %eax
        push %eax
        movl $1 + 1<<2, %eax
        # get procedure
        push %eax
        movl (_compile_tag_check_procedure_5), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_check_array_bounds_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        pop %eax
        push %eax
        movl $1 + 1<<2, %eax
        # get procedure
        push %eax
        movl (_compile_tag_check_procedure_5), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_tos_1), %eax
        # get procedure
        push %eax
        movl (_extract_string_9), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_edi_1), %eax
        push %eax
        movl (_tos_1), %eax
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_check_array_bounds_18:
        .long 0xbabb1e
        .long 55
        .ascii "now retrieve the address of string bytes from the stack"
        .text
        push %eax
        movl $_check_array_bounds_18, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_pop_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_ebx_1), %eax
        push %eax
        movl (_tos_1), %eax
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl $1 + 2<<2, %eax
        # get procedure
        push %eax
        movl (_compile_tag_check_procedure_5), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_check_array_bounds_19), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_tos_1), %eax
        # get procedure
        push %eax
        movl (_check_array_bounds_20), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl $1 + 1<<2, %eax
        push %eax
        movl (_edi_1), %eax
        push %eax
        movl (_ebx_1), %eax
        # get procedure
        push %eax
        movl (_index_register_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_indirect_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl (_al_1), %eax
        # get procedure
        push %eax
        movl (_movb_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_check_array_bounds_21:
        .long 0xbabb1e
        .long 38
        .ascii "discard the character and base address"
        .text
        push %eax
        movl $_check_array_bounds_21, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_pop_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_pop_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_check_array_bounds_22:
        .long 0xbabb1e
        .long 29
        .ascii "but we need a return value..."
        .text
        push %eax
        movl $_check_array_bounds_22, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl $1 + 0<<2, %eax
        # get procedure
        push %eax
        movl (_compile_tag_check_procedure_5), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _check_array_bounds_16, .-_check_array_bounds_16
_check_array_bounds_14:
        push %eax
        movl $_check_array_bounds_15, %eax
        push %eax
        movl $1 + 3<<2, %eax
        push %eax
        movl $_check_array_bounds_23, %eax
        # get procedure
        push %eax
        movl (_define_global_procedure_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        call *%ebx
        pop %eax
        # jump past the body of the lambda
        jmp _check_array_bounds_24
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_check_array_bounds_25:
        .long 0xca11ab1e
        .long _check_array_bounds_26
        .long 0
        .text
        .type _check_array_bounds_26, @function
_check_array_bounds_26:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $0, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_check_array_bounds_27:
        .long 0xbabb1e
        .long 30
        .ascii "string-ref primitive procedure"
        .text
        push %eax
        movl $_check_array_bounds_27, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl $1 + 0<<2, %eax
        # get procedure
        push %eax
        movl (_compile_tag_check_procedure_5), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_define_error_routine_17), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        pop %eax
        push %eax
        movl $1 + 1<<2, %eax
        # get procedure
        push %eax
        movl (_compile_tag_check_procedure_5), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_check_array_bounds_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        pop %eax
        push %eax
        movl $1 + 1<<2, %eax
        # get procedure
        push %eax
        movl (_compile_tag_check_procedure_5), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_tos_1), %eax
        # get procedure
        push %eax
        movl (_extract_string_9), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_check_array_bounds_28:
        .long 0xbabb1e
        .long 42
        .ascii "get base address of string data from stack"
        .text
        push %eax
        movl $_check_array_bounds_28, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_ebx_1), %eax
        # get procedure
        push %eax
        movl (_asm_pop_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_tos_1), %eax
        push %eax
        movl $1 + 1<<2, %eax
        push %eax
        movl (_ebx_1), %eax
        push %eax
        movl (_tos_1), %eax
        # get procedure
        push %eax
        movl (_index_register_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_indirect_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_movzbl_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_tos_1), %eax
        # get procedure
        push %eax
        movl (_check_array_bounds_29), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _check_array_bounds_26, .-_check_array_bounds_26
_check_array_bounds_24:
        push %eax
        movl $_check_array_bounds_25, %eax
        push %eax
        movl $1 + 2<<2, %eax
        push %eax
        movl $_check_array_bounds_30, %eax
        # get procedure
        push %eax
        movl (_define_global_procedure_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        call *%ebx
        pop %eax
        .section .data
_inline_string_length_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _inline_string_length_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_inline_string_length_3:
        .long 0xca11ab1e
        .long _inline_string_length_4
        .long 0
        .text
        .type _inline_string_length_4, @function
_inline_string_length_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl $1 + 1<<2, %eax
        # get procedure
        push %eax
        movl (_emit_malloc_n_4), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_inline_string_length_5:
        .long 0xbabb1e
        .long 31
        .ascii "string-length inlined primitive"
        .text
        push %eax
        movl $_inline_string_length_5, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_define_error_routine_17), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_ebx_1), %eax
        # get procedure
        push %eax
        movl (_asm_pop_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_tos_1), %eax
        # get procedure
        push %eax
        movl (_inline_string_length_6), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _inline_string_length_4, .-_inline_string_length_4
_inline_string_length_2:
        push %eax
        movl $_inline_string_length_3, %eax
        # initialize global variable with value
        movl %eax, (_inline_string_length_1)
        pop %eax
        .section .data
_cons_magic_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_cons_magic_2:
        .long 0xbabb1e
        .long 9
        .ascii "0x2ce11ed"
        .text
        push %eax
        movl $_cons_magic_2, %eax
        # initialize global variable with value
        movl %eax, (_cons_magic_1)
        pop %eax
        push %eax
        movl (_cons_magic_1), %eax
        push %eax
        movl $_cons_magic_3, %eax
        # get procedure
        push %eax
        movl (_define_magic_check_primitive_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .data
_ensure_cons_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_ensure_cons_2:
        .long 0xbabb1e
        .long 10
        .ascii "not a cons"
        .text
        push %eax
        movl $_ensure_cons_2, %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_ensure_cons_3:
        .long 0xbabb1e
        .long 11
        .ascii "ensure_cons"
        .text
        push %eax
        movl $_ensure_cons_3, %eax
        push %eax
        movl (_cons_magic_1), %eax
        # get procedure
        push %eax
        movl (_call_ensure_magic_routine_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        call *%ebx
        # initialize global variable with value
        movl %eax, (_ensure_cons_1)
        pop %eax
        .section .data
_inline_car_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _inline_car_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_inline_car_3:
        .long 0xca11ab1e
        .long _inline_car_4
        .long 0
        .text
        .type _inline_car_4, @function
_inline_car_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl $1 + 1<<2, %eax
        # get procedure
        push %eax
        movl (_emit_malloc_n_4), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_inline_car_5:
        .long 0xbabb1e
        .long 11
        .ascii "inlined car"
        .text
        push %eax
        movl $_inline_car_5, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_ensure_cons_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_tos_1), %eax
        push %eax
        movl $1 + 4<<2, %eax
        push %eax
        movl (_tos_1), %eax
        # get procedure
        push %eax
        movl (_offset_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _inline_car_4, .-_inline_car_4
_inline_car_2:
        push %eax
        movl $_inline_car_3, %eax
        # initialize global variable with value
        movl %eax, (_inline_car_1)
        pop %eax
        .section .data
_inline_cdr_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _inline_cdr_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_inline_cdr_3:
        .long 0xca11ab1e
        .long _inline_cdr_4
        .long 0
        .text
        .type _inline_cdr_4, @function
_inline_cdr_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl $1 + 1<<2, %eax
        # get procedure
        push %eax
        movl (_emit_malloc_n_4), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_inline_cdr_5:
        .long 0xbabb1e
        .long 11
        .ascii "inlined cdr"
        .text
        push %eax
        movl $_inline_cdr_5, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_ensure_cons_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_tos_1), %eax
        push %eax
        movl $1 + 8<<2, %eax
        push %eax
        movl (_tos_1), %eax
        # get procedure
        push %eax
        movl (_offset_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _inline_cdr_4, .-_inline_cdr_4
_inline_cdr_2:
        push %eax
        movl $_inline_cdr_3, %eax
        # initialize global variable with value
        movl %eax, (_inline_cdr_1)
        pop %eax
        # jump past the body of the lambda
        jmp _inline_cdr_6
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_inline_cdr_7:
        .long 0xca11ab1e
        .long _inline_cdr_8
        .long 0
        .text
        .type _inline_cdr_8, @function
_inline_cdr_8:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $0, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # get procedure
        push %eax
        movl (_text_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_inline_cdr_9:
        .long 0xbabb1e
        .long 4
        .ascii "cons"
        .text
        push %eax
        movl $_inline_cdr_9, %eax
        # get procedure
        push %eax
        movl (_label_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _inline_cdr_8, .-_inline_cdr_8
_inline_cdr_6:
        push %eax
        movl $_inline_cdr_7, %eax
        # get procedure
        push %eax
        movl (_add_to_header_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        # jump past the body of the lambda
        jmp _inline_cdr_10
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_inline_cdr_11:
        .long 0xca11ab1e
        .long _inline_cdr_12
        .long 0
        .text
        .type _inline_cdr_12, @function
_inline_cdr_12:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $0, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl $1 + 12<<2, %eax
        # get procedure
        push %eax
        movl (_push_closure_5), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_tos_1), %eax
        # get procedure
        push %eax
        movl (_indirect_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl (_cons_magic_1), %eax
        # get procedure
        push %eax
        movl (_const_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_ebx_1), %eax
        push %eax
        movl (_tos_1), %eax
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl $1 + 0<<2, %eax
        # get procedure
        push %eax
        movl (_compile_tag_check_procedure_5), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl $1 + 4<<2, %eax
        push %eax
        movl (_ebx_1), %eax
        # get procedure
        push %eax
        movl (_offset_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        push %eax
        movl (_tos_1), %eax
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_pop_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        pop %eax
        push %eax
        movl $1 + 1<<2, %eax
        # get procedure
        push %eax
        movl (_compile_tag_check_procedure_5), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl $1 + 8<<2, %eax
        push %eax
        movl (_ebx_1), %eax
        # get procedure
        push %eax
        movl (_offset_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        push %eax
        movl (_tos_1), %eax
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_pop_1), %eax
        # apply procedure
        # Tail call; nargs = 0
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea -4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _inline_cdr_12, .-_inline_cdr_12
_inline_cdr_10:
        push %eax
        movl $_inline_cdr_11, %eax
        push %eax
        movl $1 + 2<<2, %eax
        push %eax
        movl $_inline_cdr_13, %eax
        # get procedure
        push %eax
        movl (_define_global_procedure_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        call *%ebx
        pop %eax
        .section .data
_compile_cons_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _compile_cons_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_cons_3:
        .long 0xca11ab1e
        .long _compile_cons_4
        .long 0
        .text
        .type _compile_cons_4, @function
_compile_cons_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $3, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 8(%ebp), %eax
        # get procedure
        push %eax
        movl (_rodatum_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_cons_magic_1), %eax
        # get procedure
        push %eax
        movl (_compile_word_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_compile_word_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl 4(%ebp), %eax
        # get procedure
        push %eax
        movl (_compile_word_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_text_1), %eax
        # apply procedure
        # Tail call; nargs = 0
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea -4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _compile_cons_4, .-_compile_cons_4
_compile_cons_2:
        push %eax
        movl $_compile_cons_3, %eax
        # initialize global variable with value
        movl %eax, (_compile_cons_1)
        pop %eax
        .section .data
_symbol_magic_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_symbol_magic_2:
        .long 0xbabb1e
        .long 7
        .ascii "0x1abe1"
        .text
        push %eax
        movl $_symbol_magic_2, %eax
        # initialize global variable with value
        movl %eax, (_symbol_magic_1)
        pop %eax
        push %eax
        movl (_symbol_magic_1), %eax
        push %eax
        movl $_symbol_magic_3, %eax
        # get procedure
        push %eax
        movl (_define_magic_check_primitive_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .data
_ensure_symbol_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_ensure_symbol_2:
        .long 0xbabb1e
        .long 12
        .ascii "not a symbol"
        .text
        push %eax
        movl $_ensure_symbol_2, %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_ensure_symbol_3:
        .long 0xbabb1e
        .long 13
        .ascii "ensure_symbol"
        .text
        push %eax
        movl $_ensure_symbol_3, %eax
        push %eax
        movl (_symbol_magic_1), %eax
        # get procedure
        push %eax
        movl (_call_ensure_magic_routine_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        call *%ebx
        # initialize global variable with value
        movl %eax, (_ensure_symbol_1)
        pop %eax
        .section .data
_interned_symbol_list_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        push %eax
        movl $2 + 256<<2, %eax
        # initialize global variable with value
        movl %eax, (_interned_symbol_list_1)
        pop %eax
        .section .data
_intern_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _intern_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_intern_3:
        .long 0xca11ab1e
        .long _intern_4
        .long 0
        .text
        .type _intern_4, @function
_intern_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl (_interned_symbol_list_1), %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_intern_5), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _intern_4, .-_intern_4
_intern_2:
        push %eax
        movl $_intern_3, %eax
        # initialize global variable with value
        movl %eax, (_intern_1)
        pop %eax
        .section .data
_intern_5:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _interning_1
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_interning_2:
        .long 0xca11ab1e
        .long _interning_3
        .long 0
        .text
        .type _interning_3, @function
_interning_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $2, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 4(%ebp), %eax
        push %eax
        movl $2 + 256<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _interning_4
        push %eax
        movl (_interned_symbol_list_1), %eax
        # get procedure
        push %eax
        movl (_new_label_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_list_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_cons_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        movl %eax, (_interned_symbol_list_1)
        pop %eax
        push %eax
        movl (_interned_symbol_list_1), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        jmp _interning_5
_interning_4:
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl 4(%ebp), %eax
        # get procedure
        push %eax
        movl (_assq_9), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _interning_6
        push %eax
        movl 4(%ebp), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        jmp _interning_7
_interning_6:
        push %eax
        movl 4(%ebp), %eax
        # inlined cdr
        call ensure_cons
        movl 8(%eax), %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_intern_5), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
_interning_7:
_interning_5:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _interning_3, .-_interning_3
_interning_1:
        push %eax
        movl $_interning_2, %eax
        # initialize global variable with value
        movl %eax, (_intern_5)
        pop %eax
        .section .data
_symbol_value_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _symbol_value_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_symbol_value_3:
        .long 0xca11ab1e
        .long _symbol_value_4
        .long 0
        .text
        .type _symbol_value_4, @function
_symbol_value_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_intern_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_cadr_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _symbol_value_4, .-_symbol_value_4
_symbol_value_2:
        push %eax
        movl $_symbol_value_3, %eax
        # initialize global variable with value
        movl %eax, (_symbol_value_1)
        pop %eax
        .section .data
_emit_symbols_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _emit_symbols_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_emit_symbols_3:
        .long 0xca11ab1e
        .long _emit_symbols_4
        .long 0
        .text
        .type _emit_symbols_4, @function
_emit_symbols_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $0, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_emit_symbols_5:
        .long 0xbabb1e
        .long 7
        .ascii "symbols"
        .text
        push %eax
        movl $_emit_symbols_5, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_interned_symbol_list_1), %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_emit_symbols_6:
        .long 0xbabb1e
        .long 1
        .ascii "0"
        .text
        push %eax
        movl $_emit_symbols_6, %eax
        # get procedure
        push %eax
        movl (_emit_symbols_7), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _emit_symbols_4, .-_emit_symbols_4
_emit_symbols_2:
        push %eax
        movl $_emit_symbols_3, %eax
        # initialize global variable with value
        movl %eax, (_emit_symbols_1)
        pop %eax
        .section .data
_emit_symbols_7:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _emit_symbols_from_1
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_emit_symbols_from_2:
        .long 0xca11ab1e
        .long _emit_symbols_from_3
        .long 0
        .text
        .type _emit_symbols_from_3, @function
_emit_symbols_from_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $2, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # move arg from stack to heap: last-pointer
        push %eax
        movl 0(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # move arg from stack to heap: remaining
        push %eax
        movl 4(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # %ifeq
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        push %eax
        movl $2 + 256<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _emit_symbols_from_4
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_emit_symbols_from_6), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        jmp _emit_symbols_from_5
_emit_symbols_from_4:
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        # get procedure
        # jump past the body of the lambda
        jmp _emit_symbols_from_7
        .text
        .type _emit_symbols_from_8, @function
_emit_symbols_from_8:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 last-pointer
        push 12(%eax)
        # fetch artifact from closure: 1 remaining
        push 16(%eax)
        # discarding useless value in %eax
        pop %eax
        # move arg from stack to heap: symlabel
        push %eax
        movl 0(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # fetching heap var pointer 2
        push %eax
        movl -24(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        call ensure_symbol
        movl 4(%eax), %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_emit_symbols_from_9:
        .long 0xbabb1e
        .long 8
        .ascii "symbol: "
        .text
        push %eax
        movl $_emit_symbols_from_9, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        # fetching heap var pointer 2
        push %eax
        movl -24(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        call ensure_symbol
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_emit_symbols_from_10), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        # jump past the body of the lambda
        jmp _emit_symbols_from_11
        .text
        .type _emit_symbols_from_12, @function
_emit_symbols_from_12:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 last-pointer
        push 12(%eax)
        # fetch artifact from closure: 1 symlabel
        push 16(%eax)
        # fetch artifact from closure: 2 remaining
        push 20(%eax)
        # discarding useless value in %eax
        pop %eax
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # inlined cdr
        call ensure_cons
        movl 8(%eax), %eax
        # get procedure
        push %eax
        movl (_rodatum_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_symbol_magic_1), %eax
        # get procedure
        push %eax
        movl (_compile_word_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_compile_word_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_compile_word_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        # fetching heap var pointer 2
        push %eax
        movl -24(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # inlined cdr
        call ensure_cons
        movl 8(%eax), %eax
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # inlined cdr
        call ensure_cons
        movl 8(%eax), %eax
        # get procedure
        push %eax
        movl (_emit_symbols_7), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _emit_symbols_from_12, .-_emit_symbols_from_12
_emit_symbols_from_11:
        # allocate bytes: 24
        push %eax
        movl (arena_pointer), %eax
        add $24, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_emit_symbols_from_12, 4(%ebx)
        movl $3, 8(%ebx)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # fetching heap var pointer 2
        push %eax
        movl -24(%ebp), %eax
        movl %eax, 16(%ebx)
        pop %eax
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        movl %eax, 20(%ebx)
        pop %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _emit_symbols_from_8, .-_emit_symbols_from_8
_emit_symbols_from_7:
        # allocate bytes: 20
        push %eax
        movl (arena_pointer), %eax
        add $20, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_emit_symbols_from_8, 4(%ebx)
        movl $2, 8(%ebx)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        movl %eax, 16(%ebx)
        pop %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
_emit_symbols_from_5:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _emit_symbols_from_3, .-_emit_symbols_from_3
_emit_symbols_from_1:
        push %eax
        movl $_emit_symbols_from_2, %eax
        # initialize global variable with value
        movl %eax, (_emit_symbols_7)
        pop %eax
        .section .data
_emit_symbols_from_6:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _emit_symbol_list_header_1
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_emit_symbol_list_header_2:
        .long 0xca11ab1e
        .long _emit_symbol_list_header_3
        .long 0
        .text
        .type _emit_symbol_list_header_3, @function
_emit_symbol_list_header_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_emit_symbol_list_header_4:
        .long 0xbabb1e
        .long 5
        .ascii ".data"
        .text
        push %eax
        movl $_emit_symbol_list_header_4, %eax
        # get procedure
        push %eax
        movl (_section_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_emit_symbol_list_header_5:
        .long 0xbabb1e
        .long 12
        .ascii "symbol_table"
        .text
        push %eax
        movl $_emit_symbol_list_header_5, %eax
        # get procedure
        push %eax
        movl (_label_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_compile_word_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _emit_symbol_list_header_3, .-_emit_symbol_list_header_3
_emit_symbol_list_header_1:
        push %eax
        movl $_emit_symbol_list_header_2, %eax
        # initialize global variable with value
        movl %eax, (_emit_symbols_from_6)
        pop %eax
        .section .data
_inline_symbol_Gtstring_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _inline_symbol_Gtstring_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_inline_symbol_Gtstring_3:
        .long 0xca11ab1e
        .long _inline_symbol_Gtstring_4
        .long 0
        .text
        .type _inline_symbol_Gtstring_4, @function
_inline_symbol_Gtstring_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl $1 + 1<<2, %eax
        # get procedure
        push %eax
        movl (_emit_malloc_n_4), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_ensure_symbol_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_tos_1), %eax
        push %eax
        movl $1 + 4<<2, %eax
        push %eax
        movl (_tos_1), %eax
        # get procedure
        push %eax
        movl (_offset_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _inline_symbol_Gtstring_4, .-_inline_symbol_Gtstring_4
_inline_symbol_Gtstring_2:
        push %eax
        movl $_inline_symbol_Gtstring_3, %eax
        # initialize global variable with value
        movl %eax, (_inline_symbol_Gtstring_1)
        pop %eax
        # jump past the body of the lambda
        jmp _inline_symbol_Gtstring_5
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_inline_symbol_Gtstring_6:
        .long 0xca11ab1e
        .long _inline_symbol_Gtstring_7
        .long 0
        .text
        .type _inline_symbol_Gtstring_7, @function
_inline_symbol_Gtstring_7:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $0, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl $1 + 0<<2, %eax
        # get procedure
        push %eax
        movl (_compile_tag_check_procedure_5), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_define_error_routine_17), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_inline_symbol_Gtstring_8:
        .long 0xbabb1e
        .long 62
        .ascii "now string length is in %eax and string data pointer at (%esp)"
        .text
        push %eax
        movl $_inline_symbol_Gtstring_8, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_ebx_1), %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_inline_symbol_Gtstring_9:
        .long 0xbabb1e
        .long 12
        .ascii "symbol_table"
        .text
        push %eax
        movl $_inline_symbol_Gtstring_9, %eax
        # get procedure
        push %eax
        movl (_indirect_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_inline_symbol_Gtstring_10:
        .long 0xbabb1e
        .long 21
        .ascii "string_to_symbol_loop"
        .text
        push %eax
        movl $_inline_symbol_Gtstring_10, %eax
        # get procedure
        push %eax
        movl (_label_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_ebx_1), %eax
        push %eax
        movl (_ebx_1), %eax
        # get procedure
        push %eax
        movl (_test_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_inline_symbol_Gtstring_11:
        .long 0xbabb1e
        .long 17
        .ascii "intern_new_symbol"
        .text
        push %eax
        movl $_inline_symbol_Gtstring_11, %eax
        # get procedure
        push %eax
        movl (_jz_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_inline_symbol_Gtstring_12:
        .long 0xbabb1e
        .long 29
        .ascii "fetch pointer to string value"
        .text
        push %eax
        movl $_inline_symbol_Gtstring_12, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_edx_1), %eax
        push %eax
        movl $1 + 4<<2, %eax
        push %eax
        movl (_ebx_1), %eax
        # get procedure
        push %eax
        movl (_offset_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_inline_symbol_Gtstring_13:
        .long 0xbabb1e
        .long 19
        .ascii "fetch string length"
        .text
        push %eax
        movl $_inline_symbol_Gtstring_13, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_ecx_1), %eax
        push %eax
        movl $1 + 4<<2, %eax
        push %eax
        movl (_edx_1), %eax
        # get procedure
        push %eax
        movl (_offset_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_eax_1), %eax
        push %eax
        movl (_ecx_1), %eax
        # get procedure
        push %eax
        movl (_cmp_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_inline_symbol_Gtstring_14:
        .long 0xbabb1e
        .long 31
        .ascii "wrong_symbol_thanks_for_playing"
        .text
        push %eax
        movl $_inline_symbol_Gtstring_14, %eax
        # get procedure
        push %eax
        movl (_jnz_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_inline_symbol_Gtstring_15:
        .long 0xbabb1e
        .long 20
        .ascii "fetch string pointer"
        .text
        push %eax
        movl $_inline_symbol_Gtstring_15, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_esi_1), %eax
        push %eax
        movl $1 + 8<<2, %eax
        push %eax
        movl (_edx_1), %eax
        # get procedure
        push %eax
        movl (_offset_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_lea_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_edi_1), %eax
        push %eax
        movl (_nos_1), %eax
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_inline_symbol_Gtstring_16:
        .long 0xbabb1e
        .long 50
        .ascii "compare strings at [esi:esi+ecx] and [edi:edi+ecx]"
        .text
        push %eax
        movl $_inline_symbol_Gtstring_16, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_repe_cmpsb_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_inline_symbol_Gtstring_17:
        .long 0xbabb1e
        .long 31
        .ascii "wrong_symbol_thanks_for_playing"
        .text
        push %eax
        movl $_inline_symbol_Gtstring_17, %eax
        # get procedure
        push %eax
        movl (_jnz_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_inline_symbol_Gtstring_18:
        .long 0xbabb1e
        .long 22
        .ascii "found the right symbol"
        .text
        push %eax
        movl $_inline_symbol_Gtstring_18, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_pop_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_tos_1), %eax
        push %eax
        movl (_ebx_1), %eax
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_inline_symbol_Gtstring_19:
        .long 0xbabb1e
        .long 20
        .ascii "string_symbol_return"
        .text
        push %eax
        movl $_inline_symbol_Gtstring_19, %eax
        # get procedure
        push %eax
        movl (_jmp_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_inline_symbol_Gtstring_20:
        .long 0xbabb1e
        .long 31
        .ascii "wrong_symbol_thanks_for_playing"
        .text
        push %eax
        movl $_inline_symbol_Gtstring_20, %eax
        # get procedure
        push %eax
        movl (_label_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_inline_symbol_Gtstring_21:
        .long 0xbabb1e
        .long 26
        .ascii "get address of next symbol"
        .text
        push %eax
        movl $_inline_symbol_Gtstring_21, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_ebx_1), %eax
        push %eax
        movl $1 + 8<<2, %eax
        push %eax
        movl (_ebx_1), %eax
        # get procedure
        push %eax
        movl (_offset_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_inline_symbol_Gtstring_22:
        .long 0xbabb1e
        .long 21
        .ascii "string_to_symbol_loop"
        .text
        push %eax
        movl $_inline_symbol_Gtstring_22, %eax
        # get procedure
        push %eax
        movl (_jmp_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_inline_symbol_Gtstring_23:
        .long 0xbabb1e
        .long 17
        .ascii "intern_new_symbol"
        .text
        push %eax
        movl $_inline_symbol_Gtstring_23, %eax
        # get procedure
        push %eax
        movl (_label_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_inline_symbol_Gtstring_24:
        .long 0xbabb1e
        .long 18
        .ascii "get string pointer"
        .text
        push %eax
        movl $_inline_symbol_Gtstring_24, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl $1 + 0<<2, %eax
        # get procedure
        push %eax
        movl (_compile_tag_check_procedure_5), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_inline_symbol_Gtstring_25:
        .long 0xbabb1e
        .long 20
        .ascii "symbols are 12 bytes"
        .text
        push %eax
        movl $_inline_symbol_Gtstring_25, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl $1 + 12<<2, %eax
        # get procedure
        push %eax
        movl (_push_closure_5), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_tos_1), %eax
        # get procedure
        push %eax
        movl (_indirect_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl (_symbol_magic_1), %eax
        # get procedure
        push %eax
        movl (_const_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_inline_symbol_Gtstring_26:
        .long 0xbabb1e
        .long 35
        .ascii "store string pointer for new symbol"
        .text
        push %eax
        movl $_inline_symbol_Gtstring_26, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_ebx_1), %eax
        push %eax
        movl (_nos_1), %eax
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl $1 + 4<<2, %eax
        push %eax
        movl (_tos_1), %eax
        # get procedure
        push %eax
        movl (_offset_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        push %eax
        movl (_ebx_1), %eax
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_ebx_1), %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_inline_symbol_Gtstring_27:
        .long 0xbabb1e
        .long 12
        .ascii "symbol_table"
        .text
        push %eax
        movl $_inline_symbol_Gtstring_27, %eax
        # get procedure
        push %eax
        movl (_indirect_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl $1 + 8<<2, %eax
        push %eax
        movl (_tos_1), %eax
        # get procedure
        push %eax
        movl (_offset_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        push %eax
        movl (_ebx_1), %eax
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_inline_symbol_Gtstring_28:
        .long 0xbabb1e
        .long 12
        .ascii "symbol_table"
        .text
        push %eax
        movl $_inline_symbol_Gtstring_28, %eax
        # get procedure
        push %eax
        movl (_indirect_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl (_tos_1), %eax
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_inline_symbol_Gtstring_29:
        .long 0xbabb1e
        .long 20
        .ascii "string_symbol_return"
        .text
        push %eax
        movl $_inline_symbol_Gtstring_29, %eax
        # get procedure
        push %eax
        movl (_label_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _inline_symbol_Gtstring_7, .-_inline_symbol_Gtstring_7
_inline_symbol_Gtstring_5:
        push %eax
        movl $_inline_symbol_Gtstring_6, %eax
        push %eax
        movl $1 + 1<<2, %eax
        push %eax
        movl $_inline_symbol_Gtstring_30, %eax
        # get procedure
        push %eax
        movl (_define_global_procedure_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        call *%ebx
        pop %eax
        .section .data
_define_error_routine_20:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _write_2_1
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_write_2_2:
        .long 0xca11ab1e
        .long _write_2_3
        .long 0
        .text
        .type _write_2_3, @function
_write_2_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $0, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl (_edx_1), %eax
        push %eax
        movl (_tos_1), %eax
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_ecx_1), %eax
        # get procedure
        push %eax
        movl (_asm_pop_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_eax_1), %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_write_2_4:
        .long 0xbabb1e
        .long 1
        .ascii "4"
        .text
        push %eax
        movl $_write_2_4, %eax
        # get procedure
        push %eax
        movl (_const_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_syscall_1), %eax
        # apply procedure
        # Tail call; nargs = 0
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea -4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _write_2_3, .-_write_2_3
_write_2_1:
        push %eax
        movl $_write_2_2, %eax
        # initialize global variable with value
        movl %eax, (_define_error_routine_20)
        pop %eax
        # jump past the body of the lambda
        jmp _write_2_5
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_write_2_6:
        .long 0xca11ab1e
        .long _write_2_7
        .long 0
        .text
        .type _write_2_7, @function
_write_2_7:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $0, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl $1 + 0<<2, %eax
        # get procedure
        push %eax
        movl (_compile_tag_check_procedure_5), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_define_error_routine_17), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_write_2_8:
        .long 0xbabb1e
        .long 12
        .ascii "fd 1: stdout"
        .text
        push %eax
        movl $_write_2_8, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_ebx_1), %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_write_2_9:
        .long 0xbabb1e
        .long 1
        .ascii "1"
        .text
        push %eax
        movl $_write_2_9, %eax
        # get procedure
        push %eax
        movl (_const_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_define_error_routine_20), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_tos_1), %eax
        push %eax
        movl (_copy_args_12), %eax
        # get procedure
        push %eax
        movl (_const_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _write_2_7, .-_write_2_7
_write_2_5:
        push %eax
        movl $_write_2_6, %eax
        push %eax
        movl $1 + 1<<2, %eax
        push %eax
        movl $_heap_args_14, %eax
        # get procedure
        push %eax
        movl (_define_global_procedure_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        call *%ebx
        pop %eax
        # jump past the body of the lambda
        jmp _write_2_10
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_write_2_11:
        .long 0xca11ab1e
        .long _write_2_12
        .long 0
        .text
        .type _write_2_12, @function
_write_2_12:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $0, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_write_2_13:
        .long 0xbabb1e
        .long 44
        .ascii "We don't have ports right now, so return nil"
        .text
        push %eax
        movl $_write_2_13, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_copy_args_12), %eax
        # get procedure
        push %eax
        movl (_push_const_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _write_2_12, .-_write_2_12
_write_2_10:
        push %eax
        movl $_write_2_11, %eax
        push %eax
        movl $1 + 0<<2, %eax
        push %eax
        movl $_write_2_14, %eax
        # get procedure
        push %eax
        movl (_define_global_procedure_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        call *%ebx
        pop %eax
        # jump past the body of the lambda
        jmp _write_2_15
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_write_2_16:
        .long 0xca11ab1e
        .long _write_2_17
        .long 0
        .text
        .type _write_2_17, @function
_write_2_17:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $0, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_write_2_18:
        .long 0xbabb1e
        .long 29
        .ascii "We don't care about our args."
        .text
        push %eax
        movl $_write_2_18, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_write_2_19:
        .long 0xbabb1e
        .long 47
        .ascii "(maybe somebody passed us (current-input-port))"
        .text
        push %eax
        movl $_write_2_19, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_write_2_20:
        .long 0xbabb1e
        .long 4
        .ascii ".bss"
        .text
        push %eax
        movl $_write_2_20, %eax
        # get procedure
        push %eax
        movl (_section_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_write_2_21:
        .long 0xbabb1e
        .long 16
        .ascii "read_char_buffer"
        .text
        push %eax
        movl $_write_2_21, %eax
        # get procedure
        push %eax
        movl (_label_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_write_2_22:
        .long 0xbabb1e
        .long 11
        .ascii ".space 1024"
        .text
        push %eax
        movl $_write_2_22, %eax
        # get procedure
        push %eax
        movl (_insn_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_write_2_23:
        .long 0xbabb1e
        .long 20
        .ascii "read_char_buffer_end"
        .text
        push %eax
        movl $_write_2_23, %eax
        # get procedure
        push %eax
        movl (_label_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_write_2_24:
        .long 0xbabb1e
        .long 5
        .ascii ".data"
        .text
        push %eax
        movl $_write_2_24, %eax
        # get procedure
        push %eax
        movl (_section_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_write_2_25:
        .long 0xbabb1e
        .long 17
        .ascii "read_char_pointer"
        .text
        push %eax
        movl $_write_2_25, %eax
        # get procedure
        push %eax
        movl (_label_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_write_2_26:
        .long 0xbabb1e
        .long 16
        .ascii "read_char_buffer"
        .text
        push %eax
        movl $_write_2_26, %eax
        # get procedure
        push %eax
        movl (_compile_word_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_write_2_27:
        .long 0xbabb1e
        .long 29
        .ascii "read_char_buffer_fill_pointer"
        .text
        push %eax
        movl $_write_2_27, %eax
        # get procedure
        push %eax
        movl (_label_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_write_2_28:
        .long 0xbabb1e
        .long 16
        .ascii "read_char_buffer"
        .text
        push %eax
        movl $_write_2_28, %eax
        # get procedure
        push %eax
        movl (_compile_word_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_text_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_write_2_29:
        .long 0xbabb1e
        .long 9
        .ascii "read_char"
        .text
        push %eax
        movl $_write_2_29, %eax
        # get procedure
        push %eax
        movl (_label_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_eax_1), %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_write_2_30:
        .long 0xbabb1e
        .long 17
        .ascii "read_char_pointer"
        .text
        push %eax
        movl $_write_2_30, %eax
        # get procedure
        push %eax
        movl (_indirect_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_eax_1), %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_write_2_31:
        .long 0xbabb1e
        .long 29
        .ascii "read_char_buffer_fill_pointer"
        .text
        push %eax
        movl $_write_2_31, %eax
        # get procedure
        push %eax
        movl (_indirect_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_cmp_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_write_2_32:
        .long 0xbabb1e
        .long 23
        .ascii "return_char_from_buffer"
        .text
        push %eax
        movl $_write_2_32, %eax
        # get procedure
        push %eax
        movl (_jnz_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_eax_1), %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_write_2_33:
        .long 0xbabb1e
        .long 20
        .ascii "read_char_buffer_end"
        .text
        push %eax
        movl $_write_2_33, %eax
        # get procedure
        push %eax
        movl (_const_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_cmp_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_write_2_34:
        .long 0xbabb1e
        .long 17
        .ascii "call_read_syscall"
        .text
        push %eax
        movl $_write_2_34, %eax
        # get procedure
        push %eax
        movl (_jnz_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_eax_1), %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_write_2_35:
        .long 0xbabb1e
        .long 16
        .ascii "read_char_buffer"
        .text
        push %eax
        movl $_write_2_35, %eax
        # get procedure
        push %eax
        movl (_const_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_write_2_36:
        .long 0xbabb1e
        .long 17
        .ascii "read_char_pointer"
        .text
        push %eax
        movl $_write_2_36, %eax
        # get procedure
        push %eax
        movl (_indirect_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl (_eax_1), %eax
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_write_2_37:
        .long 0xbabb1e
        .long 29
        .ascii "read_char_buffer_fill_pointer"
        .text
        push %eax
        movl $_write_2_37, %eax
        # get procedure
        push %eax
        movl (_indirect_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl (_eax_1), %eax
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_write_2_38:
        .long 0xbabb1e
        .long 17
        .ascii "call_read_syscall"
        .text
        push %eax
        movl $_write_2_38, %eax
        # get procedure
        push %eax
        movl (_label_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_write_2_39:
        .long 0xbabb1e
        .long 32
        .ascii "__NR_read; see asm-i486/unistd.h"
        .text
        push %eax
        movl $_write_2_39, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_eax_1), %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_write_2_40:
        .long 0xbabb1e
        .long 1
        .ascii "3"
        .text
        push %eax
        movl $_write_2_40, %eax
        # get procedure
        push %eax
        movl (_const_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_write_2_41:
        .long 0xbabb1e
        .long 5
        .ascii "stdin"
        .text
        push %eax
        movl $_write_2_41, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_ebx_1), %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_write_2_42:
        .long 0xbabb1e
        .long 1
        .ascii "0"
        .text
        push %eax
        movl $_write_2_42, %eax
        # get procedure
        push %eax
        movl (_const_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_ecx_1), %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_write_2_43:
        .long 0xbabb1e
        .long 29
        .ascii "read_char_buffer_fill_pointer"
        .text
        push %eax
        movl $_write_2_43, %eax
        # get procedure
        push %eax
        movl (_indirect_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_edx_1), %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_write_2_44:
        .long 0xbabb1e
        .long 20
        .ascii "read_char_buffer_end"
        .text
        push %eax
        movl $_write_2_44, %eax
        # get procedure
        push %eax
        movl (_const_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_edx_1), %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_write_2_45:
        .long 0xbabb1e
        .long 29
        .ascii "read_char_buffer_fill_pointer"
        .text
        push %eax
        movl $_write_2_45, %eax
        # get procedure
        push %eax
        movl (_indirect_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_sub_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_syscall_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_eax_1), %eax
        push %eax
        movl (_eax_1), %eax
        # get procedure
        push %eax
        movl (_test_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_write_2_46:
        .long 0xbabb1e
        .long 10
        .ascii "return_eof"
        .text
        push %eax
        movl $_write_2_46, %eax
        # get procedure
        push %eax
        movl (_je_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_write_2_47:
        .long 0xbabb1e
        .long 17
        .ascii "report_read_error"
        .text
        push %eax
        movl $_write_2_47, %eax
        # get procedure
        push %eax
        movl (_jl_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_write_2_48:
        .long 0xbabb1e
        .long 29
        .ascii "read_char_buffer_fill_pointer"
        .text
        push %eax
        movl $_write_2_48, %eax
        # get procedure
        push %eax
        movl (_indirect_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl (_eax_1), %eax
        # get procedure
        push %eax
        movl (_add_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_eax_1), %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_write_2_49:
        .long 0xbabb1e
        .long 17
        .ascii "read_char_pointer"
        .text
        push %eax
        movl $_write_2_49, %eax
        # get procedure
        push %eax
        movl (_indirect_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_write_2_50:
        .long 0xbabb1e
        .long 23
        .ascii "return_char_from_buffer"
        .text
        push %eax
        movl $_write_2_50, %eax
        # get procedure
        push %eax
        movl (_label_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_ebx_1), %eax
        push %eax
        movl (_eax_1), %eax
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_ebx_1), %eax
        # get procedure
        push %eax
        movl (_inc_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_write_2_51:
        .long 0xbabb1e
        .long 17
        .ascii "read_char_pointer"
        .text
        push %eax
        movl $_write_2_51, %eax
        # get procedure
        push %eax
        movl (_indirect_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl (_ebx_1), %eax
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_tos_1), %eax
        push %eax
        movl (_eax_1), %eax
        # get procedure
        push %eax
        movl (_indirect_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_movzbl_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_tos_1), %eax
        # get procedure
        push %eax
        movl (_check_array_bounds_29), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_write_2_52:
        .long 0xbabb1e
        .long 16
        .ascii "read_char_return"
        .text
        push %eax
        movl $_write_2_52, %eax
        # get procedure
        push %eax
        movl (_jmp_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_write_2_53:
        .long 0xbabb1e
        .long 10
        .ascii "return_eof"
        .text
        push %eax
        movl $_write_2_53, %eax
        # get procedure
        push %eax
        movl (_label_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_tos_1), %eax
        push %eax
        movl (_write_2_54), %eax
        # get procedure
        push %eax
        movl (_const_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_write_2_55:
        .long 0xbabb1e
        .long 16
        .ascii "read_char_return"
        .text
        push %eax
        movl $_write_2_55, %eax
        # get procedure
        push %eax
        movl (_label_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _write_2_17, .-_write_2_17
_write_2_15:
        push %eax
        movl $_write_2_16, %eax
        push %eax
        movl $2 + 256<<2, %eax
        push %eax
        movl $_write_2_56, %eax
        # get procedure
        push %eax
        movl (_define_global_procedure_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_write_2_57:
        .long 0xbabb1e
        .long 19
        .ascii "read error on stdin"
        .text
        push %eax
        movl $_write_2_57, %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_write_2_58:
        .long 0xbabb1e
        .long 17
        .ascii "report_read_error"
        .text
        push %eax
        movl $_write_2_58, %eax
        # get procedure
        push %eax
        movl (_define_error_routine_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        # jump past the body of the lambda
        jmp _write_2_59
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_write_2_60:
        .long 0xca11ab1e
        .long _write_2_61
        .long 0
        .text
        .type _write_2_61, @function
_write_2_61:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $0, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl $1 + 0<<2, %eax
        # get procedure
        push %eax
        movl (_compile_tag_check_procedure_5), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_define_error_routine_17), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_write_2_62:
        .long 0xbabb1e
        .long 12
        .ascii "fd 2: stderr"
        .text
        push %eax
        movl $_write_2_62, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_ebx_1), %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_write_2_63:
        .long 0xbabb1e
        .long 1
        .ascii "2"
        .text
        push %eax
        movl $_write_2_63, %eax
        # get procedure
        push %eax
        movl (_const_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_define_error_routine_20), %eax
        # apply procedure
        # Tail call; nargs = 0
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea -4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _write_2_61, .-_write_2_61
_write_2_59:
        push %eax
        movl $_write_2_60, %eax
        push %eax
        movl $1 + 1<<2, %eax
        push %eax
        movl $_write_2_64, %eax
        # get procedure
        push %eax
        movl (_define_global_procedure_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        call *%ebx
        pop %eax
        # jump past the body of the lambda
        jmp _write_2_65
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_write_2_66:
        .long 0xca11ab1e
        .long _write_2_67
        .long 0
        .text
        .type _write_2_67, @function
_write_2_67:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $0, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl $1 + 0<<2, %eax
        # get procedure
        push %eax
        movl (_compile_tag_check_procedure_5), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_extract_string_7), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_tos_1), %eax
        # get procedure
        push %eax
        movl (_extract_string_9), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_ebx_1), %eax
        push %eax
        movl (_tos_1), %eax
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_eax_1), %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_write_2_68:
        .long 0xbabb1e
        .long 1
        .ascii "1"
        .text
        push %eax
        movl $_write_2_68, %eax
        # get procedure
        push %eax
        movl (_const_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_syscall_1), %eax
        # apply procedure
        # Tail call; nargs = 0
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea -4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _write_2_67, .-_write_2_67
_write_2_65:
        push %eax
        movl $_write_2_66, %eax
        push %eax
        movl $1 + 1<<2, %eax
        push %eax
        movl $_write_2_69, %eax
        # get procedure
        push %eax
        movl (_define_global_procedure_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        call *%ebx
        pop %eax
        .section .data
_tagshift_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _tagshift_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_tagshift_3:
        .long 0xca11ab1e
        .long _tagshift_4
        .long 0
        .text
        .type _tagshift_4, @function
_tagshift_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_tagshift_5:
        .long 0xbabb1e
        .long 3
        .ascii "<<2"
        .text
        push %eax
        movl $_tagshift_5, %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_number_Gtstring_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_list_1), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _tagshift_4, .-_tagshift_4
_tagshift_2:
        push %eax
        movl $_tagshift_3, %eax
        # initialize global variable with value
        movl %eax, (_tagshift_1)
        pop %eax
        .section .data
_integer_tag_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_integer_tag_2:
        .long 0xbabb1e
        .long 1
        .ascii "1"
        .text
        push %eax
        movl $_integer_tag_2, %eax
        # initialize global variable with value
        movl %eax, (_integer_tag_1)
        pop %eax
        # jump past the body of the lambda
        jmp _integer_tag_3
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_integer_tag_4:
        .long 0xca11ab1e
        .long _integer_tag_5
        .long 0
        .text
        .type _integer_tag_5, @function
_integer_tag_5:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $0, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl (_integer_tag_1), %eax
        # get procedure
        push %eax
        movl (_compile_tag_check_procedure_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _integer_tag_5, .-_integer_tag_5
_integer_tag_3:
        push %eax
        movl $_integer_tag_4, %eax
        push %eax
        movl $1 + 1<<2, %eax
        push %eax
        movl $_integer_tag_6, %eax
        # get procedure
        push %eax
        movl (_define_global_procedure_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        call *%ebx
        pop %eax
        .section .data
_tagged_integer_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _tagged_integer_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_tagged_integer_3:
        .long 0xca11ab1e
        .long _tagged_integer_4
        .long 0
        .text
        .type _tagged_integer_4, @function
_tagged_integer_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_tagshift_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_tagged_integer_5:
        .long 0xbabb1e
        .long 3
        .ascii " + "
        .text
        push %eax
        movl $_tagged_integer_5, %eax
        push %eax
        movl (_integer_tag_1), %eax
        # get procedure
        push %eax
        movl (_list_1), %eax
        # apply procedure
        # Tail call; nargs = 3
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 8(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push -8(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _tagged_integer_4, .-_tagged_integer_4
_tagged_integer_2:
        push %eax
        movl $_tagged_integer_3, %eax
        # initialize global variable with value
        movl %eax, (_tagged_integer_1)
        pop %eax
        # jump past the body of the lambda
        jmp _tagged_integer_6
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_tagged_integer_7:
        .long 0xca11ab1e
        .long _tagged_integer_8
        .long 0
        .text
        .type _tagged_integer_8, @function
_tagged_integer_8:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $0, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_tagged_integer_9:
        .long 0xbabb1e
        .long 14
        .ascii "ensure_integer"
        .text
        push %eax
        movl $_tagged_integer_9, %eax
        # get procedure
        push %eax
        movl (_label_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_tos_1), %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_tagged_integer_10:
        .long 0xbabb1e
        .long 1
        .ascii "1"
        .text
        push %eax
        movl $_tagged_integer_10, %eax
        # get procedure
        push %eax
        movl (_const_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_test_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_tagged_integer_11:
        .long 0xbabb1e
        .long 14
        .ascii "not_an_integer"
        .text
        push %eax
        movl $_tagged_integer_11, %eax
        # get procedure
        push %eax
        movl (_jz_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_tos_1), %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_tagged_integer_12:
        .long 0xbabb1e
        .long 1
        .ascii "2"
        .text
        push %eax
        movl $_tagged_integer_12, %eax
        # get procedure
        push %eax
        movl (_const_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_test_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_tagged_integer_13:
        .long 0xbabb1e
        .long 14
        .ascii "not_an_integer"
        .text
        push %eax
        movl $_tagged_integer_13, %eax
        # get procedure
        push %eax
        movl (_jnz_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_ret_1), %eax
        # apply procedure
        # Tail call; nargs = 0
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea -4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _tagged_integer_8, .-_tagged_integer_8
_tagged_integer_6:
        push %eax
        movl $_tagged_integer_7, %eax
        # get procedure
        push %eax
        movl (_add_to_header_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_tagged_integer_14:
        .long 0xbabb1e
        .long 14
        .ascii "not an integer"
        .text
        push %eax
        movl $_tagged_integer_14, %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_tagged_integer_15:
        .long 0xbabb1e
        .long 14
        .ascii "not_an_integer"
        .text
        push %eax
        movl $_tagged_integer_15, %eax
        # get procedure
        push %eax
        movl (_define_error_routine_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .data
_extract_string_7:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _ensure_integer_1
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_ensure_integer_2:
        .long 0xca11ab1e
        .long _ensure_integer_3
        .long 0
        .text
        .type _ensure_integer_3, @function
_ensure_integer_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $0, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_ensure_integer_4:
        .long 0xbabb1e
        .long 14
        .ascii "ensure_integer"
        .text
        push %eax
        movl $_ensure_integer_4, %eax
        # get procedure
        push %eax
        movl (_call_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _ensure_integer_3, .-_ensure_integer_3
_ensure_integer_1:
        push %eax
        movl $_ensure_integer_2, %eax
        # initialize global variable with value
        movl %eax, (_extract_string_7)
        pop %eax
        .section .data
_emit_malloc_n_4:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _assert_equal_1
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_assert_equal_2:
        .long 0xca11ab1e
        .long _assert_equal_3
        .long 0
        .text
        .type _assert_equal_3, @function
_assert_equal_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $2, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 4(%ebp), %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_equalP_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _assert_equal_4
        push %eax
        movl 4(%ebp), %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_list_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_assert_equal_6:
        .long 0xbabb1e
        .long 9
        .ascii "not equal"
        .text
        push %eax
        movl $_assert_equal_6, %eax
        # get procedure
        push %eax
        movl (_string_Gtnumber_8), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        jmp _assert_equal_5
_assert_equal_4:
        push %eax
        movl $2 + 258<<2, %eax
_assert_equal_5:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _assert_equal_3, .-_assert_equal_3
_assert_equal_1:
        push %eax
        movl $_assert_equal_2, %eax
        # initialize global variable with value
        movl %eax, (_emit_malloc_n_4)
        pop %eax
        .section .data
_integer_add_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _integer_add_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_integer_add_3:
        .long 0xca11ab1e
        .long _integer_add_4
        .long 0
        .text
        .type _integer_add_4, @function
_integer_add_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl $1 + 2<<2, %eax
        # get procedure
        push %eax
        movl (_emit_malloc_n_4), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_integer_add_5:
        .long 0xbabb1e
        .long 19
        .ascii "inlined integer add"
        .text
        push %eax
        movl $_integer_add_5, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_extract_string_7), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_swap_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_extract_string_7), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_ebx_1), %eax
        # get procedure
        push %eax
        movl (_asm_pop_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_tos_1), %eax
        push %eax
        movl (_ebx_1), %eax
        # get procedure
        push %eax
        movl (_add_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_tos_1), %eax
        # get procedure
        push %eax
        movl (_dec_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _integer_add_4, .-_integer_add_4
_integer_add_2:
        push %eax
        movl $_integer_add_3, %eax
        # initialize global variable with value
        movl %eax, (_integer_add_1)
        pop %eax
        .section .data
_integer_sub_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _integer_sub_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_integer_sub_3:
        .long 0xca11ab1e
        .long _integer_sub_4
        .long 0
        .text
        .type _integer_sub_4, @function
_integer_sub_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl $1 + 2<<2, %eax
        # get procedure
        push %eax
        movl (_emit_malloc_n_4), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_integer_sub_5:
        .long 0xbabb1e
        .long 24
        .ascii "inlined integer subtract"
        .text
        push %eax
        movl $_integer_sub_5, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_extract_string_7), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_swap_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_extract_string_7), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_nos_1), %eax
        push %eax
        movl (_tos_1), %eax
        # get procedure
        push %eax
        movl (_sub_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_pop_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_tos_1), %eax
        # get procedure
        push %eax
        movl (_inc_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _integer_sub_4, .-_integer_sub_4
_integer_sub_2:
        push %eax
        movl $_integer_sub_3, %eax
        # initialize global variable with value
        movl %eax, (_integer_sub_1)
        pop %eax
        .section .data
_inline_1Plus_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _inline_1Plus_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_inline_1Plus_3:
        .long 0xca11ab1e
        .long _inline_1Plus_4
        .long 0
        .text
        .type _inline_1Plus_4, @function
_inline_1Plus_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl $1 + 1<<2, %eax
        # get procedure
        push %eax
        movl (_emit_malloc_n_4), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_inline_1Plus_5:
        .long 0xbabb1e
        .long 2
        .ascii "1+"
        .text
        push %eax
        movl $_inline_1Plus_5, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_extract_string_7), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_tos_1), %eax
        push %eax
        movl $1 + 1<<2, %eax
        # get procedure
        push %eax
        movl (_tagshift_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_const_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_add_1), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _inline_1Plus_4, .-_inline_1Plus_4
_inline_1Plus_2:
        push %eax
        movl $_inline_1Plus_3, %eax
        # initialize global variable with value
        movl %eax, (_inline_1Plus_1)
        pop %eax
        .section .data
_inline_1__1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _inline_1__2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_inline_1__3:
        .long 0xca11ab1e
        .long _inline_1__4
        .long 0
        .text
        .type _inline_1__4, @function
_inline_1__4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl $1 + 1<<2, %eax
        # get procedure
        push %eax
        movl (_emit_malloc_n_4), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_extract_string_7), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_tos_1), %eax
        push %eax
        movl $1 + -1<<2, %eax
        # get procedure
        push %eax
        movl (_tagshift_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_const_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_add_1), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _inline_1__4, .-_inline_1__4
_inline_1__2:
        push %eax
        movl $_inline_1__3, %eax
        # initialize global variable with value
        movl %eax, (_inline_1__1)
        pop %eax
        .section .data
_inline_string_length_6:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _native_to_scheme_integer_1
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_native_to_scheme_integer_2:
        .long 0xca11ab1e
        .long _native_to_scheme_integer_3
        .long 0
        .text
        .type _native_to_scheme_integer_3, @function
_native_to_scheme_integer_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_sal_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_sal_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_inc_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _native_to_scheme_integer_3, .-_native_to_scheme_integer_3
_native_to_scheme_integer_1:
        push %eax
        movl $_native_to_scheme_integer_2, %eax
        # initialize global variable with value
        movl %eax, (_inline_string_length_6)
        pop %eax
        .section .data
_extract_string_9:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _scheme_to_native_integer_1
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_scheme_to_native_integer_2:
        .long 0xca11ab1e
        .long _scheme_to_native_integer_3
        .long 0
        .text
        .type _scheme_to_native_integer_3, @function
_scheme_to_native_integer_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_sar_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_sar_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _scheme_to_native_integer_3, .-_scheme_to_native_integer_3
_scheme_to_native_integer_1:
        push %eax
        movl $_scheme_to_native_integer_2, %eax
        # initialize global variable with value
        movl %eax, (_extract_string_9)
        pop %eax
        .section .data
_emit_division_code_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _emit_division_code_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_emit_division_code_3:
        .long 0xca11ab1e
        .long _emit_division_code_4
        .long 0
        .text
        .type _emit_division_code_4, @function
_emit_division_code_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $0, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl $1 + 1<<2, %eax
        # get procedure
        push %eax
        movl (_compile_tag_check_procedure_5), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_extract_string_7), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_emit_division_code_5:
        .long 0xbabb1e
        .long 44
        .ascii "fetch dividend second; idiv wants it in %eax"
        .text
        push %eax
        movl $_emit_division_code_5, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl $1 + 0<<2, %eax
        # get procedure
        push %eax
        movl (_compile_tag_check_procedure_5), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_extract_string_7), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_emit_division_code_6:
        .long 0xbabb1e
        .long 16
        .ascii "zero out the tag"
        .text
        push %eax
        movl $_emit_division_code_6, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_tos_1), %eax
        # get procedure
        push %eax
        movl (_dec_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_ebx_1), %eax
        # get procedure
        push %eax
        movl (_asm_pop_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_ebx_1), %eax
        # get procedure
        push %eax
        movl (_dec_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_emit_division_code_7:
        .long 0xbabb1e
        .long 33
        .ascii "zero the top half of the dividend"
        .text
        push %eax
        movl $_emit_division_code_7, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_edx_1), %eax
        push %eax
        movl (_edx_1), %eax
        # get procedure
        push %eax
        movl (_sub_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_ebx_1), %eax
        # get procedure
        push %eax
        movl (_idiv_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _emit_division_code_4, .-_emit_division_code_4
_emit_division_code_2:
        push %eax
        movl $_emit_division_code_3, %eax
        # initialize global variable with value
        movl %eax, (_emit_division_code_1)
        pop %eax
        # jump past the body of the lambda
        jmp _emit_division_code_8
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_emit_division_code_9:
        .long 0xca11ab1e
        .long _emit_division_code_10
        .long 0
        .text
        .type _emit_division_code_10, @function
_emit_division_code_10:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $0, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # get procedure
        push %eax
        movl (_emit_division_code_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_emit_division_code_11:
        .long 0xbabb1e
        .long 26
        .ascii "remainder (<<2) is in %edx"
        .text
        push %eax
        movl $_emit_division_code_11, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_tos_1), %eax
        push %eax
        movl (_edx_1), %eax
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_emit_division_code_12:
        .long 0xbabb1e
        .long 16
        .ascii "put the tag back"
        .text
        push %eax
        movl $_emit_division_code_12, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_tos_1), %eax
        # get procedure
        push %eax
        movl (_inc_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _emit_division_code_10, .-_emit_division_code_10
_emit_division_code_8:
        push %eax
        movl $_emit_division_code_9, %eax
        push %eax
        movl $1 + 2<<2, %eax
        push %eax
        movl $_emit_division_code_13, %eax
        # get procedure
        push %eax
        movl (_define_global_procedure_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        call *%ebx
        pop %eax
        # jump past the body of the lambda
        jmp _emit_division_code_14
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_emit_division_code_15:
        .long 0xca11ab1e
        .long _emit_division_code_16
        .long 0
        .text
        .type _emit_division_code_16, @function
_emit_division_code_16:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $0, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # get procedure
        push %eax
        movl (_emit_division_code_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_tos_1), %eax
        # get procedure
        push %eax
        movl (_inline_string_length_6), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _emit_division_code_16, .-_emit_division_code_16
_emit_division_code_14:
        push %eax
        movl $_emit_division_code_15, %eax
        push %eax
        movl $1 + 2<<2, %eax
        push %eax
        movl $_emit_division_code_17, %eax
        # get procedure
        push %eax
        movl (_define_global_procedure_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        call *%ebx
        pop %eax
        # jump past the body of the lambda
        jmp _emit_division_code_18
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_emit_division_code_19:
        .long 0xca11ab1e
        .long _emit_division_code_20
        .long 0
        .text
        .type _emit_division_code_20, @function
_emit_division_code_20:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $0, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_emit_division_code_21:
        .long 0xbabb1e
        .long 42
        .ascii "procedure <: (< x y) returns true if x < y"
        .text
        push %eax
        movl $_emit_division_code_21, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl $1 + 0<<2, %eax
        # get procedure
        push %eax
        movl (_compile_tag_check_procedure_5), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_extract_string_7), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        pop %eax
        push %eax
        movl $1 + 1<<2, %eax
        # get procedure
        push %eax
        movl (_compile_tag_check_procedure_5), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_extract_string_7), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_nos_1), %eax
        push %eax
        movl (_tos_1), %eax
        # get procedure
        push %eax
        movl (_cmp_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_pop_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_emit_division_code_22:
        .long 0xbabb1e
        .long 11
        .ascii "return_true"
        .text
        push %eax
        movl $_emit_division_code_22, %eax
        # get procedure
        push %eax
        movl (_jl_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_emit_division_code_23:
        .long 0xbabb1e
        .long 12
        .ascii "return_false"
        .text
        push %eax
        movl $_emit_division_code_23, %eax
        # get procedure
        push %eax
        movl (_jmp_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _emit_division_code_20, .-_emit_division_code_20
_emit_division_code_18:
        push %eax
        movl $_emit_division_code_19, %eax
        push %eax
        movl $1 + 2<<2, %eax
        push %eax
        movl $_emit_division_code_24, %eax
        # get procedure
        push %eax
        movl (_define_global_procedure_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        call *%ebx
        pop %eax
        .section .data
_enum_tag_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_enum_tag_2:
        .long 0xbabb1e
        .long 1
        .ascii "2"
        .text
        push %eax
        movl $_enum_tag_2, %eax
        # initialize global variable with value
        movl %eax, (_enum_tag_1)
        pop %eax
        .section .data
_enum_value_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _enum_value_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_enum_value_3:
        .long 0xca11ab1e
        .long _enum_value_4
        .long 0
        .text
        .type _enum_value_4, @function
_enum_value_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_tagshift_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_enum_value_5:
        .long 0xbabb1e
        .long 3
        .ascii " + "
        .text
        push %eax
        movl $_enum_value_5, %eax
        push %eax
        movl (_enum_tag_1), %eax
        # get procedure
        push %eax
        movl (_list_1), %eax
        # apply procedure
        # Tail call; nargs = 3
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 8(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push -8(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _enum_value_4, .-_enum_value_4
_enum_value_2:
        push %eax
        movl $_enum_value_3, %eax
        # initialize global variable with value
        movl %eax, (_enum_value_1)
        pop %eax
        .section .data
_copy_args_12:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        push %eax
        movl $1 + 256<<2, %eax
        # get procedure
        push %eax
        movl (_enum_value_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # initialize global variable with value
        movl %eax, (_copy_args_12)
        pop %eax
        .section .data
_call_ensure_magic_routine_15:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        push %eax
        movl $1 + 257<<2, %eax
        # get procedure
        push %eax
        movl (_enum_value_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # initialize global variable with value
        movl %eax, (_call_ensure_magic_routine_15)
        pop %eax
        .section .data
_call_ensure_magic_routine_17:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        push %eax
        movl $1 + 258<<2, %eax
        # get procedure
        push %eax
        movl (_enum_value_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # initialize global variable with value
        movl %eax, (_call_ensure_magic_routine_17)
        pop %eax
        .section .data
_write_2_54:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        push %eax
        movl $1 + 259<<2, %eax
        # get procedure
        push %eax
        movl (_enum_value_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # initialize global variable with value
        movl %eax, (_write_2_54)
        pop %eax
        # jump past the body of the lambda
        jmp _eof_value_1
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_eof_value_2:
        .long 0xca11ab1e
        .long _eof_value_3
        .long 0
        .text
        .type _eof_value_3, @function
_eof_value_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $0, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl $1 + 0<<2, %eax
        # get procedure
        push %eax
        movl (_compile_tag_check_procedure_5), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_tos_1), %eax
        push %eax
        movl (_write_2_54), %eax
        # get procedure
        push %eax
        movl (_const_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_cmp_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_eof_value_4:
        .long 0xbabb1e
        .long 11
        .ascii "return_true"
        .text
        push %eax
        movl $_eof_value_4, %eax
        # get procedure
        push %eax
        movl (_je_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_eof_value_5:
        .long 0xbabb1e
        .long 12
        .ascii "return_false"
        .text
        push %eax
        movl $_eof_value_5, %eax
        # get procedure
        push %eax
        movl (_jmp_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _eof_value_3, .-_eof_value_3
_eof_value_1:
        push %eax
        movl $_eof_value_2, %eax
        push %eax
        movl $1 + 1<<2, %eax
        push %eax
        movl $_eof_value_6, %eax
        # get procedure
        push %eax
        movl (_define_global_procedure_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        call *%ebx
        pop %eax
        .section .data
_jump_if_not_char_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _jump_if_not_char_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_jump_if_not_char_3:
        .long 0xca11ab1e
        .long _jump_if_not_char_4
        .long 0
        .text
        .type _jump_if_not_char_4, @function
_jump_if_not_char_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl (_tos_1), %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_jump_if_not_char_5:
        .long 0xbabb1e
        .long 1
        .ascii "1"
        .text
        push %eax
        movl $_jump_if_not_char_5, %eax
        # get procedure
        push %eax
        movl (_const_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_test_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_jnz_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_tos_1), %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_jump_if_not_char_6:
        .long 0xbabb1e
        .long 1
        .ascii "2"
        .text
        push %eax
        movl $_jump_if_not_char_6, %eax
        # get procedure
        push %eax
        movl (_const_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_test_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_jz_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_tos_1), %eax
        push %eax
        movl $1 + 256<<2, %eax
        # get procedure
        push %eax
        movl (_enum_value_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_const_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_cmp_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_jnb_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _jump_if_not_char_4, .-_jump_if_not_char_4
_jump_if_not_char_2:
        push %eax
        movl $_jump_if_not_char_3, %eax
        # initialize global variable with value
        movl %eax, (_jump_if_not_char_1)
        pop %eax
        .section .data
_check_array_bounds_19:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _ensure_character_1
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_ensure_character_2:
        .long 0xca11ab1e
        .long _ensure_character_3
        .long 0
        .text
        .type _ensure_character_3, @function
_ensure_character_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $0, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_ensure_character_4:
        .long 0xbabb1e
        .long 15
        .ascii "not_a_character"
        .text
        push %eax
        movl $_ensure_character_4, %eax
        # get procedure
        push %eax
        movl (_jump_if_not_char_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _ensure_character_3, .-_ensure_character_3
_ensure_character_1:
        push %eax
        movl $_ensure_character_2, %eax
        # initialize global variable with value
        movl %eax, (_check_array_bounds_19)
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_ensure_character_5:
        .long 0xbabb1e
        .long 15
        .ascii "not a character"
        .text
        push %eax
        movl $_ensure_character_5, %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_ensure_character_6:
        .long 0xbabb1e
        .long 15
        .ascii "not_a_character"
        .text
        push %eax
        movl $_ensure_character_6, %eax
        # get procedure
        push %eax
        movl (_define_error_routine_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        # jump past the body of the lambda
        jmp _ensure_character_7
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_ensure_character_8:
        .long 0xca11ab1e
        .long _ensure_character_9
        .long 0
        .text
        .type _ensure_character_9, @function
_ensure_character_9:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $0, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl $1 + 0<<2, %eax
        # get procedure
        push %eax
        movl (_compile_tag_check_procedure_5), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_ensure_character_10:
        .long 0xbabb1e
        .long 12
        .ascii "return_false"
        .text
        push %eax
        movl $_ensure_character_10, %eax
        # get procedure
        push %eax
        movl (_jump_if_not_char_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_ensure_character_11:
        .long 0xbabb1e
        .long 11
        .ascii "return_true"
        .text
        push %eax
        movl $_ensure_character_11, %eax
        # get procedure
        push %eax
        movl (_jmp_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _ensure_character_9, .-_ensure_character_9
_ensure_character_7:
        push %eax
        movl $_ensure_character_8, %eax
        push %eax
        movl $1 + 1<<2, %eax
        push %eax
        movl $_ensure_character_12, %eax
        # get procedure
        push %eax
        movl (_define_global_procedure_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        call *%ebx
        pop %eax
        .section .data
_check_array_bounds_20:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        push %eax
        movl (_extract_string_9), %eax
        # initialize global variable with value
        movl %eax, (_check_array_bounds_20)
        pop %eax
        .section .data
_check_array_bounds_29:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _native_to_scheme_character_1
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_native_to_scheme_character_2:
        .long 0xca11ab1e
        .long _native_to_scheme_character_3
        .long 0
        .text
        .type _native_to_scheme_character_3, @function
_native_to_scheme_character_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_sal_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_inc_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_sal_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _native_to_scheme_character_3, .-_native_to_scheme_character_3
_native_to_scheme_character_1:
        push %eax
        movl $_native_to_scheme_character_2, %eax
        # initialize global variable with value
        movl %eax, (_check_array_bounds_29)
        pop %eax
        .section .data
_tagged_character_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _tagged_character_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_tagged_character_3:
        .long 0xca11ab1e
        .long _tagged_character_4
        .long 0
        .text
        .type _tagged_character_4, @function
_tagged_character_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_tagged_character_5:
        .long 0xbabb1e
        .long 3
        .ascii "<<2"
        .text
        push %eax
        movl $_tagged_character_5, %eax
        push %eax
        movl 0(%ebp), %eax
        test $1, %eax
        jnz not_a_character
        test $2, %eax
        je not_a_character
        cmpl $2 + 256<<2, %eax
        jnb not_a_character
        dec %eax
        # get procedure
        push %eax
        movl (_number_Gtstring_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_tagged_character_6:
        .long 0xbabb1e
        .long 3
        .ascii " + "
        .text
        push %eax
        movl $_tagged_character_6, %eax
        push %eax
        movl (_enum_tag_1), %eax
        # get procedure
        push %eax
        movl (_list_1), %eax
        # apply procedure
        # Tail call; nargs = 4
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 12(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push -8(%ebx)
        push -12(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $4, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _tagged_character_4, .-_tagged_character_4
_tagged_character_2:
        push %eax
        movl $_tagged_character_3, %eax
        # initialize global variable with value
        movl %eax, (_tagged_character_1)
        pop %eax
        .section .data
_inline_integer_Gtchar_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _inline_integer_Gtchar_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_inline_integer_Gtchar_3:
        .long 0xca11ab1e
        .long _inline_integer_Gtchar_4
        .long 0
        .text
        .type _inline_integer_Gtchar_4, @function
_inline_integer_Gtchar_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl $1 + 1<<2, %eax
        # get procedure
        push %eax
        movl (_emit_malloc_n_4), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_tos_1), %eax
        # get procedure
        push %eax
        movl (_inc_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_check_array_bounds_19), %eax
        # apply procedure
        # Tail call; nargs = 0
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea -4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _inline_integer_Gtchar_4, .-_inline_integer_Gtchar_4
_inline_integer_Gtchar_2:
        push %eax
        movl $_inline_integer_Gtchar_3, %eax
        # initialize global variable with value
        movl %eax, (_inline_integer_Gtchar_1)
        pop %eax
        .section .data
_inline_char_Gtinteger_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _inline_char_Gtinteger_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_inline_char_Gtinteger_3:
        .long 0xca11ab1e
        .long _inline_char_Gtinteger_4
        .long 0
        .text
        .type _inline_char_Gtinteger_4, @function
_inline_char_Gtinteger_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl $1 + 1<<2, %eax
        # get procedure
        push %eax
        movl (_emit_malloc_n_4), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_check_array_bounds_19), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_tos_1), %eax
        # get procedure
        push %eax
        movl (_dec_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _inline_char_Gtinteger_4, .-_inline_char_Gtinteger_4
_inline_char_Gtinteger_2:
        push %eax
        movl $_inline_char_Gtinteger_3, %eax
        # initialize global variable with value
        movl %eax, (_inline_char_Gtinteger_1)
        pop %eax
        .section .data
_global_variable_labels_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        push %eax
        movl $2 + 256<<2, %eax
        # initialize global variable with value
        movl %eax, (_global_variable_labels_1)
        pop %eax
        .section .data
_global_variables_defined_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        push %eax
        movl $2 + 256<<2, %eax
        # initialize global variable with value
        movl %eax, (_global_variables_defined_1)
        pop %eax
        .section .data
_allocate_new_global_variable_labelBang_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _allocate_new_global_variable_labelBang_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_allocate_new_global_variable_labelBang_3:
        .long 0xca11ab1e
        .long _allocate_new_global_variable_labelBang_4
        .long 0
        .text
        .type _allocate_new_global_variable_labelBang_4, @function
_allocate_new_global_variable_labelBang_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # move arg from stack to heap: name
        push %eax
        movl 0(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # get procedure
        push %eax
        movl (_new_label_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        # get procedure
        # jump past the body of the lambda
        jmp _allocate_new_global_variable_labelBang_5
        .text
        .type _allocate_new_global_variable_labelBang_6, @function
_allocate_new_global_variable_labelBang_6:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 name
        push 12(%eax)
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl (_global_variable_labels_1), %eax
        push %eax
        movl 0(%ebp), %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_cons_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_cons_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        movl %eax, (_global_variable_labels_1)
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _allocate_new_global_variable_labelBang_6, .-_allocate_new_global_variable_labelBang_6
_allocate_new_global_variable_labelBang_5:
        # allocate bytes: 16
        push %eax
        movl (arena_pointer), %eax
        add $16, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_allocate_new_global_variable_labelBang_6, 4(%ebx)
        movl $1, 8(%ebx)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _allocate_new_global_variable_labelBang_4, .-_allocate_new_global_variable_labelBang_4
_allocate_new_global_variable_labelBang_2:
        push %eax
        movl $_allocate_new_global_variable_labelBang_3, %eax
        # initialize global variable with value
        movl %eax, (_allocate_new_global_variable_labelBang_1)
        pop %eax
        .section .data
_global_variable_label_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _global_variable_label_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_global_variable_label_3:
        .long 0xca11ab1e
        .long _global_variable_label_4
        .long 0
        .text
        .type _global_variable_label_4, @function
_global_variable_label_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # move arg from stack to heap: name
        push %eax
        movl 0(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        push %eax
        movl (_global_variable_labels_1), %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_assq_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        # jump past the body of the lambda
        jmp _global_variable_label_5
        .text
        .type _global_variable_label_6, @function
_global_variable_label_6:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 name
        push 12(%eax)
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _global_variable_label_7
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_allocate_new_global_variable_labelBang_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        jmp _global_variable_label_8
_global_variable_label_7:
        push %eax
        movl 0(%ebp), %eax
        # inlined cdr
        call ensure_cons
        movl 8(%eax), %eax
_global_variable_label_8:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _global_variable_label_6, .-_global_variable_label_6
_global_variable_label_5:
        # allocate bytes: 16
        push %eax
        movl (arena_pointer), %eax
        add $16, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_global_variable_label_6, 4(%ebx)
        movl $1, 8(%ebx)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _global_variable_label_4, .-_global_variable_label_4
_global_variable_label_2:
        push %eax
        movl $_global_variable_label_3, %eax
        # initialize global variable with value
        movl %eax, (_global_variable_label_1)
        pop %eax
        .section .data
_heap_args_42:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _compile_global_variable_1
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_global_variable_2:
        .long 0xca11ab1e
        .long _compile_global_variable_3
        .long 0
        .text
        .type _compile_global_variable_3, @function
_compile_global_variable_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $2, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_global_variable_4:
        .long 0xbabb1e
        .long 5
        .ascii ".data"
        .text
        push %eax
        movl $_compile_global_variable_4, %eax
        # get procedure
        push %eax
        movl (_section_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_label_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl 4(%ebp), %eax
        # get procedure
        push %eax
        movl (_compile_word_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_text_1), %eax
        # apply procedure
        # Tail call; nargs = 0
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea -4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _compile_global_variable_3, .-_compile_global_variable_3
_compile_global_variable_1:
        push %eax
        movl $_compile_global_variable_2, %eax
        # initialize global variable with value
        movl %eax, (_heap_args_42)
        pop %eax
        .section .data
_define_global_procedure_9:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _define_global_variable_1
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_define_global_variable_2:
        .long 0xca11ab1e
        .long _define_global_variable_3
        .long 0
        .text
        .type _define_global_variable_3, @function
_define_global_variable_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $2, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl (_global_variables_defined_1), %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_assq_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _define_global_variable_4
        push %eax
        movl 4(%ebp), %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_global_variable_label_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_heap_args_42), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_global_variables_defined_1), %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_list_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_cons_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        movl %eax, (_global_variables_defined_1)
        jmp _define_global_variable_5
_define_global_variable_4:
        push %eax
        movl 4(%ebp), %eax
        # get procedure
        push %eax
        movl (_push_const_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_define_global_variable_6), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
_define_global_variable_5:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _define_global_variable_3, .-_define_global_variable_3
_define_global_variable_1:
        push %eax
        movl $_define_global_variable_2, %eax
        # initialize global variable with value
        movl %eax, (_define_global_procedure_9)
        pop %eax
        .section .data
_fetch_global_variable_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _fetch_global_variable_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_fetch_global_variable_3:
        .long 0xca11ab1e
        .long _fetch_global_variable_4
        .long 0
        .text
        .type _fetch_global_variable_4, @function
_fetch_global_variable_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl (_tos_1), %eax
        # get procedure
        push %eax
        movl (_asm_push_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_tos_1), %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_global_variable_label_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_indirect_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _fetch_global_variable_4, .-_fetch_global_variable_4
_fetch_global_variable_2:
        push %eax
        movl $_fetch_global_variable_3, %eax
        # initialize global variable with value
        movl %eax, (_fetch_global_variable_1)
        pop %eax
        .section .data
_define_global_variable_6:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _set_global_variable_1
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_global_variable_2:
        .long 0xca11ab1e
        .long _set_global_variable_3
        .long 0
        .text
        .type _set_global_variable_3, @function
_set_global_variable_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_global_variable_label_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_indirect_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl (_tos_1), %eax
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _set_global_variable_3, .-_set_global_variable_3
_set_global_variable_1:
        push %eax
        movl $_set_global_variable_2, %eax
        # initialize global variable with value
        movl %eax, (_define_global_variable_6)
        pop %eax
        .section .data
_undefined_global_variables_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _undefined_global_variables_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_undefined_global_variables_3:
        .long 0xca11ab1e
        .long _undefined_global_variables_4
        .long 0
        .text
        .type _undefined_global_variables_4, @function
_undefined_global_variables_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $0, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl (_global_variable_labels_1), %eax
        # jump past the body of the lambda
        jmp _undefined_global_variables_5
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_undefined_global_variables_6:
        .long 0xca11ab1e
        .long _undefined_global_variables_7
        .long 0
        .text
        .type _undefined_global_variables_7, @function
_undefined_global_variables_7:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl (_global_variables_defined_1), %eax
        push %eax
        movl 0(%ebp), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_assq_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_not_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _undefined_global_variables_7, .-_undefined_global_variables_7
_undefined_global_variables_5:
        push %eax
        movl $_undefined_global_variables_6, %eax
        # get procedure
        push %eax
        movl (_filter_1), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _undefined_global_variables_4, .-_undefined_global_variables_4
_undefined_global_variables_2:
        push %eax
        movl $_undefined_global_variables_3, %eax
        # initialize global variable with value
        movl %eax, (_undefined_global_variables_1)
        pop %eax
        .section .data
_assert_no_undefined_global_variables_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _assert_no_undefined_global_variables_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_assert_no_undefined_global_variables_3:
        .long 0xca11ab1e
        .long _assert_no_undefined_global_variables_4
        .long 0
        .text
        .type _assert_no_undefined_global_variables_4, @function
_assert_no_undefined_global_variables_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $0, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        # get procedure
        push %eax
        movl (_undefined_global_variables_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        push %eax
        movl $2 + 256<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _assert_no_undefined_global_variables_5
        push %eax
        movl $2 + 257<<2, %eax
        jmp _assert_no_undefined_global_variables_6
_assert_no_undefined_global_variables_5:
        # get procedure
        push %eax
        movl (_undefined_global_variables_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_assert_no_undefined_global_variables_7:
        .long 0xbabb1e
        .long 23
        .ascii "error: undefined global"
        .text
        push %eax
        movl $_assert_no_undefined_global_variables_7, %eax
        # get procedure
        push %eax
        movl (_string_Gtnumber_8), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
_assert_no_undefined_global_variables_6:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _assert_no_undefined_global_variables_4, .-_assert_no_undefined_global_variables_4
_assert_no_undefined_global_variables_2:
        push %eax
        movl $_assert_no_undefined_global_variables_3, %eax
        # initialize global variable with value
        movl %eax, (_assert_no_undefined_global_variables_1)
        pop %eax
        .section .data
_compile_quote_3_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _compile_quote_3_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_quote_3_3:
        .long 0xca11ab1e
        .long _compile_quote_3_4
        .long 0
        .text
        .type _compile_quote_3_4, @function
_compile_quote_3_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $2, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # move arg from stack to heap: expr
        push %eax
        movl 0(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # move arg from stack to heap: labelname
        push %eax
        movl 4(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # %ifeq
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_stringP_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _compile_quote_3_5
        # %ifeq
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_pairP_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _compile_quote_3_7
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_quote_3_9:
        .long 0xbabb1e
        .long 10
        .ascii "unquotable"
        .text
        push %eax
        movl $_compile_quote_3_9, %eax
        # get procedure
        push %eax
        movl (_string_Gtnumber_8), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        jmp _compile_quote_3_8
_compile_quote_3_7:
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_emit_symbols_from_10), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        # jump past the body of the lambda
        jmp _compile_quote_3_10
        .text
        .type _compile_quote_3_11, @function
_compile_quote_3_11:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 expr
        push 12(%eax)
        # fetch artifact from closure: 1 labelname
        push 16(%eax)
        # discarding useless value in %eax
        pop %eax
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # inlined cdr
        call ensure_cons
        movl 8(%eax), %eax
        # get procedure
        push %eax
        movl (_emit_symbols_from_10), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_compile_cons_1), %eax
        # apply procedure
        # Tail call; nargs = 3
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 8(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push -8(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _compile_quote_3_11, .-_compile_quote_3_11
_compile_quote_3_10:
        # allocate bytes: 20
        push %eax
        movl (arena_pointer), %eax
        add $20, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_compile_quote_3_11, 4(%ebx)
        movl $2, 8(%ebx)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        movl %eax, 16(%ebx)
        pop %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
_compile_quote_3_8:
        jmp _compile_quote_3_6
_compile_quote_3_5:
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_constant_string_2_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
_compile_quote_3_6:
        pop %eax
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _compile_quote_3_4, .-_compile_quote_3_4
_compile_quote_3_2:
        push %eax
        movl $_compile_quote_3_3, %eax
        # initialize global variable with value
        movl %eax, (_compile_quote_3_1)
        pop %eax
        .section .data
_emit_symbols_from_10:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _compile_constant_1
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_constant_2:
        .long 0xca11ab1e
        .long _compile_constant_3
        .long 0
        .text
        .type _compile_constant_3, @function
_compile_constant_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl $2 + 256<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _compile_constant_4
        push %eax
        movl (_copy_args_12), %eax
        jmp _compile_constant_5
_compile_constant_4:
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_symbolP_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _compile_constant_6
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_integerP_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _compile_constant_8
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_booleanP_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _compile_constant_10
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_charP_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _compile_constant_12
        # get procedure
        push %eax
        movl (_new_label_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_compile_quote_3_1), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        jmp _compile_constant_13
_compile_constant_12:
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_tagged_character_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
_compile_constant_13:
        jmp _compile_constant_11
_compile_constant_10:
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _compile_constant_14
        push %eax
        movl (_call_ensure_magic_routine_17), %eax
        jmp _compile_constant_15
_compile_constant_14:
        push %eax
        movl (_call_ensure_magic_routine_15), %eax
_compile_constant_15:
_compile_constant_11:
        jmp _compile_constant_9
_compile_constant_8:
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_tagged_integer_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
_compile_constant_9:
        jmp _compile_constant_7
_compile_constant_6:
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_symbol_value_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
_compile_constant_7:
_compile_constant_5:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _compile_constant_3, .-_compile_constant_3
_compile_constant_1:
        push %eax
        movl $_compile_constant_2, %eax
        # initialize global variable with value
        movl %eax, (_emit_symbols_from_10)
        pop %eax
        .section .data
_compile_quotable_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _compile_quotable_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_quotable_3:
        .long 0xca11ab1e
        .long _compile_quotable_4
        .long 0
        .text
        .type _compile_quotable_4, @function
_compile_quotable_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $2, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_emit_symbols_from_10), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_push_const_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _compile_quotable_4, .-_compile_quotable_4
_compile_quotable_2:
        push %eax
        movl $_compile_quotable_3, %eax
        # initialize global variable with value
        movl %eax, (_compile_quotable_1)
        pop %eax
        .section .data
_fetch_heap_var_pointer_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _fetch_heap_var_pointer_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_fetch_heap_var_pointer_3:
        .long 0xca11ab1e
        .long _fetch_heap_var_pointer_4
        .long 0
        .text
        .type _fetch_heap_var_pointer_4, @function
_fetch_heap_var_pointer_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_number_Gtstring_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_fetch_heap_var_pointer_5:
        .long 0xbabb1e
        .long 26
        .ascii "fetching heap var pointer "
        .text
        push %eax
        movl $_fetch_heap_var_pointer_5, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_dup_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_tos_1), %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_quadruple_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $1 + -16<<2, %eax
        # inlined integer subtract
        call ensure_integer
        xchg %eax, (%esp)
        call ensure_integer
        sub %eax, (%esp)
        pop %eax
        inc %eax
        push %eax
        movl (_ebp_1), %eax
        # get procedure
        push %eax
        movl (_offset_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _fetch_heap_var_pointer_4, .-_fetch_heap_var_pointer_4
_fetch_heap_var_pointer_2:
        push %eax
        movl $_fetch_heap_var_pointer_3, %eax
        # get procedure
        push %eax
        movl (_memo1_asm_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # initialize global variable with value
        movl %eax, (_fetch_heap_var_pointer_1)
        pop %eax
        .section .data
_ensure_heap_var_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _ensure_heap_var_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_ensure_heap_var_3:
        .long 0xca11ab1e
        .long _ensure_heap_var_4
        .long 0
        .text
        .type _ensure_heap_var_4, @function
_ensure_heap_var_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $0, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl $2 + 258<<2, %eax
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _ensure_heap_var_4, .-_ensure_heap_var_4
_ensure_heap_var_2:
        push %eax
        movl $_ensure_heap_var_3, %eax
        # initialize global variable with value
        movl %eax, (_ensure_heap_var_1)
        pop %eax
        .section .data
_fetch_heap_var_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _fetch_heap_var_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_fetch_heap_var_3:
        .long 0xca11ab1e
        .long _fetch_heap_var_4
        .long 0
        .text
        .type _fetch_heap_var_4, @function
_fetch_heap_var_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_fetch_heap_var_pointer_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_fetch_heap_var_5:
        .long 0xbabb1e
        .long 33
        .ascii "fetch current value from the heap"
        .text
        push %eax
        movl $_fetch_heap_var_5, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_ensure_heap_var_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_tos_1), %eax
        push %eax
        movl $1 + 4<<2, %eax
        push %eax
        movl (_tos_1), %eax
        # get procedure
        push %eax
        movl (_offset_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _fetch_heap_var_4, .-_fetch_heap_var_4
_fetch_heap_var_2:
        push %eax
        movl $_fetch_heap_var_3, %eax
        # initialize global variable with value
        movl %eax, (_fetch_heap_var_1)
        pop %eax
        .section .data
_set_heap_var_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _set_heap_var_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_heap_var_3:
        .long 0xca11ab1e
        .long _set_heap_var_4
        .long 0
        .text
        .type _set_heap_var_4, @function
_set_heap_var_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_fetch_heap_var_pointer_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_ensure_heap_var_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_ebx_1), %eax
        push %eax
        movl (_nos_1), %eax
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl $1 + 4<<2, %eax
        push %eax
        movl (_tos_1), %eax
        # get procedure
        push %eax
        movl (_offset_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        push %eax
        movl (_ebx_1), %eax
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_pop_1), %eax
        # apply procedure
        # Tail call; nargs = 0
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea -4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _set_heap_var_4, .-_set_heap_var_4
_set_heap_var_2:
        push %eax
        movl $_set_heap_var_3, %eax
        # get procedure
        push %eax
        movl (_memo1_asm_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # initialize global variable with value
        movl %eax, (_set_heap_var_1)
        pop %eax
        .section .data
_get_variable_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _get_variable_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_get_variable_3:
        .long 0xca11ab1e
        .long _get_variable_4
        .long 0
        .text
        .type _get_variable_4, @function
_get_variable_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # move arg from stack to heap: vardefn
        push %eax
        movl 0(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        # get procedure
        # jump past the body of the lambda
        jmp _get_variable_5
        .text
        .type _get_variable_6, @function
_get_variable_6:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 vardefn
        push 12(%eax)
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl $_get_variable_9, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _get_variable_7
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_cadr_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_compile_tag_check_procedure_5), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        jmp _get_variable_8
_get_variable_7:
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl $_compile_heap_args_2_11, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _get_variable_10
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_cadr_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_fetch_heap_var_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        jmp _get_variable_11
_get_variable_10:
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_get_variable_12:
        .long 0xbabb1e
        .long 19
        .ascii "unexpected var type"
        .text
        push %eax
        movl $_get_variable_12, %eax
        # get procedure
        push %eax
        movl (_string_Gtnumber_8), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
_get_variable_11:
_get_variable_8:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _get_variable_6, .-_get_variable_6
_get_variable_5:
        # allocate bytes: 16
        push %eax
        movl (arena_pointer), %eax
        add $16, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_get_variable_6, 4(%ebx)
        movl $1, 8(%ebx)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _get_variable_4, .-_get_variable_4
_get_variable_2:
        push %eax
        movl $_get_variable_3, %eax
        # initialize global variable with value
        movl %eax, (_get_variable_1)
        pop %eax
        .section .data
_set_variable_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _set_variable_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_variable_3:
        .long 0xca11ab1e
        .long _set_variable_4
        .long 0
        .text
        .type _set_variable_4, @function
_set_variable_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # move arg from stack to heap: vardefn
        push %eax
        movl 0(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        # get procedure
        # jump past the body of the lambda
        jmp _set_variable_5
        .text
        .type _set_variable_6, @function
_set_variable_6:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 vardefn
        push 12(%eax)
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl $_get_variable_9, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _set_variable_7
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_cadr_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_set_procedure_arg_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        jmp _set_variable_8
_set_variable_7:
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl $_compile_heap_args_2_11, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _set_variable_9
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_cadr_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_set_heap_var_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        jmp _set_variable_10
_set_variable_9:
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_variable_11:
        .long 0xbabb1e
        .long 19
        .ascii "unexpected var type"
        .text
        push %eax
        movl $_set_variable_11, %eax
        # get procedure
        push %eax
        movl (_string_Gtnumber_8), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
_set_variable_10:
_set_variable_8:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _set_variable_6, .-_set_variable_6
_set_variable_5:
        # allocate bytes: 16
        push %eax
        movl (arena_pointer), %eax
        add $16, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_set_variable_6, 4(%ebx)
        movl $1, 8(%ebx)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _set_variable_4, .-_set_variable_4
_set_variable_2:
        push %eax
        movl $_set_variable_3, %eax
        # initialize global variable with value
        movl %eax, (_set_variable_1)
        pop %eax
        .section .data
_store_closure_artifacts_6:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _get_heap_var_1
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_get_heap_var_2:
        .long 0xca11ab1e
        .long _get_heap_var_3
        .long 0
        .text
        .type _get_heap_var_3, @function
_get_heap_var_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_cadr_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $_compile_heap_args_2_11, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _get_heap_var_4
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_caddr_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_fetch_heap_var_pointer_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        jmp _get_heap_var_5
_get_heap_var_4:
        push %eax
        movl 0(%ebp), %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_get_heap_var_6:
        .long 0xbabb1e
        .long 41
        .ascii "trying to fetch the heap var pointer for "
        .text
        push %eax
        movl $_get_heap_var_6, %eax
        # get procedure
        push %eax
        movl (_string_Gtnumber_8), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
_get_heap_var_5:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _get_heap_var_3, .-_get_heap_var_3
_get_heap_var_1:
        push %eax
        movl $_get_heap_var_2, %eax
        # initialize global variable with value
        movl %eax, (_store_closure_artifacts_6)
        pop %eax
        .section .data
_compile_heap_args_2_9:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _compile_var_1
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_var_2:
        .long 0xca11ab1e
        .long _compile_var_3
        .long 0
        .text
        .type _compile_var_3, @function
_compile_var_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $2, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # move arg from stack to heap: var
        push %eax
        movl 0(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        push %eax
        movl 4(%ebp), %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_assq_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        # jump past the body of the lambda
        jmp _compile_var_4
        .text
        .type _compile_var_5, @function
_compile_var_5:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 var
        push 12(%eax)
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _compile_var_6
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_fetch_global_variable_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        jmp _compile_var_7
_compile_var_6:
        push %eax
        movl 0(%ebp), %eax
        # inlined cdr
        call ensure_cons
        movl 8(%eax), %eax
        # get procedure
        push %eax
        movl (_get_variable_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
_compile_var_7:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _compile_var_5, .-_compile_var_5
_compile_var_4:
        # allocate bytes: 16
        push %eax
        movl (arena_pointer), %eax
        add $16, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_compile_var_5, 4(%ebx)
        movl $1, 8(%ebx)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _compile_var_3, .-_compile_var_3
_compile_var_1:
        push %eax
        movl $_compile_var_2, %eax
        # initialize global variable with value
        movl %eax, (_compile_heap_args_2_9)
        pop %eax
        .section .data
_compile_set_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _compile_set_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_set_3:
        .long 0xca11ab1e
        .long _compile_set_4
        .long 0
        .text
        .type _compile_set_4, @function
_compile_set_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $3, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # move arg from stack to heap: var
        push %eax
        movl 0(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        push %eax
        movl $2 + 258<<2, %eax
        push %eax
        movl 8(%ebp), %eax
        push %eax
        movl 4(%ebp), %eax
        # get procedure
        push %eax
        movl (_compile_set_5), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        call *%ebx
        pop %eax
        push %eax
        movl 8(%ebp), %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_assq_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        # jump past the body of the lambda
        jmp _compile_set_6
        .text
        .type _compile_set_7, @function
_compile_set_7:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 var
        push 12(%eax)
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _compile_set_8
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_define_global_variable_6), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        jmp _compile_set_9
_compile_set_8:
        push %eax
        movl 0(%ebp), %eax
        # inlined cdr
        call ensure_cons
        movl 8(%eax), %eax
        # get procedure
        push %eax
        movl (_set_variable_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
_compile_set_9:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _compile_set_7, .-_compile_set_7
_compile_set_6:
        # allocate bytes: 16
        push %eax
        movl (arena_pointer), %eax
        add $16, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_compile_set_7, 4(%ebx)
        movl $1, 8(%ebx)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _compile_set_4, .-_compile_set_4
_compile_set_2:
        push %eax
        movl $_compile_set_3, %eax
        # initialize global variable with value
        movl %eax, (_compile_set_1)
        pop %eax
        .section .data
_compile_discarding_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _compile_discarding_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_discarding_3:
        .long 0xca11ab1e
        .long _compile_discarding_4
        .long 0
        .text
        .type _compile_discarding_4, @function
_compile_discarding_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $2, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl $2 + 258<<2, %eax
        push %eax
        movl 4(%ebp), %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_compile_set_5), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_pop_1), %eax
        # apply procedure
        # Tail call; nargs = 0
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea -4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _compile_discarding_4, .-_compile_discarding_4
_compile_discarding_2:
        push %eax
        movl $_compile_discarding_3, %eax
        # initialize global variable with value
        movl %eax, (_compile_discarding_1)
        pop %eax
        .section .data
_lambda_environment_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _lambda_environment_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_lambda_environment_3:
        .long 0xca11ab1e
        .long _lambda_environment_4
        .long 0
        .text
        .type _lambda_environment_4, @function
_lambda_environment_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $3, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 4(%ebp), %eax
        push %eax
        movl $2 + 256<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _lambda_environment_5
        push %eax
        movl $2 + 256<<2, %eax
        jmp _lambda_environment_6
_lambda_environment_5:
        push %eax
        movl 8(%ebp), %eax
        # 1+
        call ensure_integer
        add $1<<2, %eax
        push %eax
        movl 4(%ebp), %eax
        # inlined cdr
        call ensure_cons
        movl 8(%eax), %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_lambda_environment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        call *%ebx
        push %eax
        movl 8(%ebp), %eax
        push %eax
        movl $_get_variable_9, %eax
        push %eax
        movl 4(%ebp), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_list_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_cons_2), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
_lambda_environment_6:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _lambda_environment_4, .-_lambda_environment_4
_lambda_environment_2:
        push %eax
        movl $_lambda_environment_3, %eax
        # initialize global variable with value
        movl %eax, (_lambda_environment_1)
        pop %eax
        .section .data
_compile_lambda_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _compile_lambda_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_lambda_3:
        .long 0xca11ab1e
        .long _compile_lambda_4
        .long 0
        .text
        .type _compile_lambda_4, @function
_compile_lambda_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $3, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # move arg from stack to heap: env
        push %eax
        movl 4(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        push %eax
        movl 0(%ebp), %eax
        # inlined cdr
        call ensure_cons
        movl 8(%eax), %eax
        push %eax
        movl 0(%ebp), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        # get procedure
        # jump past the body of the lambda
        jmp _compile_lambda_5
        .text
        .type _compile_lambda_6, @function
_compile_lambda_6:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $2, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 env
        push 12(%eax)
        # discarding useless value in %eax
        pop %eax
        # move arg from stack to heap: body
        push %eax
        movl 4(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_symbolP_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _compile_lambda_7
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_length_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        jmp _compile_lambda_8
_compile_lambda_7:
        push %eax
        movl $2 + 256<<2, %eax
_compile_lambda_8:
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_symbolP_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _compile_lambda_9
        push %eax
        movl 0(%ebp), %eax
        jmp _compile_lambda_10
_compile_lambda_9:
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_list_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
_compile_lambda_10:
        # get procedure
        # jump past the body of the lambda
        jmp _compile_lambda_11
        .text
        .type _compile_lambda_12, @function
_compile_lambda_12:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $2, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 env
        push 12(%eax)
        # fetch artifact from closure: 1 body
        push 16(%eax)
        # discarding useless value in %eax
        pop %eax
        # move arg from stack to heap: nargs
        push %eax
        movl 4(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_heap_args_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        push %eax
        movl $1 + 0<<2, %eax
        push %eax
        movl 0(%ebp), %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_lambda_environment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_new_label_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_artifacts_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        call *%ebx
        # get procedure
        # jump past the body of the lambda
        jmp _compile_lambda_13
        .text
        .type _compile_lambda_14, @function
_compile_lambda_14:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $4, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 nargs
        push 12(%eax)
        # fetch artifact from closure: 1 body
        push 16(%eax)
        # fetch artifact from closure: 2 env
        push 20(%eax)
        # discarding useless value in %eax
        pop %eax
        # move arg from stack to heap: artifacts
        push %eax
        movl 0(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # move arg from stack to heap: jumplabel
        push %eax
        movl 4(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # move arg from stack to heap: stack-env
        push %eax
        movl 8(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # move arg from stack to heap: heap-arg-list
        push %eax
        movl 12(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # get procedure
        push %eax
        movl (_new_label_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        # get procedure
        # jump past the body of the lambda
        jmp _compile_lambda_15
        .text
        .type _compile_lambda_16, @function
_compile_lambda_16:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 nargs
        push 12(%eax)
        # fetch artifact from closure: 1 body
        push 16(%eax)
        # fetch artifact from closure: 2 heap-arg-list
        push 20(%eax)
        # fetch artifact from closure: 3 stack-env
        push 24(%eax)
        # fetch artifact from closure: 4 jumplabel
        push 28(%eax)
        # fetch artifact from closure: 5 artifacts
        push 32(%eax)
        # fetch artifact from closure: 6 env
        push 36(%eax)
        # discarding useless value in %eax
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_lambda_17:
        .long 0xbabb1e
        .long 32
        .ascii "jump past the body of the lambda"
        .text
        push %eax
        movl $_compile_lambda_17, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        # fetching heap var pointer 4
        push %eax
        movl -32(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_jmp_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        # %ifeq
        # fetching heap var pointer 5
        push %eax
        movl -36(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        push %eax
        movl $2 + 256<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _compile_lambda_18
        # jump past the body of the lambda
        jmp _compile_lambda_20
        .text
        .type _compile_lambda_21, @function
_compile_lambda_21:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $0, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 body
        push 12(%eax)
        # fetch artifact from closure: 1 heap-arg-list
        push 16(%eax)
        # fetch artifact from closure: 2 stack-env
        push 20(%eax)
        # discarding useless value in %eax
        pop %eax
        # fetching heap var pointer 2
        push %eax
        movl -24(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        push %eax
        movl $1 + 0<<2, %eax
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_compile_heap_args_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        call *%ebx
        # get procedure
        # jump past the body of the lambda
        jmp _compile_lambda_22
        .text
        .type _compile_lambda_23, @function
_compile_lambda_23:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 body
        push 12(%eax)
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl $2 + 257<<2, %eax
        push %eax
        movl 0(%ebp), %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_compile_lambda_24), %eax
        # apply procedure
        # Tail call; nargs = 3
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 8(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push -8(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _compile_lambda_23, .-_compile_lambda_23
_compile_lambda_22:
        # allocate bytes: 16
        push %eax
        movl (arena_pointer), %eax
        add $16, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_compile_lambda_23, 4(%ebx)
        movl $1, 8(%ebx)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _compile_lambda_21, .-_compile_lambda_21
_compile_lambda_20:
        # allocate bytes: 24
        push %eax
        movl (arena_pointer), %eax
        add $24, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_compile_lambda_21, 4(%ebx)
        movl $3, 8(%ebx)
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # fetching heap var pointer 2
        push %eax
        movl -24(%ebp), %eax
        movl %eax, 16(%ebx)
        pop %eax
        # fetching heap var pointer 3
        push %eax
        movl -28(%ebp), %eax
        movl %eax, 20(%ebx)
        pop %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_compile_procedure_labeled_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        call *%ebx
        pop %eax
        # fetching heap var pointer 4
        push %eax
        movl -32(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_label_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_push_const_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        jmp _compile_lambda_19
_compile_lambda_18:
        # jump past the body of the lambda
        jmp _compile_lambda_25
        .text
        .type _compile_lambda_26, @function
_compile_lambda_26:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $0, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 body
        push 12(%eax)
        # fetch artifact from closure: 1 heap-arg-list
        push 16(%eax)
        # fetch artifact from closure: 2 stack-env
        push 20(%eax)
        # fetch artifact from closure: 3 artifacts
        push 24(%eax)
        # discarding useless value in %eax
        pop %eax
        # fetching heap var pointer 3
        push %eax
        movl -28(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_push_artifacts_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        # jump past the body of the lambda
        jmp _compile_lambda_27
        .text
        .type _compile_lambda_28, @function
_compile_lambda_28:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 body
        push 12(%eax)
        # fetch artifact from closure: 1 heap-arg-list
        push 16(%eax)
        # fetch artifact from closure: 2 artifacts
        push 20(%eax)
        # fetch artifact from closure: 3 stack-env
        push 24(%eax)
        # discarding useless value in %eax
        pop %eax
        # fetching heap var pointer 3
        push %eax
        movl -28(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_append_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # fetching heap var pointer 2
        push %eax
        movl -24(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_length_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_compile_heap_args_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        call *%ebx
        # get procedure
        # jump past the body of the lambda
        jmp _compile_lambda_29
        .text
        .type _compile_lambda_30, @function
_compile_lambda_30:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 body
        push 12(%eax)
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl $2 + 257<<2, %eax
        push %eax
        movl 0(%ebp), %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_compile_lambda_24), %eax
        # apply procedure
        # Tail call; nargs = 3
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 8(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push -8(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _compile_lambda_30, .-_compile_lambda_30
_compile_lambda_29:
        # allocate bytes: 16
        push %eax
        movl (arena_pointer), %eax
        add $16, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_compile_lambda_30, 4(%ebx)
        movl $1, 8(%ebx)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _compile_lambda_28, .-_compile_lambda_28
_compile_lambda_27:
        # allocate bytes: 28
        push %eax
        movl (arena_pointer), %eax
        add $28, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_compile_lambda_28, 4(%ebx)
        movl $4, 8(%ebx)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        movl %eax, 16(%ebx)
        pop %eax
        # fetching heap var pointer 3
        push %eax
        movl -28(%ebp), %eax
        movl %eax, 20(%ebx)
        pop %eax
        # fetching heap var pointer 2
        push %eax
        movl -24(%ebp), %eax
        movl %eax, 24(%ebx)
        pop %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _compile_lambda_26, .-_compile_lambda_26
_compile_lambda_25:
        # allocate bytes: 28
        push %eax
        movl (arena_pointer), %eax
        add $28, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_compile_lambda_26, 4(%ebx)
        movl $4, 8(%ebx)
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # fetching heap var pointer 2
        push %eax
        movl -24(%ebp), %eax
        movl %eax, 16(%ebx)
        pop %eax
        # fetching heap var pointer 3
        push %eax
        movl -28(%ebp), %eax
        movl %eax, 20(%ebx)
        pop %eax
        # fetching heap var pointer 5
        push %eax
        movl -36(%ebp), %eax
        movl %eax, 24(%ebx)
        pop %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_compile_procedure_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        call *%ebx
        pop %eax
        # fetching heap var pointer 4
        push %eax
        movl -32(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_label_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        # fetching heap var pointer 6
        push %eax
        movl -40(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # fetching heap var pointer 5
        push %eax
        movl -36(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_push_closure_1), %eax
        # apply procedure
        # Tail call; nargs = 3
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 8(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push -8(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        jmp *%ebx
_compile_lambda_19:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _compile_lambda_16, .-_compile_lambda_16
_compile_lambda_15:
        # allocate bytes: 40
        push %eax
        movl (arena_pointer), %eax
        add $40, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_compile_lambda_16, 4(%ebx)
        movl $7, 8(%ebx)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        movl %eax, 16(%ebx)
        pop %eax
        # fetching heap var pointer 6
        push %eax
        movl -40(%ebp), %eax
        movl %eax, 20(%ebx)
        pop %eax
        # fetching heap var pointer 5
        push %eax
        movl -36(%ebp), %eax
        movl %eax, 24(%ebx)
        pop %eax
        # fetching heap var pointer 4
        push %eax
        movl -32(%ebp), %eax
        movl %eax, 28(%ebx)
        pop %eax
        # fetching heap var pointer 3
        push %eax
        movl -28(%ebp), %eax
        movl %eax, 32(%ebx)
        pop %eax
        # fetching heap var pointer 2
        push %eax
        movl -24(%ebp), %eax
        movl %eax, 36(%ebx)
        pop %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _compile_lambda_14, .-_compile_lambda_14
_compile_lambda_13:
        # allocate bytes: 24
        push %eax
        movl (arena_pointer), %eax
        add $24, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_compile_lambda_14, 4(%ebx)
        movl $3, 8(%ebx)
        # fetching heap var pointer 2
        push %eax
        movl -24(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        movl %eax, 16(%ebx)
        pop %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl %eax, 20(%ebx)
        pop %eax
        # apply procedure
        # Tail call; nargs = 4
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 12(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push -8(%ebx)
        push -12(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $4, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _compile_lambda_12, .-_compile_lambda_12
_compile_lambda_11:
        # allocate bytes: 20
        push %eax
        movl (arena_pointer), %eax
        add $20, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_compile_lambda_12, 4(%ebx)
        movl $2, 8(%ebx)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        movl %eax, 16(%ebx)
        pop %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _compile_lambda_6, .-_compile_lambda_6
_compile_lambda_5:
        # allocate bytes: 16
        push %eax
        movl (arena_pointer), %eax
        add $16, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_compile_lambda_6, 4(%ebx)
        movl $1, 8(%ebx)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _compile_lambda_4, .-_compile_lambda_4
_compile_lambda_2:
        push %eax
        movl $_compile_lambda_3, %eax
        # initialize global variable with value
        movl %eax, (_compile_lambda_1)
        pop %eax
        .section .data
_compile_lambda_24:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _compile_begin_1
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_begin_2:
        .long 0xca11ab1e
        .long _compile_begin_3
        .long 0
        .text
        .type _compile_begin_3, @function
_compile_begin_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $3, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl $2 + 256<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _compile_begin_4
        push %eax
        movl (_copy_args_12), %eax
        # get procedure
        push %eax
        movl (_push_const_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        jmp _compile_begin_5
_compile_begin_4:
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        # inlined cdr
        call ensure_cons
        movl 8(%eax), %eax
        push %eax
        movl $2 + 256<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _compile_begin_6
        push %eax
        movl 8(%ebp), %eax
        push %eax
        movl 4(%ebp), %eax
        push %eax
        movl 0(%ebp), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_compile_set_5), %eax
        # apply procedure
        # Tail call; nargs = 3
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 8(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push -8(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        jmp *%ebx
        jmp _compile_begin_7
_compile_begin_6:
        push %eax
        movl 4(%ebp), %eax
        push %eax
        movl 0(%ebp), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_compile_discarding_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl 8(%ebp), %eax
        push %eax
        movl 4(%ebp), %eax
        push %eax
        movl 0(%ebp), %eax
        # inlined cdr
        call ensure_cons
        movl 8(%eax), %eax
        # get procedure
        push %eax
        movl (_compile_lambda_24), %eax
        # apply procedure
        # Tail call; nargs = 3
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 8(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push -8(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        jmp *%ebx
_compile_begin_7:
_compile_begin_5:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _compile_begin_3, .-_compile_begin_3
_compile_begin_1:
        push %eax
        movl $_compile_begin_2, %eax
        # initialize global variable with value
        movl %eax, (_compile_lambda_24)
        pop %eax
        .section .data
_compile_conditional_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _compile_conditional_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_conditional_3:
        .long 0xca11ab1e
        .long _compile_conditional_4
        .long 0
        .text
        .type _compile_conditional_4, @function
_compile_conditional_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $5, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # move arg from stack to heap: jump-if-false
        push %eax
        movl 0(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # move arg from stack to heap: then
        push %eax
        movl 4(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # move arg from stack to heap: else-expr
        push %eax
        movl 8(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # move arg from stack to heap: env
        push %eax
        movl 12(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # move arg from stack to heap: tail?
        push %eax
        movl 16(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # get procedure
        push %eax
        movl (_new_label_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        # get procedure
        # jump past the body of the lambda
        jmp _compile_conditional_5
        .text
        .type _compile_conditional_6, @function
_compile_conditional_6:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 jump-if-false
        push 12(%eax)
        # fetch artifact from closure: 1 then
        push 16(%eax)
        # fetch artifact from closure: 2 else-expr
        push 20(%eax)
        # fetch artifact from closure: 3 env
        push 24(%eax)
        # fetch artifact from closure: 4 tail?
        push 28(%eax)
        # discarding useless value in %eax
        pop %eax
        # move arg from stack to heap: falselabel
        push %eax
        movl 0(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # get procedure
        push %eax
        movl (_new_label_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        # get procedure
        # jump past the body of the lambda
        jmp _compile_conditional_7
        .text
        .type _compile_conditional_8, @function
_compile_conditional_8:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 jump-if-false
        push 12(%eax)
        # fetch artifact from closure: 1 then
        push 16(%eax)
        # fetch artifact from closure: 2 falselabel
        push 20(%eax)
        # fetch artifact from closure: 3 else-expr
        push 24(%eax)
        # fetch artifact from closure: 4 env
        push 28(%eax)
        # fetch artifact from closure: 5 tail?
        push 32(%eax)
        # discarding useless value in %eax
        pop %eax
        # fetching heap var pointer 2
        push %eax
        movl -24(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        # fetching heap var pointer 5
        push %eax
        movl -36(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # fetching heap var pointer 4
        push %eax
        movl -32(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_compile_set_5), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        call *%ebx
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_jmp_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        # fetching heap var pointer 2
        push %eax
        movl -24(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_label_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        # fetching heap var pointer 5
        push %eax
        movl -36(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # fetching heap var pointer 4
        push %eax
        movl -32(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # fetching heap var pointer 3
        push %eax
        movl -28(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_compile_set_5), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        call *%ebx
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_label_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _compile_conditional_8, .-_compile_conditional_8
_compile_conditional_7:
        # allocate bytes: 36
        push %eax
        movl (arena_pointer), %eax
        add $36, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_compile_conditional_8, 4(%ebx)
        movl $6, 8(%ebx)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        movl %eax, 16(%ebx)
        pop %eax
        # fetching heap var pointer 5
        push %eax
        movl -36(%ebp), %eax
        movl %eax, 20(%ebx)
        pop %eax
        # fetching heap var pointer 2
        push %eax
        movl -24(%ebp), %eax
        movl %eax, 24(%ebx)
        pop %eax
        # fetching heap var pointer 3
        push %eax
        movl -28(%ebp), %eax
        movl %eax, 28(%ebx)
        pop %eax
        # fetching heap var pointer 4
        push %eax
        movl -32(%ebp), %eax
        movl %eax, 32(%ebx)
        pop %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _compile_conditional_6, .-_compile_conditional_6
_compile_conditional_5:
        # allocate bytes: 32
        push %eax
        movl (arena_pointer), %eax
        add $32, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_compile_conditional_6, 4(%ebx)
        movl $5, 8(%ebx)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        movl %eax, 16(%ebx)
        pop %eax
        # fetching heap var pointer 2
        push %eax
        movl -24(%ebp), %eax
        movl %eax, 20(%ebx)
        pop %eax
        # fetching heap var pointer 3
        push %eax
        movl -28(%ebp), %eax
        movl %eax, 24(%ebx)
        pop %eax
        # fetching heap var pointer 4
        push %eax
        movl -32(%ebp), %eax
        movl %eax, 28(%ebx)
        pop %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _compile_conditional_4, .-_compile_conditional_4
_compile_conditional_2:
        push %eax
        movl $_compile_conditional_3, %eax
        # initialize global variable with value
        movl %eax, (_compile_conditional_1)
        pop %eax
        .section .data
_compile_ifeq_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _compile_ifeq_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_ifeq_3:
        .long 0xca11ab1e
        .long _compile_ifeq_4
        .long 0
        .text
        .type _compile_ifeq_4, @function
_compile_ifeq_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $3, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # move arg from stack to heap: rands
        push %eax
        movl 0(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # move arg from stack to heap: env
        push %eax
        movl 4(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # move arg from stack to heap: tail?
        push %eax
        movl 8(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_cadddr_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_caddr_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_cadr_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        # get procedure
        # jump past the body of the lambda
        jmp _compile_ifeq_5
        .text
        .type _compile_ifeq_6, @function
_compile_ifeq_6:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $4, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 rands
        push 12(%eax)
        # fetch artifact from closure: 1 env
        push 16(%eax)
        # fetch artifact from closure: 2 tail?
        push 20(%eax)
        # discarding useless value in %eax
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_ifeq_7:
        .long 0xbabb1e
        .long 5
        .ascii "%ifeq"
        .text
        push %eax
        movl $_compile_ifeq_7, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        # fetching heap var pointer 2
        push %eax
        movl -24(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        push %eax
        movl 12(%ebp), %eax
        push %eax
        movl 8(%ebp), %eax
        # jump past the body of the lambda
        jmp _compile_ifeq_8
        .text
        .type _compile_ifeq_9, @function
_compile_ifeq_9:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 rands
        push 12(%eax)
        # fetch artifact from closure: 1 env
        push 16(%eax)
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl $2 + 258<<2, %eax
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_compile_set_5), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        call *%ebx
        pop %eax
        push %eax
        movl $2 + 258<<2, %eax
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_cadr_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_compile_set_5), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_nos_1), %eax
        push %eax
        movl (_tos_1), %eax
        # get procedure
        push %eax
        movl (_cmp_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_pop_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_pop_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_jnz_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _compile_ifeq_9, .-_compile_ifeq_9
_compile_ifeq_8:
        # allocate bytes: 20
        push %eax
        movl (arena_pointer), %eax
        add $20, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_compile_ifeq_9, 4(%ebx)
        movl $2, 8(%ebx)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        movl %eax, 16(%ebx)
        pop %eax
        # get procedure
        push %eax
        movl (_compile_conditional_1), %eax
        # apply procedure
        # Tail call; nargs = 5
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 16(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push -8(%ebx)
        push -12(%ebx)
        push -16(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $5, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _compile_ifeq_6, .-_compile_ifeq_6
_compile_ifeq_5:
        # allocate bytes: 24
        push %eax
        movl (arena_pointer), %eax
        add $24, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_compile_ifeq_6, 4(%ebx)
        movl $3, 8(%ebx)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        movl %eax, 16(%ebx)
        pop %eax
        # fetching heap var pointer 2
        push %eax
        movl -24(%ebp), %eax
        movl %eax, 20(%ebx)
        pop %eax
        # apply procedure
        # Tail call; nargs = 4
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 12(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push -8(%ebx)
        push -12(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $4, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _compile_ifeq_4, .-_compile_ifeq_4
_compile_ifeq_2:
        push %eax
        movl $_compile_ifeq_3, %eax
        # initialize global variable with value
        movl %eax, (_compile_ifeq_1)
        pop %eax
        .section .data
_inline_primitive_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _inline_primitive_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_inline_primitive_3:
        .long 0xca11ab1e
        .long _inline_primitive_4
        .long 0
        .text
        .type _inline_primitive_4, @function
_inline_primitive_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $3, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # move arg from stack to heap: rator
        push %eax
        movl 0(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        push %eax
        movl 8(%ebp), %eax
        push %eax
        movl 4(%ebp), %eax
        # get procedure
        push %eax
        movl (_inline_primitive_5), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        # jump past the body of the lambda
        jmp _inline_primitive_6
        .text
        .type _inline_primitive_7, @function
_inline_primitive_7:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 rator
        push 12(%eax)
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        push %eax
        movl $_inline_primitive_10, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _inline_primitive_8
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_integer_add_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        jmp _inline_primitive_9
_inline_primitive_8:
        # %ifeq
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        push %eax
        movl $_inline_primitive_13, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _inline_primitive_11
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_integer_sub_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        jmp _inline_primitive_12
_inline_primitive_11:
        # %ifeq
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        push %eax
        movl $_inline_primitive_16, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _inline_primitive_14
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_inline_1Plus_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        jmp _inline_primitive_15
_inline_primitive_14:
        # %ifeq
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        push %eax
        movl $_inline_primitive_19, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _inline_primitive_17
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_inline_1__1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        jmp _inline_primitive_18
_inline_primitive_17:
        # %ifeq
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        push %eax
        movl $_inline_primitive_22, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _inline_primitive_20
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_inline_car_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        jmp _inline_primitive_21
_inline_primitive_20:
        # %ifeq
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        push %eax
        movl $_inline_primitive_25, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _inline_primitive_23
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_inline_cdr_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        jmp _inline_primitive_24
_inline_primitive_23:
        # %ifeq
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        push %eax
        movl $_inline_primitive_28, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _inline_primitive_26
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_inline_integer_Gtchar_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        jmp _inline_primitive_27
_inline_primitive_26:
        # %ifeq
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        push %eax
        movl $_inline_primitive_31, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _inline_primitive_29
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_inline_char_Gtinteger_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        jmp _inline_primitive_30
_inline_primitive_29:
        # %ifeq
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        push %eax
        movl $_inline_primitive_34, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _inline_primitive_32
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_inline_string_length_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        jmp _inline_primitive_33
_inline_primitive_32:
        # %ifeq
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        push %eax
        movl $_inline_primitive_37, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _inline_primitive_35
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_inline_symbol_Gtstring_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        jmp _inline_primitive_36
_inline_primitive_35:
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_inline_primitive_38:
        .long 0xbabb1e
        .long 24
        .ascii "don't know how to inline"
        .text
        push %eax
        movl $_inline_primitive_38, %eax
        # get procedure
        push %eax
        movl (_string_Gtnumber_8), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
_inline_primitive_36:
_inline_primitive_33:
_inline_primitive_30:
_inline_primitive_27:
_inline_primitive_24:
_inline_primitive_21:
_inline_primitive_18:
_inline_primitive_15:
_inline_primitive_12:
_inline_primitive_9:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _inline_primitive_7, .-_inline_primitive_7
_inline_primitive_6:
        # allocate bytes: 16
        push %eax
        movl (arena_pointer), %eax
        add $16, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_inline_primitive_7, 4(%ebx)
        movl $1, 8(%ebx)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _inline_primitive_4, .-_inline_primitive_4
_inline_primitive_2:
        push %eax
        movl $_inline_primitive_3, %eax
        # initialize global variable with value
        movl %eax, (_inline_primitive_1)
        pop %eax
        .section .data
_compile_combination_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _compile_combination_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_combination_3:
        .long 0xca11ab1e
        .long _compile_combination_4
        .long 0
        .text
        .type _compile_combination_4, @function
_compile_combination_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $4, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # move arg from stack to heap: rator
        push %eax
        movl 0(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # move arg from stack to heap: env
        push %eax
        movl 8(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # move arg from stack to heap: tail?
        push %eax
        movl 12(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # %ifeq
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        push %eax
        movl $_free_vars_15, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _compile_combination_5
        # fetching heap var pointer 2
        push %eax
        movl -24(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        push %eax
        movl 4(%ebp), %eax
        # get procedure
        push %eax
        movl (_compile_lambda_24), %eax
        # apply procedure
        # Tail call; nargs = 3
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 8(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push -8(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        jmp *%ebx
        jmp _compile_combination_6
_compile_combination_5:
        # %ifeq
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        push %eax
        movl $_lambdas_8, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _compile_combination_7
        # fetching heap var pointer 2
        push %eax
        movl -24(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        push %eax
        movl 4(%ebp), %eax
        # get procedure
        push %eax
        movl (_compile_lambda_1), %eax
        # apply procedure
        # Tail call; nargs = 3
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 8(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push -8(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        jmp *%ebx
        jmp _compile_combination_8
_compile_combination_7:
        # %ifeq
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        push %eax
        movl $_free_vars_20, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _compile_combination_9
        push %eax
        movl 4(%ebp), %eax
        # get procedure
        push %eax
        movl (_length_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $1 + 1<<2, %eax
        # get procedure
        push %eax
        movl (_emit_malloc_n_4), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        push %eax
        movl 4(%ebp), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_compile_quotable_1), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        jmp _compile_combination_10
_compile_combination_9:
        # %ifeq
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        push %eax
        movl $_free_vars_23, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _compile_combination_11
        push %eax
        movl 4(%ebp), %eax
        # get procedure
        push %eax
        movl (_length_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $1 + 2<<2, %eax
        # get procedure
        push %eax
        movl (_emit_malloc_n_4), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        push %eax
        movl 4(%ebp), %eax
        # get procedure
        push %eax
        movl (_cadr_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl 4(%ebp), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_compile_set_1), %eax
        # apply procedure
        # Tail call; nargs = 3
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 8(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push -8(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        jmp *%ebx
        jmp _compile_combination_12
_compile_combination_11:
        # %ifeq
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_combination_24:
        .long 0x2ce11ed
        .long _inline_primitive_37
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_combination_23:
        .long 0x2ce11ed
        .long _inline_primitive_34
        .long _compile_combination_24
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_combination_22:
        .long 0x2ce11ed
        .long _inline_primitive_31
        .long _compile_combination_23
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_combination_21:
        .long 0x2ce11ed
        .long _inline_primitive_28
        .long _compile_combination_22
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_combination_20:
        .long 0x2ce11ed
        .long _inline_primitive_25
        .long _compile_combination_21
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_combination_19:
        .long 0x2ce11ed
        .long _inline_primitive_22
        .long _compile_combination_20
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_combination_18:
        .long 0x2ce11ed
        .long _inline_primitive_19
        .long _compile_combination_19
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_combination_17:
        .long 0x2ce11ed
        .long _inline_primitive_16
        .long _compile_combination_18
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_combination_16:
        .long 0x2ce11ed
        .long _inline_primitive_13
        .long _compile_combination_17
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_combination_15:
        .long 0x2ce11ed
        .long _inline_primitive_10
        .long _compile_combination_16
        .text
        push %eax
        movl $_compile_combination_15, %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_memv_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _compile_combination_13
        # %ifeq
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        push %eax
        movl $_free_vars_17, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _compile_combination_25
        # fetching heap var pointer 2
        push %eax
        movl -24(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        push %eax
        movl 4(%ebp), %eax
        # get procedure
        push %eax
        movl (_compile_ifeq_1), %eax
        # apply procedure
        # Tail call; nargs = 3
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 8(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push -8(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        jmp *%ebx
        jmp _compile_combination_26
_compile_combination_25:
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        push %eax
        movl 4(%ebp), %eax
        # get procedure
        push %eax
        movl (_inline_primitive_5), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        # jump past the body of the lambda
        jmp _compile_combination_27
        .text
        .type _compile_combination_28, @function
_compile_combination_28:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 rator
        push 12(%eax)
        # fetch artifact from closure: 1 env
        push 16(%eax)
        # fetch artifact from closure: 2 tail?
        push 20(%eax)
        # discarding useless value in %eax
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_combination_29:
        .long 0xbabb1e
        .long 13
        .ascii "get procedure"
        .text
        push %eax
        movl $_compile_combination_29, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl $2 + 258<<2, %eax
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_compile_set_5), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_combination_30:
        .long 0xbabb1e
        .long 15
        .ascii "apply procedure"
        .text
        push %eax
        movl $_compile_combination_30, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        # %ifeq
        # fetching heap var pointer 2
        push %eax
        movl -24(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _compile_combination_31
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_compile_apply_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        jmp _compile_combination_32
_compile_combination_31:
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_compile_tail_apply_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
_compile_combination_32:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _compile_combination_28, .-_compile_combination_28
_compile_combination_27:
        # allocate bytes: 24
        push %eax
        movl (arena_pointer), %eax
        add $24, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_compile_combination_28, 4(%ebx)
        movl $3, 8(%ebx)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        movl %eax, 16(%ebx)
        pop %eax
        # fetching heap var pointer 2
        push %eax
        movl -24(%ebp), %eax
        movl %eax, 20(%ebx)
        pop %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
_compile_combination_26:
        jmp _compile_combination_14
_compile_combination_13:
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        push %eax
        movl 4(%ebp), %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_inline_primitive_1), %eax
        # apply procedure
        # Tail call; nargs = 3
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 8(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push -8(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        jmp *%ebx
_compile_combination_14:
_compile_combination_12:
_compile_combination_10:
_compile_combination_8:
_compile_combination_6:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _compile_combination_4, .-_compile_combination_4
_compile_combination_2:
        push %eax
        movl $_compile_combination_3, %eax
        # initialize global variable with value
        movl %eax, (_compile_combination_1)
        pop %eax
        .section .data
_compile_set_5:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _compile_expr_1
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_expr_2:
        .long 0xca11ab1e
        .long _compile_expr_3
        .long 0
        .text
        .type _compile_expr_3, @function
_compile_expr_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $3, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # move arg from stack to heap: expr
        push %eax
        movl 0(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # %ifeq
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_pairP_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _compile_expr_4
        # %ifeq
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_symbolP_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _compile_expr_6
        # %ifeq
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_stringP_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        # jump past the body of the lambda
        jmp _compile_expr_10
        .text
        .type _compile_expr_11, @function
_compile_expr_11:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 expr
        push 12(%eax)
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _compile_expr_12
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_booleanP_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        # jump past the body of the lambda
        jmp _compile_expr_14
        .text
        .type _compile_expr_15, @function
_compile_expr_15:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 expr
        push 12(%eax)
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _compile_expr_16
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_integerP_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        # jump past the body of the lambda
        jmp _compile_expr_18
        .text
        .type _compile_expr_19, @function
_compile_expr_19:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 expr
        push 12(%eax)
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _compile_expr_20
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_charP_2), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        jmp _compile_expr_21
_compile_expr_20:
        push %eax
        movl 0(%ebp), %eax
_compile_expr_21:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _compile_expr_19, .-_compile_expr_19
_compile_expr_18:
        # allocate bytes: 16
        push %eax
        movl (arena_pointer), %eax
        add $16, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_compile_expr_19, 4(%ebx)
        movl $1, 8(%ebx)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        jmp _compile_expr_17
_compile_expr_16:
        push %eax
        movl 0(%ebp), %eax
_compile_expr_17:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _compile_expr_15, .-_compile_expr_15
_compile_expr_14:
        # allocate bytes: 16
        push %eax
        movl (arena_pointer), %eax
        add $16, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_compile_expr_15, 4(%ebx)
        movl $1, 8(%ebx)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        jmp _compile_expr_13
_compile_expr_12:
        push %eax
        movl 0(%ebp), %eax
_compile_expr_13:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _compile_expr_11, .-_compile_expr_11
_compile_expr_10:
        # allocate bytes: 16
        push %eax
        movl (arena_pointer), %eax
        add $16, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_compile_expr_11, 4(%ebx)
        movl $1, 8(%ebx)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _compile_expr_8
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_expr_22:
        .long 0xbabb1e
        .long 25
        .ascii "don't know how to compile"
        .text
        push %eax
        movl $_compile_expr_22, %eax
        # get procedure
        push %eax
        movl (_string_Gtnumber_8), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        jmp _compile_expr_9
_compile_expr_8:
        push %eax
        movl 4(%ebp), %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_compile_quotable_1), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
_compile_expr_9:
        jmp _compile_expr_7
_compile_expr_6:
        push %eax
        movl 4(%ebp), %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_compile_heap_args_2_9), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
_compile_expr_7:
        jmp _compile_expr_5
_compile_expr_4:
        push %eax
        movl 8(%ebp), %eax
        push %eax
        movl 4(%ebp), %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # inlined cdr
        call ensure_cons
        movl 8(%eax), %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_compile_combination_1), %eax
        # apply procedure
        # Tail call; nargs = 4
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 12(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push -8(%ebx)
        push -12(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $4, %edx
        jmp *%ebx
_compile_expr_5:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _compile_expr_3, .-_compile_expr_3
_compile_expr_1:
        push %eax
        movl $_compile_expr_2, %eax
        # initialize global variable with value
        movl %eax, (_compile_set_5)
        pop %eax
        .section .data
_compile_args_2_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _compile_args_2_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_args_2_3:
        .long 0xca11ab1e
        .long _compile_args_2_4
        .long 0
        .text
        .type _compile_args_2_4, @function
_compile_args_2_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $3, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl $2 + 258<<2, %eax
        push %eax
        movl 4(%ebp), %eax
        push %eax
        movl 0(%ebp), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_compile_set_5), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        call *%ebx
        pop %eax
        push %eax
        movl 8(%ebp), %eax
        # 1+
        call ensure_integer
        add $1<<2, %eax
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _compile_args_2_4, .-_compile_args_2_4
_compile_args_2_2:
        push %eax
        movl $_compile_args_2_3, %eax
        # initialize global variable with value
        movl %eax, (_compile_args_2_1)
        pop %eax
        .section .data
_inline_primitive_5:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _compile_args_1
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_args_2:
        .long 0xca11ab1e
        .long _compile_args_3
        .long 0
        .text
        .type _compile_args_3, @function
_compile_args_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $2, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl $2 + 256<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _compile_args_4
        push %eax
        movl $1 + 0<<2, %eax
        jmp _compile_args_5
_compile_args_4:
        push %eax
        movl 4(%ebp), %eax
        push %eax
        movl 0(%ebp), %eax
        # inlined cdr
        call ensure_cons
        movl 8(%eax), %eax
        # get procedure
        push %eax
        movl (_inline_primitive_5), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        push %eax
        movl 4(%ebp), %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_compile_args_2_1), %eax
        # apply procedure
        # Tail call; nargs = 3
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 8(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push -8(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        jmp *%ebx
_compile_args_5:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _compile_args_3, .-_compile_args_3
_compile_args_1:
        push %eax
        movl $_compile_args_2, %eax
        # initialize global variable with value
        movl %eax, (_inline_primitive_5)
        pop %eax
        .section .data
_compile_toplevel_define_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _compile_toplevel_define_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_toplevel_define_3:
        .long 0xca11ab1e
        .long _compile_toplevel_define_4
        .long 0
        .text
        .type _compile_toplevel_define_4, @function
_compile_toplevel_define_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $3, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl (_copy_args_12), %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_define_global_procedure_9), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_toplevel_define_5:
        .long 0xbabb1e
        .long 41
        .ascii "compute initial value for global variable"
        .text
        push %eax
        movl $_compile_toplevel_define_5, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl $2 + 258<<2, %eax
        push %eax
        movl 8(%ebp), %eax
        push %eax
        movl 4(%ebp), %eax
        # get procedure
        push %eax
        movl (_compile_set_5), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_toplevel_define_6:
        .long 0xbabb1e
        .long 37
        .ascii "initialize global variable with value"
        .text
        push %eax
        movl $_compile_toplevel_define_6, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_global_variable_label_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_indirect_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl (_tos_1), %eax
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_pop_1), %eax
        # apply procedure
        # Tail call; nargs = 0
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea -4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _compile_toplevel_define_4, .-_compile_toplevel_define_4
_compile_toplevel_define_2:
        push %eax
        movl $_compile_toplevel_define_3, %eax
        # initialize global variable with value
        movl %eax, (_compile_toplevel_define_1)
        pop %eax
        .section .data
_global_env_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        push %eax
        movl $2 + 256<<2, %eax
        # initialize global variable with value
        movl %eax, (_global_env_1)
        pop %eax
        .section .data
_macros_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        push %eax
        movl $2 + 256<<2, %eax
        # initialize global variable with value
        movl %eax, (_macros_1)
        pop %eax
        .section .data
_define_ur_macro_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _define_ur_macro_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_define_ur_macro_3:
        .long 0xca11ab1e
        .long _define_ur_macro_4
        .long 0
        .text
        .type _define_ur_macro_4, @function
_define_ur_macro_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $2, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl (_macros_1), %eax
        push %eax
        movl 4(%ebp), %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_list_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_cons_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        movl %eax, (_macros_1)
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _define_ur_macro_4, .-_define_ur_macro_4
_define_ur_macro_2:
        push %eax
        movl $_define_ur_macro_3, %eax
        # initialize global variable with value
        movl %eax, (_define_ur_macro_1)
        pop %eax
        .section .data
_relevant_macro_definition_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _relevant_macro_definition_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_relevant_macro_definition_3:
        .long 0xca11ab1e
        .long _relevant_macro_definition_4
        .long 0
        .text
        .type _relevant_macro_definition_4, @function
_relevant_macro_definition_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_pairP_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _relevant_macro_definition_5
        push %eax
        movl $2 + 258<<2, %eax
        jmp _relevant_macro_definition_6
_relevant_macro_definition_5:
        push %eax
        movl (_macros_1), %eax
        push %eax
        movl 0(%ebp), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_assq_1), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
_relevant_macro_definition_6:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _relevant_macro_definition_4, .-_relevant_macro_definition_4
_relevant_macro_definition_2:
        push %eax
        movl $_relevant_macro_definition_3, %eax
        # initialize global variable with value
        movl %eax, (_relevant_macro_definition_1)
        pop %eax
        .section .data
_macroexpand_1_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _macroexpand_1_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_macroexpand_1_3:
        .long 0xca11ab1e
        .long _macroexpand_1_4
        .long 0
        .text
        .type _macroexpand_1_4, @function
_macroexpand_1_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_relevant_macro_definition_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _macroexpand_1_5
        push %eax
        movl 0(%ebp), %eax
        jmp _macroexpand_1_6
_macroexpand_1_5:
        push %eax
        movl 0(%ebp), %eax
        # inlined cdr
        call ensure_cons
        movl 8(%eax), %eax
        # get procedure
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_relevant_macro_definition_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_cadr_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
_macroexpand_1_6:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _macroexpand_1_4, .-_macroexpand_1_4
_macroexpand_1_2:
        push %eax
        movl $_macroexpand_1_3, %eax
        # initialize global variable with value
        movl %eax, (_macroexpand_1_1)
        pop %eax
        # jump past the body of the lambda
        jmp _macroexpand_1_7
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_macroexpand_1_8:
        .long 0xca11ab1e
        .long _macroexpand_1_9
        .long 0
        .text
        .type _macroexpand_1_9, @function
_macroexpand_1_9:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl $_free_vars_15, %eax
        # get procedure
        push %eax
        movl (_cons_2), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _macroexpand_1_9, .-_macroexpand_1_9
_macroexpand_1_7:
        push %eax
        movl $_macroexpand_1_8, %eax
        push %eax
        movl $_macroexpand_1_10, %eax
        # get procedure
        push %eax
        movl (_define_ur_macro_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        # jump past the body of the lambda
        jmp _macroexpand_1_11
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_macroexpand_1_12:
        .long 0xca11ab1e
        .long _macroexpand_1_13
        .long 0
        .text
        .type _macroexpand_1_13, @function
_macroexpand_1_13:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl $2 + 256<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _macroexpand_1_14
        push %eax
        movl $2 + 258<<2, %eax
        jmp _macroexpand_1_15
_macroexpand_1_14:
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_assq_9), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $_macroexpand_1_18, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _macroexpand_1_16
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_cdar_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $_macroexpand_1_10, %eax
        # get procedure
        push %eax
        movl (_cons_2), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        jmp _macroexpand_1_17
_macroexpand_1_16:
        push %eax
        movl 0(%ebp), %eax
        # inlined cdr
        call ensure_cons
        movl 8(%eax), %eax
        push %eax
        movl $_macroexpand_1_19, %eax
        # get procedure
        push %eax
        movl (_cons_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_cdar_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $_macroexpand_1_10, %eax
        # get procedure
        push %eax
        movl (_cons_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_assq_9), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $_macroexpand_1_20, %eax
        # get procedure
        push %eax
        movl (_list_1), %eax
        # apply procedure
        # Tail call; nargs = 4
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 12(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push -8(%ebx)
        push -12(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $4, %edx
        jmp *%ebx
_macroexpand_1_17:
_macroexpand_1_15:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _macroexpand_1_13, .-_macroexpand_1_13
_macroexpand_1_11:
        push %eax
        movl $_macroexpand_1_12, %eax
        push %eax
        movl $_macroexpand_1_19, %eax
        # get procedure
        push %eax
        movl (_define_ur_macro_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        # jump past the body of the lambda
        jmp _macroexpand_1_21
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_macroexpand_1_22:
        .long 0xca11ab1e
        .long _macroexpand_1_23
        .long 0
        .text
        .type _macroexpand_1_23, @function
_macroexpand_1_23:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_pairP_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _macroexpand_1_24
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl $_macroexpand_1_26, %eax
        # get procedure
        push %eax
        movl (_cons_2), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        jmp _macroexpand_1_25
_macroexpand_1_24:
        push %eax
        movl 0(%ebp), %eax
        # inlined cdr
        call ensure_cons
        movl 8(%eax), %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_cdar_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_cons_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        push %eax
        movl $_lambdas_8, %eax
        # get procedure
        push %eax
        movl (_cons_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_assq_9), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $_macroexpand_1_26, %eax
        # get procedure
        push %eax
        movl (_list_1), %eax
        # apply procedure
        # Tail call; nargs = 3
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 8(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push -8(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        jmp *%ebx
_macroexpand_1_25:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _macroexpand_1_23, .-_macroexpand_1_23
_macroexpand_1_21:
        push %eax
        movl $_macroexpand_1_22, %eax
        push %eax
        movl $_macroexpand_1_27, %eax
        # get procedure
        push %eax
        movl (_define_ur_macro_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        # jump past the body of the lambda
        jmp _macroexpand_1_28
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_macroexpand_1_29:
        .long 0xca11ab1e
        .long _macroexpand_1_30
        .long 0
        .text
        .type _macroexpand_1_30, @function
_macroexpand_1_30:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        push %eax
        movl (_cadr_1), %eax
        # get procedure
        push %eax
        movl (_map_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        push %eax
        movl 0(%ebp), %eax
        # inlined cdr
        call ensure_cons
        movl 8(%eax), %eax
        push %eax
        movl 0(%ebp), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        push %eax
        movl (_car_1), %eax
        # get procedure
        push %eax
        movl (_map_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_cons_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        push %eax
        movl $_lambdas_8, %eax
        # get procedure
        push %eax
        movl (_cons_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_cons_2), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _macroexpand_1_30, .-_macroexpand_1_30
_macroexpand_1_28:
        push %eax
        movl $_macroexpand_1_29, %eax
        push %eax
        movl $_macroexpand_1_31, %eax
        # get procedure
        push %eax
        movl (_define_ur_macro_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        # jump past the body of the lambda
        jmp _macroexpand_1_32
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_macroexpand_1_33:
        .long 0xca11ab1e
        .long _macroexpand_1_34
        .long 0
        .text
        .type _macroexpand_1_34, @function
_macroexpand_1_34:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_pairP_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _macroexpand_1_35
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        # inlined cdr
        call ensure_cons
        movl 8(%eax), %eax
        push %eax
        movl $2 + 256<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _macroexpand_1_37
        push %eax
        movl $_macroexpand_1_10, %eax
        # get procedure
        push %eax
        movl (_list_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        jmp _macroexpand_1_38
_macroexpand_1_37:
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_caadr_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $_macroexpand_1_18, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _macroexpand_1_39
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_cdadr_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $_macroexpand_1_10, %eax
        # get procedure
        push %eax
        movl (_cons_2), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        jmp _macroexpand_1_40
_macroexpand_1_39:
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_cddr_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl 0(%ebp), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_cons_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        push %eax
        movl $_macroexpand_1_41, %eax
        # get procedure
        push %eax
        movl (_cons_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_cdadr_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $_macroexpand_1_10, %eax
        # get procedure
        push %eax
        movl (_cons_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_caadr_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_length_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $1 + 1<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _macroexpand_1_42
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_caaadr_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $_free_vars_20, %eax
        # get procedure
        push %eax
        movl (_list_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        push %eax
        movl 0(%ebp), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        push %eax
        movl $_macroexpand_1_44, %eax
        # get procedure
        push %eax
        movl (_list_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        call *%ebx
        jmp _macroexpand_1_43
_macroexpand_1_42:
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_caadr_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $_free_vars_20, %eax
        # get procedure
        push %eax
        movl (_list_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        push %eax
        movl 0(%ebp), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        push %eax
        movl $_macroexpand_1_45, %eax
        # get procedure
        push %eax
        movl (_list_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        call *%ebx
_macroexpand_1_43:
        push %eax
        movl $_macroexpand_1_20, %eax
        # get procedure
        push %eax
        movl (_list_1), %eax
        # apply procedure
        # Tail call; nargs = 4
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 12(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push -8(%ebx)
        push -12(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $4, %edx
        jmp *%ebx
_macroexpand_1_40:
_macroexpand_1_38:
        jmp _macroexpand_1_36
_macroexpand_1_35:
        push %eax
        movl 0(%ebp), %eax
        # inlined cdr
        call ensure_cons
        movl 8(%eax), %eax
        push %eax
        movl $_macroexpand_1_46, %eax
        # get procedure
        push %eax
        movl (_cons_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        push %eax
        movl $_macroexpand_1_41, %eax
        # get procedure
        push %eax
        movl (_cons_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        push %eax
        movl 0(%ebp), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        push %eax
        movl $_macroexpand_1_46, %eax
        # get procedure
        push %eax
        movl (_list_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_list_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $_macroexpand_1_31, %eax
        # get procedure
        push %eax
        movl (_list_1), %eax
        # apply procedure
        # Tail call; nargs = 3
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 8(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push -8(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        jmp *%ebx
_macroexpand_1_36:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _macroexpand_1_34, .-_macroexpand_1_34
_macroexpand_1_32:
        push %eax
        movl $_macroexpand_1_33, %eax
        push %eax
        movl $_macroexpand_1_41, %eax
        # get procedure
        push %eax
        movl (_define_ur_macro_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        # jump past the body of the lambda
        jmp _macroexpand_1_47
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_macroexpand_1_48:
        .long 0xca11ab1e
        .long _macroexpand_1_49
        .long 0
        .text
        .type _macroexpand_1_49, @function
_macroexpand_1_49:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl $2 + 256<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _macroexpand_1_50
        push %eax
        movl $2 + 258<<2, %eax
        jmp _macroexpand_1_51
_macroexpand_1_50:
        # %ifeq
        push %eax
        movl $1 + 1<<2, %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_length_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _macroexpand_1_52
        push %eax
        movl 0(%ebp), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        jmp _macroexpand_1_53
_macroexpand_1_52:
        push %eax
        movl 0(%ebp), %eax
        # inlined cdr
        call ensure_cons
        movl 8(%eax), %eax
        push %eax
        movl $_macroexpand_1_54, %eax
        # get procedure
        push %eax
        movl (_cons_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        push %eax
        movl $_macroexpand_1_55, %eax
        push %eax
        movl $_macroexpand_1_55, %eax
        push %eax
        movl $_macroexpand_1_20, %eax
        # get procedure
        push %eax
        movl (_list_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $4, %edx
        call *%ebx
        push %eax
        movl 0(%ebp), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        push %eax
        movl $_macroexpand_1_55, %eax
        # get procedure
        push %eax
        movl (_list_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_list_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $_macroexpand_1_31, %eax
        # get procedure
        push %eax
        movl (_list_1), %eax
        # apply procedure
        # Tail call; nargs = 3
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 8(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push -8(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        jmp *%ebx
_macroexpand_1_53:
_macroexpand_1_51:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _macroexpand_1_49, .-_macroexpand_1_49
_macroexpand_1_47:
        push %eax
        movl $_macroexpand_1_48, %eax
        push %eax
        movl $_macroexpand_1_54, %eax
        # get procedure
        push %eax
        movl (_define_ur_macro_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        # jump past the body of the lambda
        jmp _macroexpand_1_56
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_macroexpand_1_57:
        .long 0xca11ab1e
        .long _macroexpand_1_58
        .long 0
        .text
        .type _macroexpand_1_58, @function
_macroexpand_1_58:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl $2 + 256<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _macroexpand_1_59
        push %eax
        movl $2 + 257<<2, %eax
        jmp _macroexpand_1_60
_macroexpand_1_59:
        # %ifeq
        push %eax
        movl $1 + 1<<2, %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_length_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _macroexpand_1_61
        push %eax
        movl 0(%ebp), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        jmp _macroexpand_1_62
_macroexpand_1_61:
        push %eax
        movl $2 + 258<<2, %eax
        push %eax
        movl 0(%ebp), %eax
        # inlined cdr
        call ensure_cons
        movl 8(%eax), %eax
        push %eax
        movl $_macroexpand_1_63, %eax
        # get procedure
        push %eax
        movl (_cons_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        push %eax
        movl 0(%ebp), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        push %eax
        movl $_macroexpand_1_20, %eax
        # get procedure
        push %eax
        movl (_list_1), %eax
        # apply procedure
        # Tail call; nargs = 4
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 12(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push -8(%ebx)
        push -12(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $4, %edx
        jmp *%ebx
_macroexpand_1_62:
_macroexpand_1_60:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _macroexpand_1_58, .-_macroexpand_1_58
_macroexpand_1_56:
        push %eax
        movl $_macroexpand_1_57, %eax
        push %eax
        movl $_macroexpand_1_63, %eax
        # get procedure
        push %eax
        movl (_define_ur_macro_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        # jump past the body of the lambda
        jmp _macroexpand_1_64
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_macroexpand_1_65:
        .long 0xca11ab1e
        .long _macroexpand_1_66
        .long 0
        .text
        .type _macroexpand_1_66, @function
_macroexpand_1_66:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # move arg from stack to heap: args
        push %eax
        movl 0(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # %ifeq
        push %eax
        movl $1 + 2<<2, %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_length_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _macroexpand_1_67
        push %eax
        movl $2 + 258<<2, %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_cadr_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        push %eax
        movl $_macroexpand_1_20, %eax
        # get procedure
        push %eax
        movl (_list_1), %eax
        # apply procedure
        # Tail call; nargs = 4
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 12(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push -8(%ebx)
        push -12(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $4, %edx
        jmp *%ebx
        jmp _macroexpand_1_68
_macroexpand_1_67:
        # %ifeq
        push %eax
        movl $1 + 3<<2, %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_length_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _macroexpand_1_69
        # %ifeq
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_pairP_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _macroexpand_1_71
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        push %eax
        movl $_macroexpand_1_73, %eax
        # get procedure
        push %eax
        movl (_cons_2), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        jmp _macroexpand_1_72
_macroexpand_1_71:
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_assq_9), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        # jump past the body of the lambda
        jmp _macroexpand_1_74
        .text
        .type _macroexpand_1_75, @function
_macroexpand_1_75:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 args
        push 12(%eax)
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_macroexpand_1_81:
        .long 0x2ce11ed
        .long _macroexpand_1_82
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_macroexpand_1_80:
        .long 0x2ce11ed
        .long _macroexpand_1_44
        .long _macroexpand_1_81
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_macroexpand_1_78:
        .long 0x2ce11ed
        .long _macroexpand_1_79
        .long _macroexpand_1_80
        .text
        push %eax
        movl $_macroexpand_1_78, %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_memv_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _macroexpand_1_76
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl $_macroexpand_1_85, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _macroexpand_1_83
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_caddr_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_cadr_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $2 + 256<<2, %eax
        push %eax
        movl $_free_vars_20, %eax
        # get procedure
        push %eax
        movl (_list_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_cadar_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $_free_vars_17, %eax
        # get procedure
        push %eax
        movl (_list_1), %eax
        # apply procedure
        # Tail call; nargs = 5
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 16(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push -8(%ebx)
        push -12(%ebx)
        push -16(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $5, %edx
        jmp *%ebx
        jmp _macroexpand_1_84
_macroexpand_1_83:
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl $_macroexpand_1_88, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _macroexpand_1_86
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_cadr_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_caddr_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_cadar_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $_macroexpand_1_20, %eax
        # get procedure
        push %eax
        movl (_list_1), %eax
        # apply procedure
        # Tail call; nargs = 4
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 12(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push -8(%ebx)
        push -12(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $4, %edx
        jmp *%ebx
        jmp _macroexpand_1_87
_macroexpand_1_86:
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        push %eax
        movl $_macroexpand_1_73, %eax
        # get procedure
        push %eax
        movl (_cons_2), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
_macroexpand_1_87:
_macroexpand_1_84:
        jmp _macroexpand_1_77
_macroexpand_1_76:
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_caddr_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_cadr_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_caddar_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_cadar_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $_free_vars_17, %eax
        # get procedure
        push %eax
        movl (_list_1), %eax
        # apply procedure
        # Tail call; nargs = 5
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 16(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push -8(%ebx)
        push -12(%ebx)
        push -16(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $5, %edx
        jmp *%ebx
_macroexpand_1_77:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _macroexpand_1_75, .-_macroexpand_1_75
_macroexpand_1_74:
        # allocate bytes: 16
        push %eax
        movl (arena_pointer), %eax
        add $16, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_macroexpand_1_75, 4(%ebx)
        movl $1, 8(%ebx)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
_macroexpand_1_72:
        jmp _macroexpand_1_70
_macroexpand_1_69:
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_macroexpand_1_89:
        .long 0xbabb1e
        .long 20
        .ascii "if needs 2 or 3 args"
        .text
        push %eax
        movl $_macroexpand_1_89, %eax
        # get procedure
        push %eax
        movl (_string_Gtnumber_8), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
_macroexpand_1_70:
_macroexpand_1_68:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _macroexpand_1_66, .-_macroexpand_1_66
_macroexpand_1_64:
        push %eax
        movl $_macroexpand_1_65, %eax
        push %eax
        movl $_macroexpand_1_20, %eax
        # get procedure
        push %eax
        movl (_define_ur_macro_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        # jump past the body of the lambda
        jmp _macroexpand_1_90
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_macroexpand_1_91:
        .long 0xca11ab1e
        .long _macroexpand_1_92
        .long 0
        .text
        .type _macroexpand_1_92, @function
_macroexpand_1_92:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_cadr_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_caddr_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $2 + 258<<2, %eax
        push %eax
        movl 0(%ebp), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        push %eax
        movl $_free_vars_17, %eax
        # get procedure
        push %eax
        movl (_list_1), %eax
        # apply procedure
        # Tail call; nargs = 5
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 16(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push -8(%ebx)
        push -12(%ebx)
        push -16(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $5, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _macroexpand_1_92, .-_macroexpand_1_92
_macroexpand_1_90:
        push %eax
        movl $_macroexpand_1_91, %eax
        push %eax
        movl $_macroexpand_1_73, %eax
        # get procedure
        push %eax
        movl (_define_ur_macro_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .data
_totally_macroexpand_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _totally_macroexpand_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_3:
        .long 0xca11ab1e
        .long _totally_macroexpand_4
        .long 0
        .text
        .type _totally_macroexpand_4, @function
_totally_macroexpand_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # move arg from stack to heap: expr
        push %eax
        movl 0(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # %ifeq
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_relevant_macro_definition_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _totally_macroexpand_5
        # %ifeq
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_pairP_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _totally_macroexpand_7
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        jmp _totally_macroexpand_8
_totally_macroexpand_7:
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        # get procedure
        # jump past the body of the lambda
        jmp _totally_macroexpand_9
        .text
        .type _totally_macroexpand_10, @function
_totally_macroexpand_10:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 expr
        push 12(%eax)
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl $_free_vars_20, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _totally_macroexpand_11
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        jmp _totally_macroexpand_12
_totally_macroexpand_11:
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl $_lambdas_8, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _totally_macroexpand_13
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_cddr_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl (_totally_macroexpand_1), %eax
        # get procedure
        push %eax
        movl (_map_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_cadr_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_cons_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        push %eax
        movl $_lambdas_8, %eax
        # get procedure
        push %eax
        movl (_cons_2), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        jmp _totally_macroexpand_14
_totally_macroexpand_13:
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        push %eax
        movl (_totally_macroexpand_1), %eax
        # get procedure
        push %eax
        movl (_map_1), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
_totally_macroexpand_14:
_totally_macroexpand_12:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _totally_macroexpand_10, .-_totally_macroexpand_10
_totally_macroexpand_9:
        # allocate bytes: 16
        push %eax
        movl (arena_pointer), %eax
        add $16, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_totally_macroexpand_10, 4(%ebx)
        movl $1, 8(%ebx)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
_totally_macroexpand_8:
        jmp _totally_macroexpand_6
_totally_macroexpand_5:
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_macroexpand_1_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_totally_macroexpand_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
_totally_macroexpand_6:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _totally_macroexpand_4, .-_totally_macroexpand_4
_totally_macroexpand_2:
        push %eax
        movl $_totally_macroexpand_3, %eax
        # initialize global variable with value
        movl %eax, (_totally_macroexpand_1)
        pop %eax
        push %eax
        movl $_sample_closure_expression_20, %eax
        push %eax
        movl $_sample_closure_expression_20, %eax
        # get procedure
        push %eax
        movl (_totally_macroexpand_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_emit_malloc_n_4), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_18:
        .long 0x2ce11ed
        .long _sample_abcd_4
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_17:
        .long 0x2ce11ed
        .long _set_union_all_12
        .long _totally_macroexpand_18
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_16:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long _totally_macroexpand_17
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_15:
        .long 0x2ce11ed
        .long _sample_closure_expression_20
        .long _totally_macroexpand_16
        .text
        push %eax
        movl $_totally_macroexpand_15, %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_22:
        .long 0x2ce11ed
        .long _sample_abcd_4
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_21:
        .long 0x2ce11ed
        .long _set_union_all_12
        .long _totally_macroexpand_22
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_20:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long _totally_macroexpand_21
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_19:
        .long 0x2ce11ed
        .long _sample_closure_expression_20
        .long _totally_macroexpand_20
        .text
        push %eax
        movl $_totally_macroexpand_19, %eax
        # get procedure
        push %eax
        movl (_totally_macroexpand_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_emit_malloc_n_4), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_23:
        .long 0xbabb1e
        .long 13
        .ascii "no begin defn"
        .text
        push %eax
        movl $_totally_macroexpand_23, %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_27:
        .long 0x2ce11ed
        .long _sample_abcd_4
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_26:
        .long 0x2ce11ed
        .long _set_union_all_12
        .long _totally_macroexpand_27
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_25:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long _totally_macroexpand_26
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_24:
        .long 0x2ce11ed
        .long _macroexpand_1_10
        .long _totally_macroexpand_25
        .text
        push %eax
        movl $_totally_macroexpand_24, %eax
        # get procedure
        push %eax
        movl (_relevant_macro_definition_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_assert_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_31:
        .long 0x2ce11ed
        .long _sample_abcd_4
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_30:
        .long 0x2ce11ed
        .long _set_union_all_12
        .long _totally_macroexpand_31
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_29:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long _totally_macroexpand_30
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_28:
        .long 0x2ce11ed
        .long _free_vars_15
        .long _totally_macroexpand_29
        .text
        push %eax
        movl $_totally_macroexpand_28, %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_35:
        .long 0x2ce11ed
        .long _sample_abcd_4
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_34:
        .long 0x2ce11ed
        .long _set_union_all_12
        .long _totally_macroexpand_35
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_33:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long _totally_macroexpand_34
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_32:
        .long 0x2ce11ed
        .long _macroexpand_1_10
        .long _totally_macroexpand_33
        .text
        push %eax
        movl $_totally_macroexpand_32, %eax
        # get procedure
        push %eax
        movl (_totally_macroexpand_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_emit_malloc_n_4), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_40:
        .long 0x2ce11ed
        .long _set_union_all_12
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_39:
        .long 0x2ce11ed
        .long _sample_abcd_4
        .long _totally_macroexpand_40
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_38:
        .long 0x2ce11ed
        .long 2 + 258<<2
        .long _totally_macroexpand_39
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_37:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long _totally_macroexpand_38
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_36:
        .long 0x2ce11ed
        .long _free_vars_17
        .long _totally_macroexpand_37
        .text
        push %eax
        movl $_totally_macroexpand_36, %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_44:
        .long 0x2ce11ed
        .long _sample_abcd_4
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_43:
        .long 0x2ce11ed
        .long _set_union_all_12
        .long _totally_macroexpand_44
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_42:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long _totally_macroexpand_43
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_41:
        .long 0x2ce11ed
        .long _macroexpand_1_20
        .long _totally_macroexpand_42
        .text
        push %eax
        movl $_totally_macroexpand_41, %eax
        # get procedure
        push %eax
        movl (_totally_macroexpand_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_emit_malloc_n_4), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_47:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_50:
        .long 0x2ce11ed
        .long _set_union_all_12
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_49:
        .long 0x2ce11ed
        .long _sample_abcd_4
        .long _totally_macroexpand_50
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_48:
        .long 0x2ce11ed
        .long 2 + 258<<2
        .long _totally_macroexpand_49
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_46:
        .long 0x2ce11ed
        .long _totally_macroexpand_47
        .long _totally_macroexpand_48
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_45:
        .long 0x2ce11ed
        .long _free_vars_17
        .long _totally_macroexpand_46
        .text
        push %eax
        movl $_totally_macroexpand_45, %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_53:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_55:
        .long 0x2ce11ed
        .long _sample_abcd_4
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_54:
        .long 0x2ce11ed
        .long _set_union_all_12
        .long _totally_macroexpand_55
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_52:
        .long 0x2ce11ed
        .long _totally_macroexpand_53
        .long _totally_macroexpand_54
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_51:
        .long 0x2ce11ed
        .long _macroexpand_1_20
        .long _totally_macroexpand_52
        .text
        push %eax
        movl $_totally_macroexpand_51, %eax
        # get procedure
        push %eax
        movl (_totally_macroexpand_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_emit_malloc_n_4), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_58:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_61:
        .long 0x2ce11ed
        .long _set_union_all_12
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_60:
        .long 0x2ce11ed
        .long 2 + 258<<2
        .long _totally_macroexpand_61
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_59:
        .long 0x2ce11ed
        .long 2 + 258<<2
        .long _totally_macroexpand_60
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_57:
        .long 0x2ce11ed
        .long _totally_macroexpand_58
        .long _totally_macroexpand_59
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_56:
        .long 0x2ce11ed
        .long _free_vars_17
        .long _totally_macroexpand_57
        .text
        push %eax
        movl $_totally_macroexpand_56, %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_64:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_65:
        .long 0x2ce11ed
        .long _set_union_all_12
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_63:
        .long 0x2ce11ed
        .long _totally_macroexpand_64
        .long _totally_macroexpand_65
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_62:
        .long 0x2ce11ed
        .long _macroexpand_1_20
        .long _totally_macroexpand_63
        .text
        push %eax
        movl $_totally_macroexpand_62, %eax
        # get procedure
        push %eax
        movl (_totally_macroexpand_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_emit_malloc_n_4), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_70:
        .long 0x2ce11ed
        .long _sample_abcd_4
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_69:
        .long 0x2ce11ed
        .long _set_union_all_12
        .long _totally_macroexpand_70
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_68:
        .long 0x2ce11ed
        .long 2 + 258<<2
        .long _totally_macroexpand_69
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_67:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long _totally_macroexpand_68
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_66:
        .long 0x2ce11ed
        .long _free_vars_17
        .long _totally_macroexpand_67
        .text
        push %eax
        movl $_totally_macroexpand_66, %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_74:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_73:
        .long 0x2ce11ed
        .long _macroexpand_1_88
        .long _totally_macroexpand_74
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_76:
        .long 0x2ce11ed
        .long _sample_abcd_4
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_75:
        .long 0x2ce11ed
        .long _set_union_all_12
        .long _totally_macroexpand_76
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_72:
        .long 0x2ce11ed
        .long _totally_macroexpand_73
        .long _totally_macroexpand_75
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_71:
        .long 0x2ce11ed
        .long _macroexpand_1_20
        .long _totally_macroexpand_72
        .text
        push %eax
        movl $_totally_macroexpand_71, %eax
        # get procedure
        push %eax
        movl (_totally_macroexpand_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_emit_malloc_n_4), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_81:
        .long 0x2ce11ed
        .long 2 + 256<<2
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_80:
        .long 0x2ce11ed
        .long _free_vars_20
        .long _totally_macroexpand_81
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_83:
        .long 0x2ce11ed
        .long _sample_abcd_4
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_82:
        .long 0x2ce11ed
        .long _set_union_all_12
        .long _totally_macroexpand_83
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_79:
        .long 0x2ce11ed
        .long _totally_macroexpand_80
        .long _totally_macroexpand_82
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_78:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long _totally_macroexpand_79
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_77:
        .long 0x2ce11ed
        .long _free_vars_17
        .long _totally_macroexpand_78
        .text
        push %eax
        movl $_totally_macroexpand_77, %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_87:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_86:
        .long 0x2ce11ed
        .long _macroexpand_1_85
        .long _totally_macroexpand_87
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_89:
        .long 0x2ce11ed
        .long _sample_abcd_4
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_88:
        .long 0x2ce11ed
        .long _set_union_all_12
        .long _totally_macroexpand_89
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_85:
        .long 0x2ce11ed
        .long _totally_macroexpand_86
        .long _totally_macroexpand_88
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_84:
        .long 0x2ce11ed
        .long _macroexpand_1_20
        .long _totally_macroexpand_85
        .text
        push %eax
        movl $_totally_macroexpand_84, %eax
        # get procedure
        push %eax
        movl (_totally_macroexpand_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_emit_malloc_n_4), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_100:
        .long 0x2ce11ed
        .long 1 + 3<<2
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_99:
        .long 0x2ce11ed
        .long _macroexpand_1_19
        .long _totally_macroexpand_100
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_98:
        .long 0x2ce11ed
        .long _totally_macroexpand_99
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_97:
        .long 0x2ce11ed
        .long _free_vars_20
        .long _totally_macroexpand_98
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_96:
        .long 0x2ce11ed
        .long _totally_macroexpand_97
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_95:
        .long 0x2ce11ed
        .long 1 + 4<<2
        .long _totally_macroexpand_96
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_94:
        .long 0x2ce11ed
        .long _free_vars_15
        .long _totally_macroexpand_95
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_107:
        .long 0x2ce11ed
        .long 1 + 8<<2
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_106:
        .long 0x2ce11ed
        .long _free_vars_15
        .long _totally_macroexpand_107
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_111:
        .long 0x2ce11ed
        .long 1 + 7<<2
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_110:
        .long 0x2ce11ed
        .long 1 + 6<<2
        .long _totally_macroexpand_111
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_109:
        .long 0x2ce11ed
        .long _free_vars_15
        .long _totally_macroexpand_110
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_108:
        .long 0x2ce11ed
        .long _totally_macroexpand_109
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_105:
        .long 0x2ce11ed
        .long _totally_macroexpand_106
        .long _totally_macroexpand_108
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_104:
        .long 0x2ce11ed
        .long 1 + 4<<2
        .long _totally_macroexpand_105
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_103:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long _totally_macroexpand_104
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_102:
        .long 0x2ce11ed
        .long _free_vars_17
        .long _totally_macroexpand_103
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_101:
        .long 0x2ce11ed
        .long _totally_macroexpand_102
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_93:
        .long 0x2ce11ed
        .long _totally_macroexpand_94
        .long _totally_macroexpand_101
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_92:
        .long 0x2ce11ed
        .long 1 + 3<<2
        .long _totally_macroexpand_93
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_91:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long _totally_macroexpand_92
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_90:
        .long 0x2ce11ed
        .long _free_vars_17
        .long _totally_macroexpand_91
        .text
        push %eax
        movl $_totally_macroexpand_90, %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_117:
        .long 0x2ce11ed
        .long 1 + 3<<2
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_116:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long _totally_macroexpand_117
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_115:
        .long 0x2ce11ed
        .long _macroexpand_1_79
        .long _totally_macroexpand_116
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_123:
        .long 0x2ce11ed
        .long 1 + 3<<2
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_122:
        .long 0x2ce11ed
        .long _macroexpand_1_19
        .long _totally_macroexpand_123
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_121:
        .long 0x2ce11ed
        .long _totally_macroexpand_122
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_120:
        .long 0x2ce11ed
        .long _free_vars_20
        .long _totally_macroexpand_121
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_119:
        .long 0x2ce11ed
        .long _totally_macroexpand_120
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_118:
        .long 0x2ce11ed
        .long 1 + 4<<2
        .long _totally_macroexpand_119
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_114:
        .long 0x2ce11ed
        .long _totally_macroexpand_115
        .long _totally_macroexpand_118
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_128:
        .long 0x2ce11ed
        .long 1 + 4<<2
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_127:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long _totally_macroexpand_128
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_126:
        .long 0x2ce11ed
        .long _macroexpand_1_79
        .long _totally_macroexpand_127
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_129:
        .long 0x2ce11ed
        .long 1 + 8<<2
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_125:
        .long 0x2ce11ed
        .long _totally_macroexpand_126
        .long _totally_macroexpand_129
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_133:
        .long 0x2ce11ed
        .long 1 + 7<<2
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_132:
        .long 0x2ce11ed
        .long 1 + 6<<2
        .long _totally_macroexpand_133
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_131:
        .long 0x2ce11ed
        .long _macroexpand_1_18
        .long _totally_macroexpand_132
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_130:
        .long 0x2ce11ed
        .long _totally_macroexpand_131
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_124:
        .long 0x2ce11ed
        .long _totally_macroexpand_125
        .long _totally_macroexpand_130
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_113:
        .long 0x2ce11ed
        .long _totally_macroexpand_114
        .long _totally_macroexpand_124
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_112:
        .long 0x2ce11ed
        .long _macroexpand_1_19
        .long _totally_macroexpand_113
        .text
        push %eax
        movl $_totally_macroexpand_112, %eax
        # get procedure
        push %eax
        movl (_totally_macroexpand_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_emit_malloc_n_4), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_143:
        .long 0x2ce11ed
        .long 1 + 3<<2
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_142:
        .long 0x2ce11ed
        .long 1 + 2<<2
        .long _totally_macroexpand_143
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_141:
        .long 0x2ce11ed
        .long 2 + 113<<2
        .long _totally_macroexpand_142
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_140:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long _totally_macroexpand_141
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_139:
        .long 0x2ce11ed
        .long _free_vars_17
        .long _totally_macroexpand_140
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_138:
        .long 0x2ce11ed
        .long _totally_macroexpand_139
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_137:
        .long 0x2ce11ed
        .long 1 + 1<<2
        .long _totally_macroexpand_138
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_136:
        .long 0x2ce11ed
        .long 1 + 0<<2
        .long _totally_macroexpand_137
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_135:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long _totally_macroexpand_136
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_134:
        .long 0x2ce11ed
        .long _free_vars_17
        .long _totally_macroexpand_135
        .text
        push %eax
        movl $_totally_macroexpand_134, %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_148:
        .long 0x2ce11ed
        .long 1 + 0<<2
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_147:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long _totally_macroexpand_148
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_146:
        .long 0x2ce11ed
        .long _macroexpand_1_82
        .long _totally_macroexpand_147
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_155:
        .long 0x2ce11ed
        .long 2 + 113<<2
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_154:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long _totally_macroexpand_155
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_153:
        .long 0x2ce11ed
        .long _macroexpand_1_44
        .long _totally_macroexpand_154
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_157:
        .long 0x2ce11ed
        .long 1 + 3<<2
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_156:
        .long 0x2ce11ed
        .long 1 + 2<<2
        .long _totally_macroexpand_157
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_152:
        .long 0x2ce11ed
        .long _totally_macroexpand_153
        .long _totally_macroexpand_156
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_151:
        .long 0x2ce11ed
        .long _macroexpand_1_20
        .long _totally_macroexpand_152
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_150:
        .long 0x2ce11ed
        .long _totally_macroexpand_151
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_149:
        .long 0x2ce11ed
        .long 1 + 1<<2
        .long _totally_macroexpand_150
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_145:
        .long 0x2ce11ed
        .long _totally_macroexpand_146
        .long _totally_macroexpand_149
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_144:
        .long 0x2ce11ed
        .long _macroexpand_1_20
        .long _totally_macroexpand_145
        .text
        push %eax
        movl $_totally_macroexpand_144, %eax
        # get procedure
        push %eax
        movl (_totally_macroexpand_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_emit_malloc_n_4), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_163:
        .long 0x2ce11ed
        .long _sample_abcd_4
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_162:
        .long 0x2ce11ed
        .long _set_union_all_12
        .long _totally_macroexpand_163
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_161:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long _totally_macroexpand_162
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_160:
        .long 0x2ce11ed
        .long 2 + 256<<2
        .long _totally_macroexpand_161
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_159:
        .long 0x2ce11ed
        .long _lambdas_8
        .long _totally_macroexpand_160
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_158:
        .long 0x2ce11ed
        .long _totally_macroexpand_159
        .long 2 + 256<<2
        .text
        push %eax
        movl $_totally_macroexpand_158, %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_168:
        .long 0x2ce11ed
        .long _sample_abcd_4
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_167:
        .long 0x2ce11ed
        .long _set_union_all_12
        .long _totally_macroexpand_168
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_166:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long _totally_macroexpand_167
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_165:
        .long 0x2ce11ed
        .long 2 + 256<<2
        .long _totally_macroexpand_166
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_164:
        .long 0x2ce11ed
        .long _macroexpand_1_31
        .long _totally_macroexpand_165
        .text
        push %eax
        movl $_totally_macroexpand_164, %eax
        # get procedure
        push %eax
        movl (_totally_macroexpand_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_emit_malloc_n_4), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_173:
        .long 0x2ce11ed
        .long _set_union_all_12
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_172:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long _totally_macroexpand_173
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_176:
        .long 0x2ce11ed
        .long _sample_abcd_4
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_175:
        .long 0x2ce11ed
        .long _set_union_all_12
        .long _totally_macroexpand_176
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_174:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long _totally_macroexpand_175
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_171:
        .long 0x2ce11ed
        .long _totally_macroexpand_172
        .long _totally_macroexpand_174
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_170:
        .long 0x2ce11ed
        .long _lambdas_8
        .long _totally_macroexpand_171
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_178:
        .long 0x2ce11ed
        .long 1 + 2<<2
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_177:
        .long 0x2ce11ed
        .long 1 + 1<<2
        .long _totally_macroexpand_178
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_169:
        .long 0x2ce11ed
        .long _totally_macroexpand_170
        .long _totally_macroexpand_177
        .text
        push %eax
        movl $_totally_macroexpand_169, %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_183:
        .long 0x2ce11ed
        .long 1 + 1<<2
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_182:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long _totally_macroexpand_183
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_186:
        .long 0x2ce11ed
        .long 1 + 2<<2
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_185:
        .long 0x2ce11ed
        .long _set_union_all_12
        .long _totally_macroexpand_186
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_184:
        .long 0x2ce11ed
        .long _totally_macroexpand_185
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_181:
        .long 0x2ce11ed
        .long _totally_macroexpand_182
        .long _totally_macroexpand_184
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_189:
        .long 0x2ce11ed
        .long _sample_abcd_4
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_188:
        .long 0x2ce11ed
        .long _set_union_all_12
        .long _totally_macroexpand_189
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_187:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long _totally_macroexpand_188
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_180:
        .long 0x2ce11ed
        .long _totally_macroexpand_181
        .long _totally_macroexpand_187
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_179:
        .long 0x2ce11ed
        .long _macroexpand_1_31
        .long _totally_macroexpand_180
        .text
        push %eax
        movl $_totally_macroexpand_179, %eax
        # get procedure
        push %eax
        movl (_totally_macroexpand_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_emit_malloc_n_4), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_199:
        .long 0x2ce11ed
        .long _sample_abcd_4
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_198:
        .long 0x2ce11ed
        .long 2 + 258<<2
        .long _totally_macroexpand_199
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_197:
        .long 0x2ce11ed
        .long 2 + 258<<2
        .long _totally_macroexpand_198
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_196:
        .long 0x2ce11ed
        .long _set_union_all_12
        .long _totally_macroexpand_197
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_195:
        .long 0x2ce11ed
        .long _free_vars_17
        .long _totally_macroexpand_196
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_194:
        .long 0x2ce11ed
        .long _totally_macroexpand_195
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_193:
        .long 0x2ce11ed
        .long 2 + 258<<2
        .long _totally_macroexpand_194
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_192:
        .long 0x2ce11ed
        .long 2 + 258<<2
        .long _totally_macroexpand_193
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_191:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long _totally_macroexpand_192
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_190:
        .long 0x2ce11ed
        .long _free_vars_17
        .long _totally_macroexpand_191
        .text
        push %eax
        movl $_totally_macroexpand_190, %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_203:
        .long 0x2ce11ed
        .long _sample_abcd_4
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_202:
        .long 0x2ce11ed
        .long _set_union_all_12
        .long _totally_macroexpand_203
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_201:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long _totally_macroexpand_202
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_200:
        .long 0x2ce11ed
        .long _macroexpand_1_63
        .long _totally_macroexpand_201
        .text
        push %eax
        movl $_totally_macroexpand_200, %eax
        # get procedure
        push %eax
        movl (_totally_macroexpand_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_emit_malloc_n_4), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_208:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_207:
        .long 0x2ce11ed
        .long _macroexpand_1_55
        .long _totally_macroexpand_208
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_206:
        .long 0x2ce11ed
        .long _totally_macroexpand_207
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_218:
        .long 0x2ce11ed
        .long _set_union_all_12
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_217:
        .long 0x2ce11ed
        .long _macroexpand_1_55
        .long _totally_macroexpand_218
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_216:
        .long 0x2ce11ed
        .long _totally_macroexpand_217
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_223:
        .long 0x2ce11ed
        .long _sample_abcd_4
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_222:
        .long 0x2ce11ed
        .long _macroexpand_1_55
        .long _totally_macroexpand_223
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_221:
        .long 0x2ce11ed
        .long _macroexpand_1_55
        .long _totally_macroexpand_222
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_220:
        .long 0x2ce11ed
        .long _macroexpand_1_20
        .long _totally_macroexpand_221
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_219:
        .long 0x2ce11ed
        .long _totally_macroexpand_220
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_215:
        .long 0x2ce11ed
        .long _totally_macroexpand_216
        .long _totally_macroexpand_219
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_214:
        .long 0x2ce11ed
        .long _macroexpand_1_31
        .long _totally_macroexpand_215
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_213:
        .long 0x2ce11ed
        .long _totally_macroexpand_214
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_212:
        .long 0x2ce11ed
        .long _macroexpand_1_55
        .long _totally_macroexpand_213
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_211:
        .long 0x2ce11ed
        .long _macroexpand_1_55
        .long _totally_macroexpand_212
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_210:
        .long 0x2ce11ed
        .long _macroexpand_1_20
        .long _totally_macroexpand_211
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_209:
        .long 0x2ce11ed
        .long _totally_macroexpand_210
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_205:
        .long 0x2ce11ed
        .long _totally_macroexpand_206
        .long _totally_macroexpand_209
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_204:
        .long 0x2ce11ed
        .long _macroexpand_1_31
        .long _totally_macroexpand_205
        .text
        push %eax
        movl $_totally_macroexpand_204, %eax
        # get procedure
        push %eax
        movl (_totally_macroexpand_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_227:
        .long 0x2ce11ed
        .long _sample_abcd_4
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_226:
        .long 0x2ce11ed
        .long _set_union_all_12
        .long _totally_macroexpand_227
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_225:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long _totally_macroexpand_226
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_224:
        .long 0x2ce11ed
        .long _macroexpand_1_54
        .long _totally_macroexpand_225
        .text
        push %eax
        movl $_totally_macroexpand_224, %eax
        # get procedure
        push %eax
        movl (_totally_macroexpand_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_emit_malloc_n_4), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_232:
        .long 0x2ce11ed
        .long _sample_begin_expr_23
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_231:
        .long 0x2ce11ed
        .long _free_vars_20
        .long _totally_macroexpand_232
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_235:
        .long 0x2ce11ed
        .long _sample_begin_expr_10
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_234:
        .long 0x2ce11ed
        .long _free_vars_15
        .long _totally_macroexpand_235
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_238:
        .long 0x2ce11ed
        .long _totally_macroexpand_239
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_237:
        .long 0x2ce11ed
        .long _free_vars_15
        .long _totally_macroexpand_238
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_236:
        .long 0x2ce11ed
        .long _totally_macroexpand_237
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_233:
        .long 0x2ce11ed
        .long _totally_macroexpand_234
        .long _totally_macroexpand_236
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_230:
        .long 0x2ce11ed
        .long _totally_macroexpand_231
        .long _totally_macroexpand_233
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_229:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long _totally_macroexpand_230
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_228:
        .long 0x2ce11ed
        .long _free_vars_17
        .long _totally_macroexpand_229
        .text
        push %eax
        movl $_totally_macroexpand_228, %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_244:
        .long 0x2ce11ed
        .long _sample_begin_expr_23
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_245:
        .long 0x2ce11ed
        .long _sample_begin_expr_10
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_243:
        .long 0x2ce11ed
        .long _totally_macroexpand_244
        .long _totally_macroexpand_245
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_248:
        .long 0x2ce11ed
        .long _totally_macroexpand_239
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_247:
        .long 0x2ce11ed
        .long _macroexpand_1_18
        .long _totally_macroexpand_248
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_246:
        .long 0x2ce11ed
        .long _totally_macroexpand_247
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_242:
        .long 0x2ce11ed
        .long _totally_macroexpand_243
        .long _totally_macroexpand_246
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_241:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long _totally_macroexpand_242
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_240:
        .long 0x2ce11ed
        .long _macroexpand_1_41
        .long _totally_macroexpand_241
        .text
        push %eax
        movl $_totally_macroexpand_240, %eax
        # get procedure
        push %eax
        movl (_totally_macroexpand_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_emit_malloc_n_4), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_258:
        .long 0x2ce11ed
        .long _totally_macroexpand_259
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_256:
        .long 0x2ce11ed
        .long _totally_macroexpand_257
        .long _totally_macroexpand_258
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_255:
        .long 0x2ce11ed
        .long _macroexpand_1_18
        .long _totally_macroexpand_256
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_253:
        .long 0x2ce11ed
        .long _totally_macroexpand_254
        .long _totally_macroexpand_255
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_252:
        .long 0x2ce11ed
        .long _macroexpand_1_19
        .long _totally_macroexpand_253
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_266:
        .long 0x2ce11ed
        .long 2 + 258<<2
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_264:
        .long 0x2ce11ed
        .long _totally_macroexpand_265
        .long _totally_macroexpand_266
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_263:
        .long 0x2ce11ed
        .long _macroexpand_1_19
        .long _totally_macroexpand_264
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_261:
        .long 0x2ce11ed
        .long _totally_macroexpand_262
        .long _totally_macroexpand_263
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_270:
        .long 0x2ce11ed
        .long _totally_macroexpand_257
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_268:
        .long 0x2ce11ed
        .long _totally_macroexpand_269
        .long _totally_macroexpand_270
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_267:
        .long 0x2ce11ed
        .long _totally_macroexpand_268
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_260:
        .long 0x2ce11ed
        .long _totally_macroexpand_261
        .long _totally_macroexpand_267
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_251:
        .long 0x2ce11ed
        .long _totally_macroexpand_252
        .long _totally_macroexpand_260
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_250:
        .long 0x2ce11ed
        .long _lambdas_8
        .long _totally_macroexpand_251
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_273:
        .long 0x2ce11ed
        .long _totally_macroexpand_274
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_272:
        .long 0x2ce11ed
        .long _inline_primitive_22
        .long _totally_macroexpand_273
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_278:
        .long 0x2ce11ed
        .long _totally_macroexpand_274
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_276:
        .long 0x2ce11ed
        .long _totally_macroexpand_277
        .long _totally_macroexpand_278
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_282:
        .long 0x2ce11ed
        .long _totally_macroexpand_274
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_280:
        .long 0x2ce11ed
        .long _totally_macroexpand_281
        .long _totally_macroexpand_282
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_284:
        .long 0x2ce11ed
        .long _totally_macroexpand_285
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_287:
        .long 0x2ce11ed
        .long _totally_macroexpand_285
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_286:
        .long 0x2ce11ed
        .long _totally_macroexpand_287
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_283:
        .long 0x2ce11ed
        .long _totally_macroexpand_284
        .long _totally_macroexpand_286
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_279:
        .long 0x2ce11ed
        .long _totally_macroexpand_280
        .long _totally_macroexpand_283
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_275:
        .long 0x2ce11ed
        .long _totally_macroexpand_276
        .long _totally_macroexpand_279
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_271:
        .long 0x2ce11ed
        .long _totally_macroexpand_272
        .long _totally_macroexpand_275
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_249:
        .long 0x2ce11ed
        .long _totally_macroexpand_250
        .long _totally_macroexpand_271
        .text
        push %eax
        movl $_totally_macroexpand_249, %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_294:
        .long 0x2ce11ed
        .long _totally_macroexpand_274
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_293:
        .long 0x2ce11ed
        .long _inline_primitive_22
        .long _totally_macroexpand_294
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_292:
        .long 0x2ce11ed
        .long _totally_macroexpand_293
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_291:
        .long 0x2ce11ed
        .long _macroexpand_1_19
        .long _totally_macroexpand_292
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_299:
        .long 0x2ce11ed
        .long _totally_macroexpand_274
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_298:
        .long 0x2ce11ed
        .long _totally_macroexpand_277
        .long _totally_macroexpand_299
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_297:
        .long 0x2ce11ed
        .long _totally_macroexpand_298
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_296:
        .long 0x2ce11ed
        .long _totally_macroexpand_254
        .long _totally_macroexpand_297
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_304:
        .long 0x2ce11ed
        .long _totally_macroexpand_274
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_303:
        .long 0x2ce11ed
        .long _totally_macroexpand_281
        .long _totally_macroexpand_304
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_302:
        .long 0x2ce11ed
        .long _totally_macroexpand_303
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_301:
        .long 0x2ce11ed
        .long _macroexpand_1_18
        .long _totally_macroexpand_302
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_308:
        .long 0x2ce11ed
        .long _totally_macroexpand_285
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_307:
        .long 0x2ce11ed
        .long _totally_macroexpand_308
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_306:
        .long 0x2ce11ed
        .long _totally_macroexpand_257
        .long _totally_macroexpand_307
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_312:
        .long 0x2ce11ed
        .long _totally_macroexpand_285
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_311:
        .long 0x2ce11ed
        .long _totally_macroexpand_312
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_310:
        .long 0x2ce11ed
        .long _totally_macroexpand_259
        .long _totally_macroexpand_311
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_309:
        .long 0x2ce11ed
        .long _totally_macroexpand_310
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_305:
        .long 0x2ce11ed
        .long _totally_macroexpand_306
        .long _totally_macroexpand_309
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_300:
        .long 0x2ce11ed
        .long _totally_macroexpand_301
        .long _totally_macroexpand_305
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_295:
        .long 0x2ce11ed
        .long _totally_macroexpand_296
        .long _totally_macroexpand_300
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_290:
        .long 0x2ce11ed
        .long _totally_macroexpand_291
        .long _totally_macroexpand_295
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_317:
        .long 0x2ce11ed
        .long 2 + 258<<2
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_316:
        .long 0x2ce11ed
        .long _totally_macroexpand_265
        .long _totally_macroexpand_317
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_315:
        .long 0x2ce11ed
        .long _macroexpand_1_19
        .long _totally_macroexpand_316
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_314:
        .long 0x2ce11ed
        .long _totally_macroexpand_262
        .long _totally_macroexpand_315
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_320:
        .long 0x2ce11ed
        .long _totally_macroexpand_257
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_319:
        .long 0x2ce11ed
        .long _totally_macroexpand_269
        .long _totally_macroexpand_320
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_318:
        .long 0x2ce11ed
        .long _totally_macroexpand_319
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_313:
        .long 0x2ce11ed
        .long _totally_macroexpand_314
        .long _totally_macroexpand_318
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_289:
        .long 0x2ce11ed
        .long _totally_macroexpand_290
        .long _totally_macroexpand_313
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_288:
        .long 0x2ce11ed
        .long _macroexpand_1_31
        .long _totally_macroexpand_289
        .text
        push %eax
        movl $_totally_macroexpand_288, %eax
        # get procedure
        push %eax
        movl (_totally_macroexpand_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_emit_malloc_n_4), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .data
_compile_toplevel_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _compile_toplevel_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_toplevel_3:
        .long 0xca11ab1e
        .long _compile_toplevel_4
        .long 0
        .text
        .type _compile_toplevel_4, @function
_compile_toplevel_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_totally_macroexpand_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_compile_toplevel_5), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _compile_toplevel_4, .-_compile_toplevel_4
_compile_toplevel_2:
        push %eax
        movl $_compile_toplevel_3, %eax
        # initialize global variable with value
        movl %eax, (_compile_toplevel_1)
        pop %eax
        .section .data
_compile_toplevel_5:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _compile_toplevel_expanded_1
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_toplevel_expanded_2:
        .long 0xca11ab1e
        .long _compile_toplevel_expanded_3
        .long 0
        .text
        .type _compile_toplevel_expanded_3, @function
_compile_toplevel_expanded_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        push %eax
        movl $_macroexpand_1_26, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _compile_toplevel_expanded_4
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_cadr_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_set_label_prefix_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_global_env_1), %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_caddr_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_cadr_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_compile_toplevel_define_1), %eax
        # apply procedure
        # Tail call; nargs = 3
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 8(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push -8(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $3, %edx
        jmp *%ebx
        jmp _compile_toplevel_expanded_5
_compile_toplevel_expanded_4:
        push %eax
        movl (_global_env_1), %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_compile_discarding_1), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
_compile_toplevel_expanded_5:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _compile_toplevel_expanded_3, .-_compile_toplevel_expanded_3
_compile_toplevel_expanded_1:
        push %eax
        movl $_compile_toplevel_expanded_2, %eax
        # initialize global variable with value
        movl %eax, (_compile_toplevel_5)
        pop %eax
        .section .data
_ungettable_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _ungettable_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_ungettable_3:
        .long 0xca11ab1e
        .long _ungettable_4
        .long 0
        .text
        .type _ungettable_4, @function
_ungettable_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # move arg from stack to heap: thunk
        push %eax
        movl 0(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        push %eax
        movl $2 + 258<<2, %eax
        push %eax
        movl $2 + 258<<2, %eax
        # get procedure
        # jump past the body of the lambda
        jmp _ungettable_5
        .text
        .type _ungettable_6, @function
_ungettable_6:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $2, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 thunk
        push 12(%eax)
        # discarding useless value in %eax
        pop %eax
        # move arg from stack to heap: ungot
        push %eax
        movl 0(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # move arg from stack to heap: last
        push %eax
        movl 4(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # jump past the body of the lambda
        jmp _ungettable_7
        .text
        .type _ungettable_8, @function
_ungettable_8:
        # make space for variadic argument list
        pop %ebx
        push %ebx
        push %ebx
        # push desired %esp on return
        lea 8(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        call package_up_variadic_args
        # fetch artifact from closure: 0 thunk
        push 12(%eax)
        # fetch artifact from closure: 1 ungot
        push 16(%eax)
        # fetch artifact from closure: 2 last
        push 20(%eax)
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl $2 + 256<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _ungettable_9
        # %ifeq
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _ungettable_11
        # get procedure
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        # fetching heap var pointer 2
        push %eax
        movl -24(%ebp), %eax
        movl (%esp), %ebx
        movl %ebx, 4(%eax)
        pop %eax
        pop %eax
        # fetching heap var pointer 2
        push %eax
        movl -24(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        jmp _ungettable_12
_ungettable_11:
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        # jump past the body of the lambda
        jmp _ungettable_13
        .text
        .type _ungettable_14, @function
_ungettable_14:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 ungot
        push 12(%eax)
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl $2 + 258<<2, %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl (%esp), %ebx
        movl %ebx, 4(%eax)
        pop %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _ungettable_14, .-_ungettable_14
_ungettable_13:
        # allocate bytes: 16
        push %eax
        movl (arena_pointer), %eax
        add $16, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_ungettable_14, 4(%ebx)
        movl $1, 8(%ebx)
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
_ungettable_12:
        jmp _ungettable_10
_ungettable_9:
        # fetching heap var pointer 2
        push %eax
        movl -24(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        movl (%esp), %ebx
        movl %ebx, 4(%eax)
        pop %eax
_ungettable_10:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _ungettable_8, .-_ungettable_8
_ungettable_7:
        # allocate bytes: 24
        push %eax
        movl (arena_pointer), %eax
        add $24, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_ungettable_8, 4(%ebx)
        movl $3, 8(%ebx)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        movl %eax, 16(%ebx)
        pop %eax
        # fetching heap var pointer 2
        push %eax
        movl -24(%ebp), %eax
        movl %eax, 20(%ebx)
        pop %eax
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _ungettable_6, .-_ungettable_6
_ungettable_5:
        # allocate bytes: 16
        push %eax
        movl (arena_pointer), %eax
        add $16, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_ungettable_6, 4(%ebx)
        movl $1, 8(%ebx)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _ungettable_4, .-_ungettable_4
_ungettable_2:
        push %eax
        movl $_ungettable_3, %eax
        # initialize global variable with value
        movl %eax, (_ungettable_1)
        pop %eax
        .section .data
_read_from_string_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _read_from_string_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_from_string_3:
        .long 0xca11ab1e
        .long _read_from_string_4
        .long 0
        .text
        .type _read_from_string_4, @function
_read_from_string_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # move arg from stack to heap: string
        push %eax
        movl 0(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        push %eax
        movl $1 + 0<<2, %eax
        # get procedure
        # jump past the body of the lambda
        jmp _read_from_string_5
        .text
        .type _read_from_string_6, @function
_read_from_string_6:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 string
        push 12(%eax)
        # discarding useless value in %eax
        pop %eax
        # move arg from stack to heap: pos
        push %eax
        movl 0(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # jump past the body of the lambda
        jmp _read_from_string_7
        .text
        .type _read_from_string_8, @function
_read_from_string_8:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $0, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 string
        push 12(%eax)
        # fetch artifact from closure: 1 pos
        push 16(%eax)
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # string-length inlined primitive
        call ensure_string
        lea 8(%eax), %ebx
        push %ebx
        movl 4(%eax), %eax
        pop %ebx
        sal %eax
        sal %eax
        inc %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _read_from_string_9
        push %eax
        movl $_read_from_string_11, %eax
        jmp _read_from_string_10
_read_from_string_9:
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # 1+
        call ensure_integer
        add $1<<2, %eax
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        movl (%esp), %ebx
        movl %ebx, 4(%eax)
        pop %eax
        pop %eax
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        call ensure_integer
        add $-1<<2, %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_string_ref_2), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
_read_from_string_10:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _read_from_string_8, .-_read_from_string_8
_read_from_string_7:
        # allocate bytes: 20
        push %eax
        movl (arena_pointer), %eax
        add $20, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_read_from_string_8, 4(%ebx)
        movl $2, 8(%ebx)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # fetching heap var pointer 1
        push %eax
        movl -20(%ebp), %eax
        movl %eax, 16(%ebx)
        pop %eax
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _read_from_string_6, .-_read_from_string_6
_read_from_string_5:
        # allocate bytes: 16
        push %eax
        movl (arena_pointer), %eax
        add $16, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_read_from_string_6, 4(%ebx)
        movl $1, 8(%ebx)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _read_from_string_4, .-_read_from_string_4
_read_from_string_2:
        push %eax
        movl $_read_from_string_3, %eax
        # initialize global variable with value
        movl %eax, (_read_from_string_1)
        pop %eax
        .section .data
_sample_sr_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_sr_2:
        .long 0xbabb1e
        .long 3
        .ascii "foo"
        .text
        push %eax
        movl $_sample_sr_2, %eax
        # get procedure
        push %eax
        movl (_read_from_string_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # initialize global variable with value
        movl %eax, (_sample_sr_1)
        pop %eax
        push %eax
        movl $2 + 102<<2, %eax
        # get procedure
        push %eax
        movl (_sample_sr_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_emit_malloc_n_4), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl $2 + 111<<2, %eax
        # get procedure
        push %eax
        movl (_sample_sr_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_emit_malloc_n_4), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl $2 + 111<<2, %eax
        # get procedure
        push %eax
        movl (_sample_sr_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_emit_malloc_n_4), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl $_read_from_string_11, %eax
        # get procedure
        push %eax
        movl (_sample_sr_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_emit_malloc_n_4), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl $_read_from_string_11, %eax
        # get procedure
        push %eax
        movl (_sample_sr_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_emit_malloc_n_4), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .data
_sample_unget_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_unget_2:
        .long 0xbabb1e
        .long 3
        .ascii "foo"
        .text
        push %eax
        movl $_sample_unget_2, %eax
        # get procedure
        push %eax
        movl (_read_from_string_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_ungettable_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # initialize global variable with value
        movl %eax, (_sample_unget_1)
        pop %eax
        push %eax
        movl $2 + 102<<2, %eax
        # get procedure
        push %eax
        movl (_sample_unget_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_emit_malloc_n_4), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl $_sample_unget_3, %eax
        # get procedure
        push %eax
        movl (_sample_unget_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl $2 + 102<<2, %eax
        # get procedure
        push %eax
        movl (_sample_unget_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_emit_malloc_n_4), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl $2 + 111<<2, %eax
        # get procedure
        push %eax
        movl (_sample_unget_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_emit_malloc_n_4), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl $2 + 111<<2, %eax
        # get procedure
        push %eax
        movl (_sample_unget_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_emit_malloc_n_4), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl $_read_from_string_11, %eax
        # get procedure
        push %eax
        movl (_sample_unget_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_emit_malloc_n_4), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .data
_parse_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _parse_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_3:
        .long 0xca11ab1e
        .long _parse_4
        .long 0
        .text
        .type _parse_4, @function
_parse_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # move arg from stack to heap: s
        push %eax
        movl 0(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_parse_5), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        # jump past the body of the lambda
        jmp _parse_6
        .text
        .type _parse_7, @function
_parse_7:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 s
        push 12(%eax)
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_parse_10), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _parse_8
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl $2 + 40<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _parse_11
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_parse_5), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_parse_13), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        jmp _parse_12
_parse_11:
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl $2 + 39<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _parse_14
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_parse_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $_free_vars_20, %eax
        # get procedure
        push %eax
        movl (_list_1), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        jmp _parse_15
_parse_14:
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl $2 + 34<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _parse_16
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_parse_18), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        jmp _parse_17
_parse_16:
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl $2 + 35<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _parse_19
        # get procedure
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_parse_21), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        jmp _parse_20
_parse_19:
        push %eax
        movl $_sample_unget_3, %eax
        # get procedure
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_parse_22), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
_parse_20:
_parse_17:
_parse_15:
_parse_12:
        jmp _parse_9
_parse_8:
        push %eax
        movl 0(%ebp), %eax
_parse_9:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _parse_7, .-_parse_7
_parse_6:
        # allocate bytes: 16
        push %eax
        movl (arena_pointer), %eax
        add $16, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_parse_7, 4(%ebx)
        movl $1, 8(%ebx)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _parse_4, .-_parse_4
_parse_2:
        push %eax
        movl $_parse_3, %eax
        # initialize global variable with value
        movl %eax, (_parse_1)
        pop %eax
        .section .data
_parse_13:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _parse_list_1
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_list_2:
        .long 0xca11ab1e
        .long _parse_list_3
        .long 0
        .text
        .type _parse_list_3, @function
_parse_list_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $2, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # move arg from stack to heap: s
        push %eax
        movl 0(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # %ifeq
        push %eax
        movl 4(%ebp), %eax
        # get procedure
        push %eax
        movl (_parse_10), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _parse_list_4
        # %ifeq
        push %eax
        movl 4(%ebp), %eax
        push %eax
        movl $2 + 41<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _parse_list_6
        push %eax
        movl $2 + 256<<2, %eax
        jmp _parse_list_7
_parse_list_6:
        # %ifeq
        push %eax
        movl 4(%ebp), %eax
        push %eax
        movl $2 + 46<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _parse_list_8
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_parse_list_10), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        jmp _parse_list_9
_parse_list_8:
        push %eax
        movl $_sample_unget_3, %eax
        # get procedure
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_parse_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        # jump past the body of the lambda
        jmp _parse_list_11
        .text
        .type _parse_list_12, @function
_parse_list_12:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 s
        push 12(%eax)
        # discarding useless value in %eax
        pop %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_parse_5), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_parse_13), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_cons_2), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _parse_list_12, .-_parse_list_12
_parse_list_11:
        # allocate bytes: 16
        push %eax
        movl (arena_pointer), %eax
        add $16, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_parse_list_12, 4(%ebx)
        movl $1, 8(%ebx)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
_parse_list_9:
_parse_list_7:
        jmp _parse_list_5
_parse_list_4:
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_list_13:
        .long 0xbabb1e
        .long 19
        .ascii "missing right paren"
        .text
        push %eax
        movl $_parse_list_13, %eax
        # get procedure
        push %eax
        movl (_string_Gtnumber_8), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
_parse_list_5:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _parse_list_3, .-_parse_list_3
_parse_list_1:
        push %eax
        movl $_parse_list_2, %eax
        # initialize global variable with value
        movl %eax, (_parse_13)
        pop %eax
        .section .data
_parse_list_10:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _read_dotted_tail_1
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_dotted_tail_2:
        .long 0xca11ab1e
        .long _read_dotted_tail_3
        .long 0
        .text
        .type _read_dotted_tail_3, @function
_read_dotted_tail_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # move arg from stack to heap: s
        push %eax
        movl 0(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_parse_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        # jump past the body of the lambda
        jmp _read_dotted_tail_4
        .text
        .type _read_dotted_tail_5, @function
_read_dotted_tail_5:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 s
        push 12(%eax)
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl $2 + 41<<2, %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_parse_5), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _read_dotted_tail_6
        push %eax
        movl 0(%ebp), %eax
        jmp _read_dotted_tail_7
_read_dotted_tail_6:
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_dotted_tail_8:
        .long 0xbabb1e
        .long 17
        .ascii "funky dotted list"
        .text
        push %eax
        movl $_read_dotted_tail_8, %eax
        # get procedure
        push %eax
        movl (_string_Gtnumber_8), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
_read_dotted_tail_7:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _read_dotted_tail_5, .-_read_dotted_tail_5
_read_dotted_tail_4:
        # allocate bytes: 16
        push %eax
        movl (arena_pointer), %eax
        add $16, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_read_dotted_tail_5, 4(%ebx)
        movl $1, 8(%ebx)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _read_dotted_tail_3, .-_read_dotted_tail_3
_read_dotted_tail_1:
        push %eax
        movl $_read_dotted_tail_2, %eax
        # initialize global variable with value
        movl %eax, (_parse_list_10)
        pop %eax
        .section .data
_whitespace_chars_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_whitespace_chars_2:
        .long 0xbabb1e
        .long 2
        .ascii "\n "
        .text
        push %eax
        movl $_whitespace_chars_2, %eax
        # initialize global variable with value
        movl %eax, (_whitespace_chars_1)
        pop %eax
        .section .data
_parse_5:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _after_wsp_1
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_after_wsp_2:
        .long 0xca11ab1e
        .long _after_wsp_3
        .long 0
        .text
        .type _after_wsp_3, @function
_after_wsp_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # get procedure
        push %eax
        movl 0(%ebp), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_after_wsp_4), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _after_wsp_3, .-_after_wsp_3
_after_wsp_1:
        push %eax
        movl $_after_wsp_2, %eax
        # initialize global variable with value
        movl %eax, (_parse_5)
        pop %eax
        .section .data
_after_wsp_4:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _after_wsp_2_1
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_after_wsp_2_2:
        .long 0xca11ab1e
        .long _after_wsp_2_3
        .long 0
        .text
        .type _after_wsp_2_3, @function
_after_wsp_2_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $2, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_after_wsp_2_8:
        .long 0x2ce11ed
        .long 2 + 9<<2
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_after_wsp_2_7:
        .long 0x2ce11ed
        .long 2 + 10<<2
        .long _after_wsp_2_8
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_after_wsp_2_6:
        .long 0x2ce11ed
        .long 2 + 32<<2
        .long _after_wsp_2_7
        .text
        push %eax
        movl $_after_wsp_2_6, %eax
        push %eax
        movl 4(%ebp), %eax
        # get procedure
        push %eax
        movl (_memv_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _after_wsp_2_4
        # %ifeq
        push %eax
        movl 4(%ebp), %eax
        push %eax
        movl $2 + 59<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _after_wsp_2_9
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_after_wsp_2_11), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_parse_5), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        jmp _after_wsp_2_10
_after_wsp_2_9:
        push %eax
        movl 4(%ebp), %eax
_after_wsp_2_10:
        jmp _after_wsp_2_5
_after_wsp_2_4:
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_parse_5), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
_after_wsp_2_5:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _after_wsp_2_3, .-_after_wsp_2_3
_after_wsp_2_1:
        push %eax
        movl $_after_wsp_2_2, %eax
        # initialize global variable with value
        movl %eax, (_after_wsp_4)
        pop %eax
        .section .data
_after_wsp_2_11:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _discard_comment_1
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_discard_comment_2:
        .long 0xca11ab1e
        .long _discard_comment_3
        .long 0
        .text
        .type _discard_comment_3, @function
_discard_comment_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        # get procedure
        push %eax
        movl 0(%ebp), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        push %eax
        movl $2 + 10<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _discard_comment_4
        push %eax
        movl $2 + 258<<2, %eax
        jmp _discard_comment_5
_discard_comment_4:
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_after_wsp_2_11), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
_discard_comment_5:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _discard_comment_3, .-_discard_comment_3
_discard_comment_1:
        push %eax
        movl $_discard_comment_2, %eax
        # initialize global variable with value
        movl %eax, (_after_wsp_2_11)
        pop %eax
        .section .data
_parse_22:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _parse_atom_1
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_atom_2:
        .long 0xca11ab1e
        .long _parse_atom_3
        .long 0
        .text
        .type _parse_atom_3, @function
_parse_atom_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # get procedure
        push %eax
        movl 0(%ebp), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_parse_atom_4), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        # jump past the body of the lambda
        jmp _parse_atom_5
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_atom_6:
        .long 0xca11ab1e
        .long _parse_atom_7
        .long 0
        .text
        .type _parse_atom_7, @function
_parse_atom_7:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_parse_atom_10), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _parse_atom_8
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_list_Gtstring_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_string_Gtsymbol_2), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        jmp _parse_atom_9
_parse_atom_8:
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_list_Gtstring_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_string_Gtnumber_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
_parse_atom_9:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _parse_atom_7, .-_parse_atom_7
_parse_atom_5:
        push %eax
        movl $_parse_atom_6, %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _parse_atom_3, .-_parse_atom_3
_parse_atom_1:
        push %eax
        movl $_parse_atom_2, %eax
        # initialize global variable with value
        movl %eax, (_parse_22)
        pop %eax
        .section .data
_parse_atom_10:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _parsed_numberP_1
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parsed_numberP_2:
        .long 0xca11ab1e
        .long _parsed_numberP_3
        .long 0
        .text
        .type _parsed_numberP_3, @function
_parsed_numberP_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl $2 + 256<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _parsed_numberP_4
        push %eax
        movl $2 + 258<<2, %eax
        jmp _parsed_numberP_5
_parsed_numberP_4:
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_char_numericP_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _parsed_numberP_6
        # %ifeq
        push %eax
        movl $2 + 43<<2, %eax
        push %eax
        movl 0(%ebp), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _parsed_numberP_8
        push %eax
        movl 0(%ebp), %eax
        # inlined cdr
        call ensure_cons
        movl 8(%eax), %eax
        # get procedure
        push %eax
        movl (_parsed_numberP_10), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        jmp _parsed_numberP_9
_parsed_numberP_8:
        # %ifeq
        push %eax
        movl $2 + 45<<2, %eax
        push %eax
        movl 0(%ebp), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _parsed_numberP_11
        push %eax
        movl 0(%ebp), %eax
        # inlined cdr
        call ensure_cons
        movl 8(%eax), %eax
        # get procedure
        push %eax
        movl (_parsed_numberP_10), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        jmp _parsed_numberP_12
_parsed_numberP_11:
        push %eax
        movl $2 + 258<<2, %eax
_parsed_numberP_12:
_parsed_numberP_9:
        jmp _parsed_numberP_7
_parsed_numberP_6:
        push %eax
        movl 0(%ebp), %eax
        # inlined cdr
        call ensure_cons
        movl 8(%eax), %eax
        # get procedure
        push %eax
        movl (_parsed_numberP_13), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
_parsed_numberP_7:
_parsed_numberP_5:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _parsed_numberP_3, .-_parsed_numberP_3
_parsed_numberP_1:
        push %eax
        movl $_parsed_numberP_2, %eax
        # initialize global variable with value
        movl %eax, (_parse_atom_10)
        pop %eax
        .section .data
_parsed_numberP_10:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _nonempty_and_all_numericP_1
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_nonempty_and_all_numericP_2:
        .long 0xca11ab1e
        .long _nonempty_and_all_numericP_3
        .long 0
        .text
        .type _nonempty_and_all_numericP_3, @function
_nonempty_and_all_numericP_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl $2 + 256<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _nonempty_and_all_numericP_4
        push %eax
        movl $2 + 258<<2, %eax
        jmp _nonempty_and_all_numericP_5
_nonempty_and_all_numericP_4:
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_parsed_numberP_13), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
_nonempty_and_all_numericP_5:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _nonempty_and_all_numericP_3, .-_nonempty_and_all_numericP_3
_nonempty_and_all_numericP_1:
        push %eax
        movl $_nonempty_and_all_numericP_2, %eax
        # initialize global variable with value
        movl %eax, (_parsed_numberP_10)
        pop %eax
        .section .data
_parsed_numberP_13:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _all_numericP_1
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_all_numericP_2:
        .long 0xca11ab1e
        .long _all_numericP_3
        .long 0
        .text
        .type _all_numericP_3, @function
_all_numericP_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # move arg from stack to heap: lst
        push %eax
        movl 0(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_nullP_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        # jump past the body of the lambda
        jmp _all_numericP_4
        .text
        .type _all_numericP_5, @function
_all_numericP_5:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 lst
        push 12(%eax)
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _all_numericP_6
        # %ifeq
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_char_numericP_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _all_numericP_8
        push %eax
        movl $2 + 258<<2, %eax
        jmp _all_numericP_9
_all_numericP_8:
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # inlined cdr
        call ensure_cons
        movl 8(%eax), %eax
        # get procedure
        push %eax
        movl (_parsed_numberP_13), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
_all_numericP_9:
        jmp _all_numericP_7
_all_numericP_6:
        push %eax
        movl 0(%ebp), %eax
_all_numericP_7:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _all_numericP_5, .-_all_numericP_5
_all_numericP_4:
        # allocate bytes: 16
        push %eax
        movl (arena_pointer), %eax
        add $16, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_all_numericP_5, 4(%ebx)
        movl $1, 8(%ebx)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _all_numericP_3, .-_all_numericP_3
_all_numericP_1:
        push %eax
        movl $_all_numericP_2, %eax
        # initialize global variable with value
        movl %eax, (_parsed_numberP_13)
        pop %eax
        .section .data
_parse_atom_4:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _parse_atom_2_1
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_atom_2_2:
        .long 0xca11ab1e
        .long _parse_atom_2_3
        .long 0
        .text
        .type _parse_atom_2_3, @function
_parse_atom_2_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $2, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 4(%ebp), %eax
        # get procedure
        push %eax
        movl (_parse_10), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _parse_atom_2_4
        # %ifeq
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_atom_2_15:
        .long 0x2ce11ed
        .long 2 + 34<<2
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_atom_2_14:
        .long 0x2ce11ed
        .long 2 + 39<<2
        .long _parse_atom_2_15
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_atom_2_13:
        .long 0x2ce11ed
        .long 2 + 41<<2
        .long _parse_atom_2_14
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_atom_2_12:
        .long 0x2ce11ed
        .long 2 + 40<<2
        .long _parse_atom_2_13
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_atom_2_11:
        .long 0x2ce11ed
        .long 2 + 59<<2
        .long _parse_atom_2_12
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_atom_2_10:
        .long 0x2ce11ed
        .long 2 + 9<<2
        .long _parse_atom_2_11
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_atom_2_9:
        .long 0x2ce11ed
        .long 2 + 10<<2
        .long _parse_atom_2_10
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_atom_2_8:
        .long 0x2ce11ed
        .long 2 + 32<<2
        .long _parse_atom_2_9
        .text
        push %eax
        movl $_parse_atom_2_8, %eax
        push %eax
        movl 4(%ebp), %eax
        # get procedure
        push %eax
        movl (_memv_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _parse_atom_2_6
        # get procedure
        push %eax
        movl 0(%ebp), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_parse_atom_4), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        push %eax
        movl 4(%ebp), %eax
        # get procedure
        push %eax
        movl (_cons_2), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        jmp _parse_atom_2_7
_parse_atom_2_6:
        push %eax
        movl $_sample_unget_3, %eax
        # get procedure
        push %eax
        movl 0(%ebp), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl $2 + 256<<2, %eax
_parse_atom_2_7:
        jmp _parse_atom_2_5
_parse_atom_2_4:
        push %eax
        movl $2 + 256<<2, %eax
_parse_atom_2_5:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _parse_atom_2_3, .-_parse_atom_2_3
_parse_atom_2_1:
        push %eax
        movl $_parse_atom_2_2, %eax
        # initialize global variable with value
        movl %eax, (_parse_atom_4)
        pop %eax
        .section .data
_parse_18:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _parse_string_literal_1
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_string_literal_2:
        .long 0xca11ab1e
        .long _parse_string_literal_3
        .long 0
        .text
        .type _parse_string_literal_3, @function
_parse_string_literal_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # get procedure
        push %eax
        movl 0(%ebp), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_parse_string_literal_4), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_list_Gtstring_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _parse_string_literal_3, .-_parse_string_literal_3
_parse_string_literal_1:
        push %eax
        movl $_parse_string_literal_2, %eax
        # initialize global variable with value
        movl %eax, (_parse_18)
        pop %eax
        .section .data
_parse_string_literal_4:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _parse_string_literal_2_1
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_string_literal_2_2:
        .long 0xca11ab1e
        .long _parse_string_literal_2_3
        .long 0
        .text
        .type _parse_string_literal_2_3, @function
_parse_string_literal_2_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $2, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # move arg from stack to heap: s
        push %eax
        movl 0(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # %ifeq
        push %eax
        movl 4(%ebp), %eax
        # get procedure
        push %eax
        movl (_parse_10), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _parse_string_literal_2_4
        # %ifeq
        push %eax
        movl 4(%ebp), %eax
        push %eax
        movl $2 + 92<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _parse_string_literal_2_6
        # get procedure
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        # get procedure
        # jump past the body of the lambda
        jmp _parse_string_literal_2_8
        .text
        .type _parse_string_literal_2_9, @function
_parse_string_literal_2_9:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 s
        push 12(%eax)
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl $2 + 110<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _parse_string_literal_2_10
        push %eax
        movl $2 + 10<<2, %eax
        jmp _parse_string_literal_2_11
_parse_string_literal_2_10:
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl $2 + 116<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _parse_string_literal_2_12
        push %eax
        movl $2 + 9<<2, %eax
        jmp _parse_string_literal_2_13
_parse_string_literal_2_12:
        push %eax
        movl 0(%ebp), %eax
_parse_string_literal_2_13:
_parse_string_literal_2_11:
        # get procedure
        # jump past the body of the lambda
        jmp _parse_string_literal_2_14
        .text
        .type _parse_string_literal_2_15, @function
_parse_string_literal_2_15:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 s
        push 12(%eax)
        # discarding useless value in %eax
        pop %eax
        # get procedure
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_parse_string_literal_4), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_cons_2), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _parse_string_literal_2_15, .-_parse_string_literal_2_15
_parse_string_literal_2_14:
        # allocate bytes: 16
        push %eax
        movl (arena_pointer), %eax
        add $16, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_parse_string_literal_2_15, 4(%ebx)
        movl $1, 8(%ebx)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _parse_string_literal_2_9, .-_parse_string_literal_2_9
_parse_string_literal_2_8:
        # allocate bytes: 16
        push %eax
        movl (arena_pointer), %eax
        add $16, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_parse_string_literal_2_9, 4(%ebx)
        movl $1, 8(%ebx)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        jmp _parse_string_literal_2_7
_parse_string_literal_2_6:
        # %ifeq
        push %eax
        movl 4(%ebp), %eax
        push %eax
        movl $2 + 34<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _parse_string_literal_2_16
        push %eax
        movl $2 + 256<<2, %eax
        jmp _parse_string_literal_2_17
_parse_string_literal_2_16:
        # get procedure
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_parse_string_literal_4), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        push %eax
        movl 4(%ebp), %eax
        # get procedure
        push %eax
        movl (_cons_2), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
_parse_string_literal_2_17:
_parse_string_literal_2_7:
        jmp _parse_string_literal_2_5
_parse_string_literal_2_4:
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_string_literal_2_18:
        .long 0xbabb1e
        .long 13
        .ascii "eof in string"
        .text
        push %eax
        movl $_parse_string_literal_2_18, %eax
        # get procedure
        push %eax
        movl (_string_Gtnumber_8), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
_parse_string_literal_2_5:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _parse_string_literal_2_3, .-_parse_string_literal_2_3
_parse_string_literal_2_1:
        push %eax
        movl $_parse_string_literal_2_2, %eax
        # initialize global variable with value
        movl %eax, (_parse_string_literal_4)
        pop %eax
        .section .data
_parse_21:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _parse_hashy_thing_1
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_hashy_thing_2:
        .long 0xca11ab1e
        .long _parse_hashy_thing_3
        .long 0
        .text
        .type _parse_hashy_thing_3, @function
_parse_hashy_thing_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $2, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 4(%ebp), %eax
        # get procedure
        push %eax
        movl (_parse_10), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _parse_hashy_thing_4
        # %ifeq
        push %eax
        movl 4(%ebp), %eax
        push %eax
        movl $2 + 116<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _parse_hashy_thing_6
        push %eax
        movl $2 + 257<<2, %eax
        jmp _parse_hashy_thing_7
_parse_hashy_thing_6:
        # %ifeq
        push %eax
        movl 4(%ebp), %eax
        push %eax
        movl $2 + 102<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _parse_hashy_thing_8
        push %eax
        movl $2 + 258<<2, %eax
        jmp _parse_hashy_thing_9
_parse_hashy_thing_8:
        # %ifeq
        push %eax
        movl 4(%ebp), %eax
        push %eax
        movl $2 + 92<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _parse_hashy_thing_10
        # get procedure
        push %eax
        movl 0(%ebp), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_parse_hashy_thing_12), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        jmp _parse_hashy_thing_11
_parse_hashy_thing_10:
        push %eax
        movl 4(%ebp), %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_hashy_thing_13:
        .long 0xbabb1e
        .long 15
        .ascii "Unimplemented #"
        .text
        push %eax
        movl $_parse_hashy_thing_13, %eax
        # get procedure
        push %eax
        movl (_string_Gtnumber_8), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
_parse_hashy_thing_11:
_parse_hashy_thing_9:
_parse_hashy_thing_7:
        jmp _parse_hashy_thing_5
_parse_hashy_thing_4:
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_hashy_thing_14:
        .long 0xbabb1e
        .long 11
        .ascii "eof after #"
        .text
        push %eax
        movl $_parse_hashy_thing_14, %eax
        # get procedure
        push %eax
        movl (_string_Gtnumber_8), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
_parse_hashy_thing_5:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _parse_hashy_thing_3, .-_parse_hashy_thing_3
_parse_hashy_thing_1:
        push %eax
        movl $_parse_hashy_thing_2, %eax
        # initialize global variable with value
        movl %eax, (_parse_21)
        pop %eax
        .section .data
_parse_hashy_thing_12:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _parse_char_literal_1
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_char_literal_2:
        .long 0xca11ab1e
        .long _parse_char_literal_3
        .long 0
        .text
        .type _parse_char_literal_3, @function
_parse_char_literal_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $2, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 4(%ebp), %eax
        # get procedure
        push %eax
        movl (_parse_10), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _parse_char_literal_4
        # %ifeq
        push %eax
        movl 4(%ebp), %eax
        # get procedure
        push %eax
        movl (_char_alphabeticP_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _parse_char_literal_6
        push %eax
        movl 4(%ebp), %eax
        jmp _parse_char_literal_7
_parse_char_literal_6:
        push %eax
        movl $_sample_unget_3, %eax
        # get procedure
        push %eax
        movl 0(%ebp), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_parse_char_literal_8), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
_parse_char_literal_7:
        jmp _parse_char_literal_5
_parse_char_literal_4:
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_char_literal_9:
        .long 0xbabb1e
        .long 19
        .ascii "eof in char literal"
        .text
        push %eax
        movl $_parse_char_literal_9, %eax
        # get procedure
        push %eax
        movl (_string_Gtnumber_8), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
_parse_char_literal_5:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _parse_char_literal_3, .-_parse_char_literal_3
_parse_char_literal_1:
        push %eax
        movl $_parse_char_literal_2, %eax
        # initialize global variable with value
        movl %eax, (_parse_hashy_thing_12)
        pop %eax
        .section .data
_parse_char_literal_8:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _parse_named_char_1
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_named_char_2:
        .long 0xca11ab1e
        .long _parse_named_char_3
        .long 0
        .text
        .type _parse_named_char_3, @function
_parse_named_char_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # get procedure
        push %eax
        movl 0(%ebp), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_parse_atom_4), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        # get procedure
        # jump past the body of the lambda
        jmp _parse_named_char_4
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_named_char_5:
        .long 0xca11ab1e
        .long _parse_named_char_6
        .long 0
        .text
        .type _parse_named_char_6, @function
_parse_named_char_6:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # move arg from stack to heap: name
        push %eax
        movl 0(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # %ifeq
        push %eax
        movl $1 + 1<<2, %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_length_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _parse_named_char_7
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # inlined car
        call ensure_cons
        movl 4(%eax), %eax
        jmp _parse_named_char_8
_parse_named_char_7:
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_list_Gtstring_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_string_Gtsymbol_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        # jump past the body of the lambda
        jmp _parse_named_char_9
        .text
        .type _parse_named_char_10, @function
_parse_named_char_10:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 name
        push 12(%eax)
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl $_parse_named_char_13, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _parse_named_char_11
        push %eax
        movl $2 + 32<<2, %eax
        jmp _parse_named_char_12
_parse_named_char_11:
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl $_heap_args_22, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _parse_named_char_14
        push %eax
        movl $2 + 10<<2, %eax
        jmp _parse_named_char_15
_parse_named_char_14:
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl $_parse_named_char_18, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _parse_named_char_16
        push %eax
        movl $2 + 9<<2, %eax
        jmp _parse_named_char_17
_parse_named_char_16:
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_list_Gtstring_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_string_Gtsymbol_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_named_char_19:
        .long 0xbabb1e
        .long 27
        .ascii "Unrecognized character name"
        .text
        push %eax
        movl $_parse_named_char_19, %eax
        # get procedure
        push %eax
        movl (_string_Gtnumber_8), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
_parse_named_char_17:
_parse_named_char_15:
_parse_named_char_12:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _parse_named_char_10, .-_parse_named_char_10
_parse_named_char_9:
        # allocate bytes: 16
        push %eax
        movl (arena_pointer), %eax
        add $16, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_parse_named_char_10, 4(%ebx)
        movl $1, 8(%ebx)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
_parse_named_char_8:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _parse_named_char_6, .-_parse_named_char_6
_parse_named_char_4:
        push %eax
        movl $_parse_named_char_5, %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _parse_named_char_3, .-_parse_named_char_3
_parse_named_char_1:
        push %eax
        movl $_parse_named_char_2, %eax
        # initialize global variable with value
        movl %eax, (_parse_char_literal_8)
        pop %eax
        .section .data
_parse_string_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _parse_string_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_string_3:
        .long 0xca11ab1e
        .long _parse_string_4
        .long 0
        .text
        .type _parse_string_4, @function
_parse_string_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_read_from_string_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_ungettable_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_parse_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _parse_string_4, .-_parse_string_4
_parse_string_2:
        push %eax
        movl $_parse_string_3, %eax
        # initialize global variable with value
        movl %eax, (_parse_string_1)
        pop %eax
        .section .data
_read_expr_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _read_expr_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_expr_3:
        .long 0xca11ab1e
        .long _read_expr_4
        .long 0
        .text
        .type _read_expr_4, @function
_read_expr_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # move arg from stack to heap: file
        push %eax
        movl 0(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # jump past the body of the lambda
        jmp _read_expr_5
        .text
        .type _read_expr_6, @function
_read_expr_6:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $0, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 file
        push 12(%eax)
        # discarding useless value in %eax
        pop %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_read_char_2), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _read_expr_6, .-_read_expr_6
_read_expr_5:
        # allocate bytes: 16
        push %eax
        movl (arena_pointer), %eax
        add $16, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_read_expr_6, 4(%ebx)
        movl $1, 8(%ebx)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # get procedure
        push %eax
        movl (_ungettable_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_parse_1), %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _read_expr_4, .-_read_expr_4
_read_expr_2:
        push %eax
        movl $_read_expr_3, %eax
        # initialize global variable with value
        movl %eax, (_read_expr_1)
        pop %eax
        .section .data
_parse_10:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _parse_eofP_1
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_2:
        .long 0xca11ab1e
        .long _parse_eofP_3
        .long 0
        .text
        .type _parse_eofP_3, @function
_parse_eofP_3:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # move arg from stack to heap: x
        push %eax
        movl 0(%ebp), %eax
        # moving top of stack to newly allocated heap var
        # allocate bytes: 8
        push %eax
        movl (arena_pointer), %eax
        add $8, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl $0x1ce11ed, (%eax)
        pop 4(%eax)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_eof_objectP_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        # jump past the body of the lambda
        jmp _parse_eofP_4
        .text
        .type _parse_eofP_5, @function
_parse_eofP_5:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # fetch artifact from closure: 0 x
        push 12(%eax)
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _parse_eofP_6
        push %eax
        movl $_read_from_string_11, %eax
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        # fetch current value from the heap
        movl 4(%eax), %eax
        # get procedure
        push %eax
        movl (_eqP_1), %eax
        # apply procedure
        # Tail call; nargs = 2
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push -4(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        jmp *%ebx
        jmp _parse_eofP_7
_parse_eofP_6:
        push %eax
        movl 0(%ebp), %eax
_parse_eofP_7:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _parse_eofP_5, .-_parse_eofP_5
_parse_eofP_4:
        # allocate bytes: 16
        push %eax
        movl (arena_pointer), %eax
        add $16, (arena_pointer)
        cmpl $end_arena, (arena_pointer)
        ja arena_full
        # now %eax points to newly allocated memory
        movl %eax, %ebx
        movl $0xca11ab1e, (%ebx)
        movl $_parse_eofP_5, 4(%ebx)
        movl $1, 8(%ebx)
        # fetching heap var pointer 0
        push %eax
        movl -16(%ebp), %eax
        movl %eax, 12(%ebx)
        pop %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _parse_eofP_3, .-_parse_eofP_3
_parse_eofP_1:
        push %eax
        movl $_parse_eofP_2, %eax
        # initialize global variable with value
        movl %eax, (_parse_10)
        pop %eax
        push %eax
        movl $2 + 256<<2, %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_8:
        .long 0xbabb1e
        .long 2
        .ascii "()"
        .text
        push %eax
        movl $_parse_eofP_8, %eax
        # get procedure
        push %eax
        movl (_parse_string_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_emit_malloc_n_4), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl $2 + 256<<2, %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_9:
        .long 0xbabb1e
        .long 3
        .ascii " ()"
        .text
        push %eax
        movl $_parse_eofP_9, %eax
        # get procedure
        push %eax
        movl (_parse_string_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_emit_malloc_n_4), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl $2 + 256<<2, %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_10:
        .long 0xbabb1e
        .long 3
        .ascii "\n()"
        .text
        push %eax
        movl $_parse_eofP_10, %eax
        # get procedure
        push %eax
        movl (_parse_string_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_emit_malloc_n_4), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl $2 + 256<<2, %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_11:
        .long 0xbabb1e
        .long 4
        .ascii " ( )"
        .text
        push %eax
        movl $_parse_eofP_11, %eax
        # get procedure
        push %eax
        movl (_parse_string_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_emit_malloc_n_4), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl $2 + 256<<2, %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_12:
        .long 0xbabb1e
        .long 10
        .ascii ";hi\n(;hi\n)"
        .text
        push %eax
        movl $_parse_eofP_12, %eax
        # get procedure
        push %eax
        movl (_parse_string_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_emit_malloc_n_4), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl $_sample_begin_expr_17, %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_13:
        .long 0xbabb1e
        .long 2
        .ascii "x "
        .text
        push %eax
        movl $_parse_eofP_13, %eax
        # get procedure
        push %eax
        movl (_parse_string_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_emit_malloc_n_4), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl $_sample_begin_expr_17, %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_14:
        .long 0xbabb1e
        .long 1
        .ascii "x"
        .text
        push %eax
        movl $_parse_eofP_14, %eax
        # get procedure
        push %eax
        movl (_parse_string_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_emit_malloc_n_4), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl $_parse_eofP_15, %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_16:
        .long 0xbabb1e
        .long 3
        .ascii "xyz"
        .text
        push %eax
        movl $_parse_eofP_16, %eax
        # get procedure
        push %eax
        movl (_parse_string_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_emit_malloc_n_4), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_17:
        .long 0x2ce11ed
        .long _parse_eofP_15
        .long 2 + 256<<2
        .text
        push %eax
        movl $_parse_eofP_17, %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_18:
        .long 0xbabb1e
        .long 5
        .ascii "(xyz)"
        .text
        push %eax
        movl $_parse_eofP_18, %eax
        # get procedure
        push %eax
        movl (_parse_string_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_emit_malloc_n_4), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_21:
        .long 0x2ce11ed
        .long _sample_begin_expr_10
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_20:
        .long 0x2ce11ed
        .long _sample_begin_expr_23
        .long _parse_eofP_21
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_19:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long _parse_eofP_20
        .text
        push %eax
        movl $_parse_eofP_19, %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_22:
        .long 0xbabb1e
        .long 7
        .ascii "(x y z)"
        .text
        push %eax
        movl $_parse_eofP_22, %eax
        # get procedure
        push %eax
        movl (_parse_string_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_emit_malloc_n_4), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_24:
        .long 0x2ce11ed
        .long _sample_begin_expr_23
        .long _sample_begin_expr_10
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_23:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long _parse_eofP_24
        .text
        push %eax
        movl $_parse_eofP_23, %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_25:
        .long 0xbabb1e
        .long 9
        .ascii "(x y . z)"
        .text
        push %eax
        movl $_parse_eofP_25, %eax
        # get procedure
        push %eax
        movl (_parse_string_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_emit_malloc_n_4), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_29:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_28:
        .long 0x2ce11ed
        .long _inline_primitive_16
        .long _parse_eofP_29
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_33:
        .long 0x2ce11ed
        .long 1 + 1<<2
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_32:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long _parse_eofP_33
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_31:
        .long 0x2ce11ed
        .long _inline_primitive_10
        .long _parse_eofP_32
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_30:
        .long 0x2ce11ed
        .long _parse_eofP_31
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_27:
        .long 0x2ce11ed
        .long _parse_eofP_28
        .long _parse_eofP_30
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_26:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _parse_eofP_27
        .text
        push %eax
        movl $_parse_eofP_26, %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_34:
        .long 0xbabb1e
        .long 23
        .ascii "(define (1+ x) (+ x 1))"
        .text
        push %eax
        movl $_parse_eofP_34, %eax
        # get procedure
        push %eax
        movl (_parse_string_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_emit_malloc_n_4), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_41:
        .long 0x2ce11ed
        .long _parse_eofP_42
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_39:
        .long 0x2ce11ed
        .long _parse_eofP_40
        .long _parse_eofP_41
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_37:
        .long 0x2ce11ed
        .long _parse_eofP_38
        .long _parse_eofP_39
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_47:
        .long 0x2ce11ed
        .long _parse_eofP_42
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_46:
        .long 0x2ce11ed
        .long _macroexpand_1_85
        .long _parse_eofP_47
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_50:
        .long 0x2ce11ed
        .long 2 + 256<<2
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_49:
        .long 0x2ce11ed
        .long _free_vars_20
        .long _parse_eofP_50
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_48:
        .long 0x2ce11ed
        .long _parse_eofP_49
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_45:
        .long 0x2ce11ed
        .long _parse_eofP_46
        .long _parse_eofP_48
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_44:
        .long 0x2ce11ed
        .long _macroexpand_1_20
        .long _parse_eofP_45
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_43:
        .long 0x2ce11ed
        .long _parse_eofP_44
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_36:
        .long 0x2ce11ed
        .long _parse_eofP_37
        .long _parse_eofP_43
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_35:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _parse_eofP_36
        .text
        push %eax
        movl $_parse_eofP_35, %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_51:
        .long 0xbabb1e
        .long 54
        .ascii "(define (filter fn lst)  ; foo\n  (if (null? lst) '()))"
        .text
        push %eax
        movl $_parse_eofP_51, %eax
        # get procedure
        push %eax
        movl (_parse_string_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_emit_malloc_n_4), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_52:
        .long 0xbabb1e
        .long 40
        .ascii "(char->string (string-ref \"0123456789\"))"
        .text
        push %eax
        movl $_parse_eofP_52, %eax
        # get procedure
        push %eax
        movl (_parse_string_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_58:
        .long 0xbabb1e
        .long 10
        .ascii "0123456789"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_59:
        .long 0x2ce11ed
        .long _parse_eofP_60
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_57:
        .long 0x2ce11ed
        .long _parse_eofP_58
        .long _parse_eofP_59
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_56:
        .long 0x2ce11ed
        .long _check_array_bounds_30
        .long _parse_eofP_57
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_55:
        .long 0x2ce11ed
        .long _parse_eofP_56
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_53:
        .long 0x2ce11ed
        .long _parse_eofP_54
        .long _parse_eofP_55
        .text
        push %eax
        movl $_parse_eofP_53, %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_61:
        .long 0xbabb1e
        .long 47
        .ascii "(char->string (string-ref \"0123456789\" digit)))"
        .text
        push %eax
        movl $_parse_eofP_61, %eax
        # get procedure
        push %eax
        movl (_parse_string_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_emit_malloc_n_4), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_64:
        .long 0xbabb1e
        .long 1
        .ascii "3"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_67:
        .long 0xbabb1e
        .long 1
        .ascii "5"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_66:
        .long 0x2ce11ed
        .long _parse_eofP_67
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_65:
        .long 0x2ce11ed
        .long 2 + 256<<2
        .long _parse_eofP_66
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_63:
        .long 0x2ce11ed
        .long _parse_eofP_64
        .long _parse_eofP_65
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_62:
        .long 0x2ce11ed
        .long _sample_closure_expression_20
        .long _parse_eofP_63
        .text
        push %eax
        movl $_parse_eofP_62, %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_68:
        .long 0xbabb1e
        .long 13
        .ascii "(foo\"3\"()\"5\")"
        .text
        push %eax
        movl $_parse_eofP_68, %eax
        # get procedure
        push %eax
        movl (_parse_string_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_emit_malloc_n_4), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_72:
        .long 0x2ce11ed
        .long 2 + 258<<2
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_71:
        .long 0x2ce11ed
        .long 2 + 257<<2
        .long _parse_eofP_72
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_70:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long _parse_eofP_71
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_69:
        .long 0x2ce11ed
        .long _set_union_all_12
        .long _parse_eofP_70
        .text
        push %eax
        movl $_parse_eofP_69, %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_73:
        .long 0xbabb1e
        .long 11
        .ascii "(b a #t #f)"
        .text
        push %eax
        movl $_parse_eofP_73, %eax
        # get procedure
        push %eax
        movl (_parse_string_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_emit_malloc_n_4), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_81:
        .long 0x2ce11ed
        .long 1 + -8<<2
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_79:
        .long 0x2ce11ed
        .long _parse_eofP_80
        .long _parse_eofP_81
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_77:
        .long 0x2ce11ed
        .long _parse_eofP_78
        .long _parse_eofP_79
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_82:
        .long 0x2ce11ed
        .long _parse_eofP_83
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_76:
        .long 0x2ce11ed
        .long _parse_eofP_77
        .long _parse_eofP_82
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_74:
        .long 0x2ce11ed
        .long _parse_eofP_75
        .long _parse_eofP_76
        .text
        push %eax
        movl $_parse_eofP_74, %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_84:
        .long 0xbabb1e
        .long 25
        .ascii "(mov (offset ebp -8) esp)"
        .text
        push %eax
        movl $_parse_eofP_84, %eax
        # get procedure
        push %eax
        movl (_parse_string_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_emit_malloc_n_4), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_85:
        .long 0xbabb1e
        .long 22
        .ascii "parsing at end of file"
        .text
        push %eax
        movl $_parse_eofP_85, %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_86:
        .long 0xbabb1e
        .long 0
        .ascii ""
        .text
        push %eax
        movl $_parse_eofP_86, %eax
        # get procedure
        push %eax
        movl (_parse_string_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_parse_10), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_assert_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_94:
        .long 0x2ce11ed
        .long 2 + 92<<2
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_93:
        .long 0x2ce11ed
        .long 2 + 35<<2
        .long _parse_eofP_94
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_92:
        .long 0x2ce11ed
        .long 2 + 41<<2
        .long _parse_eofP_93
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_91:
        .long 0x2ce11ed
        .long 2 + 40<<2
        .long _parse_eofP_92
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_90:
        .long 0x2ce11ed
        .long 2 + 32<<2
        .long _parse_eofP_91
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_89:
        .long 0x2ce11ed
        .long 2 + 9<<2
        .long _parse_eofP_90
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_88:
        .long 0x2ce11ed
        .long 2 + 10<<2
        .long _parse_eofP_89
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_87:
        .long 0x2ce11ed
        .long 2 + 97<<2
        .long _parse_eofP_88
        .text
        push %eax
        movl $_parse_eofP_87, %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_95:
        .long 0xbabb1e
        .long 45
        .ascii "(#\\a #\\newline #\\tab #\\space #\\( #\\) #\\# #\\\\)"
        .text
        push %eax
        movl $_parse_eofP_95, %eax
        # get procedure
        push %eax
        movl (_parse_string_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_emit_malloc_n_4), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_96:
        .long 0xbabb1e
        .long 12
        .ascii "hello\n	there"
        .text
        push %eax
        movl $_parse_eofP_96, %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_97:
        .long 0xbabb1e
        .long 16
        .ascii "\"hello\\n\\tthere\""
        .text
        push %eax
        movl $_parse_eofP_97, %eax
        # get procedure
        push %eax
        movl (_parse_string_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_emit_malloc_n_4), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .data
_standard_library_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_7:
        .long 0x2ce11ed
        .long _set_union_all_12
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_6:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long _standard_library_7
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_5:
        .long 0x2ce11ed
        .long _inline_primitive_10
        .long _standard_library_6
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_11:
        .long 0x2ce11ed
        .long _set_union_all_12
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_10:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long _standard_library_11
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_9:
        .long 0x2ce11ed
        .long _inline_primitive_10
        .long _standard_library_10
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_8:
        .long 0x2ce11ed
        .long _standard_library_9
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_4:
        .long 0x2ce11ed
        .long _standard_library_5
        .long _standard_library_8
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_3:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _standard_library_4
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_17:
        .long 0x2ce11ed
        .long _set_union_all_12
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_16:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long _standard_library_17
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_15:
        .long 0x2ce11ed
        .long _inline_primitive_13
        .long _standard_library_16
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_21:
        .long 0x2ce11ed
        .long _set_union_all_12
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_20:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long _standard_library_21
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_19:
        .long 0x2ce11ed
        .long _inline_primitive_13
        .long _standard_library_20
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_18:
        .long 0x2ce11ed
        .long _standard_library_19
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_14:
        .long 0x2ce11ed
        .long _standard_library_15
        .long _standard_library_18
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_13:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _standard_library_14
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_26:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_25:
        .long 0x2ce11ed
        .long _inline_primitive_22
        .long _standard_library_26
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_29:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_28:
        .long 0x2ce11ed
        .long _inline_primitive_22
        .long _standard_library_29
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_27:
        .long 0x2ce11ed
        .long _standard_library_28
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_24:
        .long 0x2ce11ed
        .long _standard_library_25
        .long _standard_library_27
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_23:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _standard_library_24
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_34:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_33:
        .long 0x2ce11ed
        .long _inline_primitive_25
        .long _standard_library_34
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_37:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_36:
        .long 0x2ce11ed
        .long _inline_primitive_25
        .long _standard_library_37
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_35:
        .long 0x2ce11ed
        .long _standard_library_36
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_32:
        .long 0x2ce11ed
        .long _standard_library_33
        .long _standard_library_35
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_31:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _standard_library_32
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_42:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_41:
        .long 0x2ce11ed
        .long _inline_primitive_16
        .long _standard_library_42
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_45:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_44:
        .long 0x2ce11ed
        .long _inline_primitive_16
        .long _standard_library_45
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_43:
        .long 0x2ce11ed
        .long _standard_library_44
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_40:
        .long 0x2ce11ed
        .long _standard_library_41
        .long _standard_library_43
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_39:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _standard_library_40
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_50:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_49:
        .long 0x2ce11ed
        .long _inline_primitive_19
        .long _standard_library_50
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_53:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_52:
        .long 0x2ce11ed
        .long _inline_primitive_19
        .long _standard_library_53
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_51:
        .long 0x2ce11ed
        .long _standard_library_52
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_48:
        .long 0x2ce11ed
        .long _standard_library_49
        .long _standard_library_51
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_47:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _standard_library_48
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_57:
        .long 0x2ce11ed
        .long _standard_library_58
        .long _standard_library_59
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_60:
        .long 0x2ce11ed
        .long _standard_library_59
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_56:
        .long 0x2ce11ed
        .long _standard_library_57
        .long _standard_library_60
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_55:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _standard_library_56
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_66:
        .long 0x2ce11ed
        .long _standard_library_58
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_64:
        .long 0x2ce11ed
        .long _standard_library_65
        .long _standard_library_66
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_71:
        .long 0x2ce11ed
        .long _standard_library_58
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_70:
        .long 0x2ce11ed
        .long _macroexpand_1_85
        .long _standard_library_71
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_79:
        .long 0x2ce11ed
        .long _standard_library_58
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_78:
        .long 0x2ce11ed
        .long _inline_primitive_25
        .long _standard_library_79
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_77:
        .long 0x2ce11ed
        .long _standard_library_78
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_76:
        .long 0x2ce11ed
        .long _standard_library_65
        .long _standard_library_77
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_75:
        .long 0x2ce11ed
        .long _standard_library_76
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_74:
        .long 0x2ce11ed
        .long _inline_primitive_16
        .long _standard_library_75
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_73:
        .long 0x2ce11ed
        .long _standard_library_74
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_72:
        .long 0x2ce11ed
        .long 1 + 0<<2
        .long _standard_library_73
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_69:
        .long 0x2ce11ed
        .long _standard_library_70
        .long _standard_library_72
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_68:
        .long 0x2ce11ed
        .long _macroexpand_1_20
        .long _standard_library_69
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_67:
        .long 0x2ce11ed
        .long _standard_library_68
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_63:
        .long 0x2ce11ed
        .long _standard_library_64
        .long _standard_library_67
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_62:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _standard_library_63
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_87:
        .long 0x2ce11ed
        .long _standard_library_88
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_85:
        .long 0x2ce11ed
        .long _standard_library_86
        .long _standard_library_87
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_83:
        .long 0x2ce11ed
        .long _standard_library_84
        .long _standard_library_85
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_94:
        .long 0x2ce11ed
        .long _standard_library_88
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_93:
        .long 0x2ce11ed
        .long _macroexpand_1_85
        .long _standard_library_94
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_95:
        .long 0x2ce11ed
        .long 2 + 258<<2
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_92:
        .long 0x2ce11ed
        .long _standard_library_93
        .long _standard_library_95
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_103:
        .long 0x2ce11ed
        .long _standard_library_88
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_101:
        .long 0x2ce11ed
        .long _standard_library_102
        .long _standard_library_103
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_100:
        .long 0x2ce11ed
        .long _standard_library_101
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_99:
        .long 0x2ce11ed
        .long _standard_library_86
        .long _standard_library_100
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_98:
        .long 0x2ce11ed
        .long _macroexpand_1_79
        .long _standard_library_99
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_106:
        .long 0x2ce11ed
        .long _standard_library_88
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_105:
        .long 0x2ce11ed
        .long _inline_primitive_22
        .long _standard_library_106
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_104:
        .long 0x2ce11ed
        .long _standard_library_105
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_97:
        .long 0x2ce11ed
        .long _standard_library_98
        .long _standard_library_104
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_114:
        .long 0x2ce11ed
        .long _standard_library_88
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_113:
        .long 0x2ce11ed
        .long _inline_primitive_25
        .long _standard_library_114
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_112:
        .long 0x2ce11ed
        .long _standard_library_113
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_111:
        .long 0x2ce11ed
        .long _standard_library_86
        .long _standard_library_112
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_110:
        .long 0x2ce11ed
        .long _standard_library_84
        .long _standard_library_111
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_109:
        .long 0x2ce11ed
        .long _standard_library_110
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_108:
        .long 0x2ce11ed
        .long _macroexpand_1_18
        .long _standard_library_109
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_107:
        .long 0x2ce11ed
        .long _standard_library_108
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_96:
        .long 0x2ce11ed
        .long _standard_library_97
        .long _standard_library_107
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_91:
        .long 0x2ce11ed
        .long _standard_library_92
        .long _standard_library_96
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_90:
        .long 0x2ce11ed
        .long _macroexpand_1_19
        .long _standard_library_91
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_89:
        .long 0x2ce11ed
        .long _standard_library_90
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_82:
        .long 0x2ce11ed
        .long _standard_library_83
        .long _standard_library_89
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_81:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _standard_library_82
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_121:
        .long 0x2ce11ed
        .long _standard_library_58
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_120:
        .long 0x2ce11ed
        .long _standard_library_86
        .long _standard_library_121
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_118:
        .long 0x2ce11ed
        .long _standard_library_119
        .long _standard_library_120
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_127:
        .long 0x2ce11ed
        .long _standard_library_58
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_126:
        .long 0x2ce11ed
        .long _macroexpand_1_85
        .long _standard_library_127
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_128:
        .long 0x2ce11ed
        .long 2 + 258<<2
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_125:
        .long 0x2ce11ed
        .long _standard_library_126
        .long _standard_library_128
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_135:
        .long 0x2ce11ed
        .long _standard_library_58
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_134:
        .long 0x2ce11ed
        .long _inline_primitive_22
        .long _standard_library_135
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_133:
        .long 0x2ce11ed
        .long _standard_library_134
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_132:
        .long 0x2ce11ed
        .long _standard_library_86
        .long _standard_library_133
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_131:
        .long 0x2ce11ed
        .long _macroexpand_1_79
        .long _standard_library_132
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_136:
        .long 0x2ce11ed
        .long _standard_library_58
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_130:
        .long 0x2ce11ed
        .long _standard_library_131
        .long _standard_library_136
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_144:
        .long 0x2ce11ed
        .long _standard_library_58
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_143:
        .long 0x2ce11ed
        .long _inline_primitive_25
        .long _standard_library_144
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_142:
        .long 0x2ce11ed
        .long _standard_library_143
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_141:
        .long 0x2ce11ed
        .long _standard_library_86
        .long _standard_library_142
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_140:
        .long 0x2ce11ed
        .long _standard_library_119
        .long _standard_library_141
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_139:
        .long 0x2ce11ed
        .long _standard_library_140
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_138:
        .long 0x2ce11ed
        .long _macroexpand_1_18
        .long _standard_library_139
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_137:
        .long 0x2ce11ed
        .long _standard_library_138
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_129:
        .long 0x2ce11ed
        .long _standard_library_130
        .long _standard_library_137
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_124:
        .long 0x2ce11ed
        .long _standard_library_125
        .long _standard_library_129
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_123:
        .long 0x2ce11ed
        .long _macroexpand_1_19
        .long _standard_library_124
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_122:
        .long 0x2ce11ed
        .long _standard_library_123
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_117:
        .long 0x2ce11ed
        .long _standard_library_118
        .long _standard_library_122
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_116:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _standard_library_117
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_148:
        .long 0x2ce11ed
        .long _standard_library_119
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_147:
        .long 0x2ce11ed
        .long _macroexpand_1_45
        .long _standard_library_148
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_146:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _standard_library_147
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_156:
        .long 0x2ce11ed
        .long _standard_library_157
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_155:
        .long 0x2ce11ed
        .long _parse_eofP_42
        .long _standard_library_156
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_154:
        .long 0x2ce11ed
        .long _parse_eofP_40
        .long _standard_library_155
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_152:
        .long 0x2ce11ed
        .long _standard_library_153
        .long _standard_library_154
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_162:
        .long 0x2ce11ed
        .long _parse_eofP_42
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_161:
        .long 0x2ce11ed
        .long _macroexpand_1_85
        .long _standard_library_162
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_168:
        .long 0x2ce11ed
        .long _parse_eofP_42
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_167:
        .long 0x2ce11ed
        .long _inline_primitive_22
        .long _standard_library_168
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_174:
        .long 0x2ce11ed
        .long _parse_eofP_42
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_173:
        .long 0x2ce11ed
        .long _inline_primitive_25
        .long _standard_library_174
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_175:
        .long 0x2ce11ed
        .long _standard_library_157
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_172:
        .long 0x2ce11ed
        .long _standard_library_173
        .long _standard_library_175
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_171:
        .long 0x2ce11ed
        .long _parse_eofP_40
        .long _standard_library_172
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_170:
        .long 0x2ce11ed
        .long _standard_library_153
        .long _standard_library_171
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_169:
        .long 0x2ce11ed
        .long _standard_library_170
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_166:
        .long 0x2ce11ed
        .long _standard_library_167
        .long _standard_library_169
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_165:
        .long 0x2ce11ed
        .long _parse_eofP_40
        .long _standard_library_166
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_164:
        .long 0x2ce11ed
        .long _standard_library_165
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_163:
        .long 0x2ce11ed
        .long _standard_library_157
        .long _standard_library_164
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_160:
        .long 0x2ce11ed
        .long _standard_library_161
        .long _standard_library_163
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_159:
        .long 0x2ce11ed
        .long _macroexpand_1_20
        .long _standard_library_160
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_158:
        .long 0x2ce11ed
        .long _standard_library_159
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_151:
        .long 0x2ce11ed
        .long _standard_library_152
        .long _standard_library_158
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_150:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _standard_library_151
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_182:
        .long 0x2ce11ed
        .long _set_union_all_12
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_181:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long _standard_library_182
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_179:
        .long 0x2ce11ed
        .long _standard_library_180
        .long _standard_library_181
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_187:
        .long 0x2ce11ed
        .long _set_union_all_12
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_186:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long _standard_library_187
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_185:
        .long 0x2ce11ed
        .long _inline_cdr_13
        .long _standard_library_186
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_184:
        .long 0x2ce11ed
        .long _standard_library_153
        .long _standard_library_185
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_183:
        .long 0x2ce11ed
        .long _standard_library_184
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_178:
        .long 0x2ce11ed
        .long _standard_library_179
        .long _standard_library_183
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_177:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _standard_library_178
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_191:
        .long 0x2ce11ed
        .long _standard_library_192
        .long _standard_library_59
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_199:
        .long 0x2ce11ed
        .long 2 + 256<<2
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_198:
        .long 0x2ce11ed
        .long _free_vars_20
        .long _standard_library_199
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_197:
        .long 0x2ce11ed
        .long _standard_library_198
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_196:
        .long 0x2ce11ed
        .long _standard_library_59
        .long _standard_library_197
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_195:
        .long 0x2ce11ed
        .long _standard_library_180
        .long _standard_library_196
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_194:
        .long 0x2ce11ed
        .long _standard_library_153
        .long _standard_library_195
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_193:
        .long 0x2ce11ed
        .long _standard_library_194
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_190:
        .long 0x2ce11ed
        .long _standard_library_191
        .long _standard_library_193
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_189:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _standard_library_190
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_204:
        .long 0x2ce11ed
        .long _standard_library_205
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_203:
        .long 0x2ce11ed
        .long _standard_library_102
        .long _standard_library_204
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_210:
        .long 0x2ce11ed
        .long _standard_library_205
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_209:
        .long 0x2ce11ed
        .long _inline_primitive_22
        .long _standard_library_210
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_208:
        .long 0x2ce11ed
        .long _standard_library_209
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_207:
        .long 0x2ce11ed
        .long _inline_primitive_22
        .long _standard_library_208
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_206:
        .long 0x2ce11ed
        .long _standard_library_207
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_202:
        .long 0x2ce11ed
        .long _standard_library_203
        .long _standard_library_206
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_201:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _standard_library_202
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_216:
        .long 0x2ce11ed
        .long _standard_library_205
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_214:
        .long 0x2ce11ed
        .long _standard_library_215
        .long _standard_library_216
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_221:
        .long 0x2ce11ed
        .long _standard_library_205
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_220:
        .long 0x2ce11ed
        .long _inline_primitive_22
        .long _standard_library_221
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_219:
        .long 0x2ce11ed
        .long _standard_library_220
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_218:
        .long 0x2ce11ed
        .long _inline_primitive_25
        .long _standard_library_219
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_217:
        .long 0x2ce11ed
        .long _standard_library_218
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_213:
        .long 0x2ce11ed
        .long _standard_library_214
        .long _standard_library_217
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_212:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _standard_library_213
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_226:
        .long 0x2ce11ed
        .long _standard_library_205
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_225:
        .long 0x2ce11ed
        .long _totally_macroexpand_277
        .long _standard_library_226
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_231:
        .long 0x2ce11ed
        .long _standard_library_205
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_230:
        .long 0x2ce11ed
        .long _inline_primitive_25
        .long _standard_library_231
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_229:
        .long 0x2ce11ed
        .long _standard_library_230
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_228:
        .long 0x2ce11ed
        .long _inline_primitive_22
        .long _standard_library_229
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_227:
        .long 0x2ce11ed
        .long _standard_library_228
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_224:
        .long 0x2ce11ed
        .long _standard_library_225
        .long _standard_library_227
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_223:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _standard_library_224
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_237:
        .long 0x2ce11ed
        .long _standard_library_205
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_235:
        .long 0x2ce11ed
        .long _standard_library_236
        .long _standard_library_237
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_242:
        .long 0x2ce11ed
        .long _standard_library_205
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_241:
        .long 0x2ce11ed
        .long _inline_primitive_25
        .long _standard_library_242
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_240:
        .long 0x2ce11ed
        .long _standard_library_241
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_239:
        .long 0x2ce11ed
        .long _inline_primitive_25
        .long _standard_library_240
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_238:
        .long 0x2ce11ed
        .long _standard_library_239
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_234:
        .long 0x2ce11ed
        .long _standard_library_235
        .long _standard_library_238
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_233:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _standard_library_234
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_247:
        .long 0x2ce11ed
        .long _standard_library_205
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_246:
        .long 0x2ce11ed
        .long _totally_macroexpand_281
        .long _standard_library_247
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_254:
        .long 0x2ce11ed
        .long _standard_library_205
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_253:
        .long 0x2ce11ed
        .long _inline_primitive_25
        .long _standard_library_254
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_252:
        .long 0x2ce11ed
        .long _standard_library_253
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_251:
        .long 0x2ce11ed
        .long _inline_primitive_25
        .long _standard_library_252
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_250:
        .long 0x2ce11ed
        .long _standard_library_251
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_249:
        .long 0x2ce11ed
        .long _inline_primitive_22
        .long _standard_library_250
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_248:
        .long 0x2ce11ed
        .long _standard_library_249
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_245:
        .long 0x2ce11ed
        .long _standard_library_246
        .long _standard_library_248
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_244:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _standard_library_245
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_260:
        .long 0x2ce11ed
        .long _standard_library_205
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_258:
        .long 0x2ce11ed
        .long _standard_library_259
        .long _standard_library_260
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_267:
        .long 0x2ce11ed
        .long _standard_library_205
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_266:
        .long 0x2ce11ed
        .long _inline_primitive_25
        .long _standard_library_267
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_265:
        .long 0x2ce11ed
        .long _standard_library_266
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_264:
        .long 0x2ce11ed
        .long _inline_primitive_22
        .long _standard_library_265
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_263:
        .long 0x2ce11ed
        .long _standard_library_264
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_262:
        .long 0x2ce11ed
        .long _inline_primitive_22
        .long _standard_library_263
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_261:
        .long 0x2ce11ed
        .long _standard_library_262
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_257:
        .long 0x2ce11ed
        .long _standard_library_258
        .long _standard_library_261
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_256:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _standard_library_257
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_273:
        .long 0x2ce11ed
        .long _standard_library_205
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_271:
        .long 0x2ce11ed
        .long _standard_library_272
        .long _standard_library_273
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_280:
        .long 0x2ce11ed
        .long _standard_library_205
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_279:
        .long 0x2ce11ed
        .long _inline_primitive_25
        .long _standard_library_280
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_278:
        .long 0x2ce11ed
        .long _standard_library_279
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_277:
        .long 0x2ce11ed
        .long _inline_primitive_22
        .long _standard_library_278
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_276:
        .long 0x2ce11ed
        .long _standard_library_277
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_275:
        .long 0x2ce11ed
        .long _inline_primitive_25
        .long _standard_library_276
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_274:
        .long 0x2ce11ed
        .long _standard_library_275
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_270:
        .long 0x2ce11ed
        .long _standard_library_271
        .long _standard_library_274
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_269:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _standard_library_270
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_286:
        .long 0x2ce11ed
        .long _standard_library_205
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_284:
        .long 0x2ce11ed
        .long _standard_library_285
        .long _standard_library_286
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_293:
        .long 0x2ce11ed
        .long _standard_library_205
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_292:
        .long 0x2ce11ed
        .long _inline_primitive_22
        .long _standard_library_293
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_291:
        .long 0x2ce11ed
        .long _standard_library_292
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_290:
        .long 0x2ce11ed
        .long _inline_primitive_25
        .long _standard_library_291
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_289:
        .long 0x2ce11ed
        .long _standard_library_290
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_288:
        .long 0x2ce11ed
        .long _inline_primitive_22
        .long _standard_library_289
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_287:
        .long 0x2ce11ed
        .long _standard_library_288
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_283:
        .long 0x2ce11ed
        .long _standard_library_284
        .long _standard_library_287
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_282:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _standard_library_283
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_299:
        .long 0x2ce11ed
        .long _standard_library_205
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_297:
        .long 0x2ce11ed
        .long _standard_library_298
        .long _standard_library_299
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_308:
        .long 0x2ce11ed
        .long _standard_library_205
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_307:
        .long 0x2ce11ed
        .long _inline_primitive_22
        .long _standard_library_308
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_306:
        .long 0x2ce11ed
        .long _standard_library_307
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_305:
        .long 0x2ce11ed
        .long _inline_primitive_25
        .long _standard_library_306
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_304:
        .long 0x2ce11ed
        .long _standard_library_305
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_303:
        .long 0x2ce11ed
        .long _inline_primitive_25
        .long _standard_library_304
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_302:
        .long 0x2ce11ed
        .long _standard_library_303
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_301:
        .long 0x2ce11ed
        .long _inline_primitive_22
        .long _standard_library_302
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_300:
        .long 0x2ce11ed
        .long _standard_library_301
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_296:
        .long 0x2ce11ed
        .long _standard_library_297
        .long _standard_library_300
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_295:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _standard_library_296
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_314:
        .long 0x2ce11ed
        .long _standard_library_205
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_312:
        .long 0x2ce11ed
        .long _standard_library_313
        .long _standard_library_314
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_323:
        .long 0x2ce11ed
        .long _standard_library_205
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_322:
        .long 0x2ce11ed
        .long _inline_primitive_25
        .long _standard_library_323
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_321:
        .long 0x2ce11ed
        .long _standard_library_322
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_320:
        .long 0x2ce11ed
        .long _inline_primitive_25
        .long _standard_library_321
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_319:
        .long 0x2ce11ed
        .long _standard_library_320
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_318:
        .long 0x2ce11ed
        .long _inline_primitive_25
        .long _standard_library_319
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_317:
        .long 0x2ce11ed
        .long _standard_library_318
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_316:
        .long 0x2ce11ed
        .long _inline_primitive_22
        .long _standard_library_317
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_315:
        .long 0x2ce11ed
        .long _standard_library_316
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_311:
        .long 0x2ce11ed
        .long _standard_library_312
        .long _standard_library_315
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_310:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _standard_library_311
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_329:
        .long 0x2ce11ed
        .long _standard_library_205
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_327:
        .long 0x2ce11ed
        .long _standard_library_328
        .long _standard_library_329
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_338:
        .long 0x2ce11ed
        .long _standard_library_205
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_337:
        .long 0x2ce11ed
        .long _inline_primitive_25
        .long _standard_library_338
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_336:
        .long 0x2ce11ed
        .long _standard_library_337
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_335:
        .long 0x2ce11ed
        .long _inline_primitive_22
        .long _standard_library_336
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_334:
        .long 0x2ce11ed
        .long _standard_library_335
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_333:
        .long 0x2ce11ed
        .long _inline_primitive_22
        .long _standard_library_334
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_332:
        .long 0x2ce11ed
        .long _standard_library_333
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_331:
        .long 0x2ce11ed
        .long _inline_primitive_22
        .long _standard_library_332
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_330:
        .long 0x2ce11ed
        .long _standard_library_331
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_326:
        .long 0x2ce11ed
        .long _standard_library_327
        .long _standard_library_330
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_325:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _standard_library_326
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_343:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_342:
        .long 0x2ce11ed
        .long _macroexpand_1_88
        .long _standard_library_343
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_348:
        .long 0x2ce11ed
        .long 2 + 257<<2
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_347:
        .long 0x2ce11ed
        .long 2 + 258<<2
        .long _standard_library_348
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_346:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long _standard_library_347
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_345:
        .long 0x2ce11ed
        .long _macroexpand_1_20
        .long _standard_library_346
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_344:
        .long 0x2ce11ed
        .long _standard_library_345
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_341:
        .long 0x2ce11ed
        .long _standard_library_342
        .long _standard_library_344
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_340:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _standard_library_341
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_353:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_352:
        .long 0x2ce11ed
        .long _inline_primitive_34
        .long _standard_library_353
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_356:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_355:
        .long 0x2ce11ed
        .long _inline_primitive_34
        .long _standard_library_356
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_354:
        .long 0x2ce11ed
        .long _standard_library_355
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_351:
        .long 0x2ce11ed
        .long _standard_library_352
        .long _standard_library_354
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_350:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _standard_library_351
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_361:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_360:
        .long 0x2ce11ed
        .long _inline_primitive_37
        .long _standard_library_361
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_364:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_363:
        .long 0x2ce11ed
        .long _inline_primitive_37
        .long _standard_library_364
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_362:
        .long 0x2ce11ed
        .long _standard_library_363
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_359:
        .long 0x2ce11ed
        .long _standard_library_360
        .long _standard_library_362
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_358:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _standard_library_359
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_372:
        .long 0x2ce11ed
        .long _standard_library_373
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_370:
        .long 0x2ce11ed
        .long _standard_library_371
        .long _standard_library_372
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_368:
        .long 0x2ce11ed
        .long _standard_library_369
        .long _standard_library_370
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_386:
        .long 0x2ce11ed
        .long _standard_library_371
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_385:
        .long 0x2ce11ed
        .long _inline_primitive_34
        .long _standard_library_386
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_389:
        .long 0x2ce11ed
        .long _standard_library_373
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_388:
        .long 0x2ce11ed
        .long _inline_primitive_34
        .long _standard_library_389
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_387:
        .long 0x2ce11ed
        .long _standard_library_388
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_384:
        .long 0x2ce11ed
        .long _standard_library_385
        .long _standard_library_387
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_383:
        .long 0x2ce11ed
        .long _inline_primitive_10
        .long _standard_library_384
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_382:
        .long 0x2ce11ed
        .long _standard_library_383
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_381:
        .long 0x2ce11ed
        .long _extract_string_15
        .long _standard_library_382
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_380:
        .long 0x2ce11ed
        .long _standard_library_381
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_378:
        .long 0x2ce11ed
        .long _standard_library_379
        .long _standard_library_380
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_377:
        .long 0x2ce11ed
        .long _standard_library_378
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_397:
        .long 0x2ce11ed
        .long _standard_library_371
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_396:
        .long 0x2ce11ed
        .long _inline_primitive_34
        .long _standard_library_397
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_399:
        .long 0x2ce11ed
        .long 1 + 0<<2
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_398:
        .long 0x2ce11ed
        .long _standard_library_379
        .long _standard_library_399
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_395:
        .long 0x2ce11ed
        .long _standard_library_396
        .long _standard_library_398
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_394:
        .long 0x2ce11ed
        .long 1 + 0<<2
        .long _standard_library_395
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_393:
        .long 0x2ce11ed
        .long _standard_library_371
        .long _standard_library_394
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_391:
        .long 0x2ce11ed
        .long _standard_library_392
        .long _standard_library_393
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_406:
        .long 0x2ce11ed
        .long _standard_library_373
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_405:
        .long 0x2ce11ed
        .long _inline_primitive_34
        .long _standard_library_406
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_410:
        .long 0x2ce11ed
        .long _standard_library_371
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_409:
        .long 0x2ce11ed
        .long _inline_primitive_34
        .long _standard_library_410
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_408:
        .long 0x2ce11ed
        .long _standard_library_409
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_407:
        .long 0x2ce11ed
        .long _standard_library_379
        .long _standard_library_408
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_404:
        .long 0x2ce11ed
        .long _standard_library_405
        .long _standard_library_407
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_403:
        .long 0x2ce11ed
        .long 1 + 0<<2
        .long _standard_library_404
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_402:
        .long 0x2ce11ed
        .long _standard_library_373
        .long _standard_library_403
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_401:
        .long 0x2ce11ed
        .long _standard_library_392
        .long _standard_library_402
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_411:
        .long 0x2ce11ed
        .long _standard_library_379
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_400:
        .long 0x2ce11ed
        .long _standard_library_401
        .long _standard_library_411
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_390:
        .long 0x2ce11ed
        .long _standard_library_391
        .long _standard_library_400
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_376:
        .long 0x2ce11ed
        .long _standard_library_377
        .long _standard_library_390
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_375:
        .long 0x2ce11ed
        .long _macroexpand_1_31
        .long _standard_library_376
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_374:
        .long 0x2ce11ed
        .long _standard_library_375
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_367:
        .long 0x2ce11ed
        .long _standard_library_368
        .long _standard_library_374
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_366:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _standard_library_367
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_424:
        .long 0x2ce11ed
        .long _standard_library_425
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_422:
        .long 0x2ce11ed
        .long _standard_library_423
        .long _standard_library_424
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_420:
        .long 0x2ce11ed
        .long _standard_library_421
        .long _standard_library_422
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_418:
        .long 0x2ce11ed
        .long _standard_library_419
        .long _standard_library_420
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_416:
        .long 0x2ce11ed
        .long _standard_library_417
        .long _standard_library_418
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_415:
        .long 0x2ce11ed
        .long _standard_library_392
        .long _standard_library_416
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_433:
        .long 0x2ce11ed
        .long 1 + 0<<2
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_432:
        .long 0x2ce11ed
        .long _standard_library_421
        .long _standard_library_433
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_431:
        .long 0x2ce11ed
        .long _macroexpand_1_82
        .long _standard_library_432
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_430:
        .long 0x2ce11ed
        .long _standard_library_431
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_429:
        .long 0x2ce11ed
        .long _macroexpand_1_88
        .long _standard_library_430
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_443:
        .long 0x2ce11ed
        .long _standard_library_419
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_442:
        .long 0x2ce11ed
        .long _standard_library_417
        .long _standard_library_443
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_441:
        .long 0x2ce11ed
        .long _check_array_bounds_30
        .long _standard_library_442
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_440:
        .long 0x2ce11ed
        .long _standard_library_441
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_439:
        .long 0x2ce11ed
        .long _standard_library_425
        .long _standard_library_440
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_438:
        .long 0x2ce11ed
        .long _standard_library_423
        .long _standard_library_439
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_437:
        .long 0x2ce11ed
        .long _check_array_bounds_23
        .long _standard_library_438
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_449:
        .long 0x2ce11ed
        .long _standard_library_419
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_448:
        .long 0x2ce11ed
        .long _inline_primitive_16
        .long _standard_library_449
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_452:
        .long 0x2ce11ed
        .long _standard_library_421
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_451:
        .long 0x2ce11ed
        .long _inline_primitive_19
        .long _standard_library_452
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_456:
        .long 0x2ce11ed
        .long _standard_library_425
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_455:
        .long 0x2ce11ed
        .long _inline_primitive_16
        .long _standard_library_456
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_454:
        .long 0x2ce11ed
        .long _standard_library_455
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_453:
        .long 0x2ce11ed
        .long _standard_library_423
        .long _standard_library_454
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_450:
        .long 0x2ce11ed
        .long _standard_library_451
        .long _standard_library_453
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_447:
        .long 0x2ce11ed
        .long _standard_library_448
        .long _standard_library_450
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_446:
        .long 0x2ce11ed
        .long _standard_library_417
        .long _standard_library_447
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_445:
        .long 0x2ce11ed
        .long _standard_library_392
        .long _standard_library_446
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_444:
        .long 0x2ce11ed
        .long _standard_library_445
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_436:
        .long 0x2ce11ed
        .long _standard_library_437
        .long _standard_library_444
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_435:
        .long 0x2ce11ed
        .long _macroexpand_1_10
        .long _standard_library_436
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_434:
        .long 0x2ce11ed
        .long _standard_library_435
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_428:
        .long 0x2ce11ed
        .long _standard_library_429
        .long _standard_library_434
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_427:
        .long 0x2ce11ed
        .long _macroexpand_1_20
        .long _standard_library_428
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_426:
        .long 0x2ce11ed
        .long _standard_library_427
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_414:
        .long 0x2ce11ed
        .long _standard_library_415
        .long _standard_library_426
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_413:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _standard_library_414
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_462:
        .long 0x2ce11ed
        .long _sample_abcd_4
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_460:
        .long 0x2ce11ed
        .long _standard_library_461
        .long _standard_library_462
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_470:
        .long 0x2ce11ed
        .long 2 + 9<<2
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_469:
        .long 0x2ce11ed
        .long 2 + 10<<2
        .long _standard_library_470
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_468:
        .long 0x2ce11ed
        .long 2 + 32<<2
        .long _standard_library_469
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_471:
        .long 0x2ce11ed
        .long 2 + 257<<2
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_467:
        .long 0x2ce11ed
        .long _standard_library_468
        .long _standard_library_471
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_474:
        .long 0x2ce11ed
        .long 2 + 258<<2
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_473:
        .long 0x2ce11ed
        .long _macroexpand_1_18
        .long _standard_library_474
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_472:
        .long 0x2ce11ed
        .long _standard_library_473
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_466:
        .long 0x2ce11ed
        .long _standard_library_467
        .long _standard_library_472
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_465:
        .long 0x2ce11ed
        .long _sample_abcd_4
        .long _standard_library_466
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_464:
        .long 0x2ce11ed
        .long _macroexpand_1_41
        .long _standard_library_465
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_463:
        .long 0x2ce11ed
        .long _standard_library_464
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_459:
        .long 0x2ce11ed
        .long _standard_library_460
        .long _standard_library_463
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_458:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _standard_library_459
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_481:
        .long 0x2ce11ed
        .long _set_union_all_12
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_480:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long _standard_library_481
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_478:
        .long 0x2ce11ed
        .long _standard_library_479
        .long _standard_library_480
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_486:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_485:
        .long 0x2ce11ed
        .long _inline_primitive_31
        .long _standard_library_486
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_489:
        .long 0x2ce11ed
        .long _set_union_all_12
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_488:
        .long 0x2ce11ed
        .long _inline_primitive_31
        .long _standard_library_489
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_487:
        .long 0x2ce11ed
        .long _standard_library_488
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_484:
        .long 0x2ce11ed
        .long _standard_library_485
        .long _standard_library_487
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_483:
        .long 0x2ce11ed
        .long _emit_division_code_24
        .long _standard_library_484
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_482:
        .long 0x2ce11ed
        .long _standard_library_483
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_477:
        .long 0x2ce11ed
        .long _standard_library_478
        .long _standard_library_482
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_476:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _standard_library_477
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_496:
        .long 0x2ce11ed
        .long _set_union_all_12
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_495:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long _standard_library_496
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_493:
        .long 0x2ce11ed
        .long _standard_library_494
        .long _standard_library_495
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_502:
        .long 0x2ce11ed
        .long _set_union_all_12
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_501:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long _standard_library_502
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_500:
        .long 0x2ce11ed
        .long _macroexpand_1_44
        .long _standard_library_501
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_506:
        .long 0x2ce11ed
        .long _set_union_all_12
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_505:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long _standard_library_506
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_504:
        .long 0x2ce11ed
        .long _standard_library_479
        .long _standard_library_505
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_503:
        .long 0x2ce11ed
        .long _standard_library_504
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_499:
        .long 0x2ce11ed
        .long _standard_library_500
        .long _standard_library_503
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_498:
        .long 0x2ce11ed
        .long _macroexpand_1_54
        .long _standard_library_499
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_497:
        .long 0x2ce11ed
        .long _standard_library_498
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_492:
        .long 0x2ce11ed
        .long _standard_library_493
        .long _standard_library_497
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_491:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _standard_library_492
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_514:
        .long 0x2ce11ed
        .long _sample_abcd_4
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_513:
        .long 0x2ce11ed
        .long _set_union_all_12
        .long _standard_library_514
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_512:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long _standard_library_513
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_510:
        .long 0x2ce11ed
        .long _standard_library_511
        .long _standard_library_512
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_520:
        .long 0x2ce11ed
        .long _set_union_all_12
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_519:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long _standard_library_520
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_518:
        .long 0x2ce11ed
        .long _standard_library_494
        .long _standard_library_519
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_524:
        .long 0x2ce11ed
        .long _sample_abcd_4
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_523:
        .long 0x2ce11ed
        .long _set_union_all_12
        .long _standard_library_524
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_522:
        .long 0x2ce11ed
        .long _standard_library_494
        .long _standard_library_523
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_521:
        .long 0x2ce11ed
        .long _standard_library_522
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_517:
        .long 0x2ce11ed
        .long _standard_library_518
        .long _standard_library_521
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_516:
        .long 0x2ce11ed
        .long _macroexpand_1_63
        .long _standard_library_517
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_515:
        .long 0x2ce11ed
        .long _standard_library_516
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_509:
        .long 0x2ce11ed
        .long _standard_library_510
        .long _standard_library_515
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_508:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _standard_library_509
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_530:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_528:
        .long 0x2ce11ed
        .long _standard_library_529
        .long _standard_library_530
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_537:
        .long 0x2ce11ed
        .long 2 + 90<<2
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_536:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long _standard_library_537
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_535:
        .long 0x2ce11ed
        .long 2 + 65<<2
        .long _standard_library_536
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_534:
        .long 0x2ce11ed
        .long _standard_library_511
        .long _standard_library_535
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_542:
        .long 0x2ce11ed
        .long 2 + 122<<2
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_541:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long _standard_library_542
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_540:
        .long 0x2ce11ed
        .long 2 + 97<<2
        .long _standard_library_541
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_539:
        .long 0x2ce11ed
        .long _standard_library_511
        .long _standard_library_540
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_538:
        .long 0x2ce11ed
        .long _standard_library_539
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_533:
        .long 0x2ce11ed
        .long _standard_library_534
        .long _standard_library_538
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_532:
        .long 0x2ce11ed
        .long _macroexpand_1_54
        .long _standard_library_533
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_531:
        .long 0x2ce11ed
        .long _standard_library_532
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_527:
        .long 0x2ce11ed
        .long _standard_library_528
        .long _standard_library_531
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_526:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _standard_library_527
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_548:
        .long 0x2ce11ed
        .long _standard_library_549
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_546:
        .long 0x2ce11ed
        .long _standard_library_547
        .long _standard_library_548
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_554:
        .long 0x2ce11ed
        .long 2 + 57<<2
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_553:
        .long 0x2ce11ed
        .long _standard_library_549
        .long _standard_library_554
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_552:
        .long 0x2ce11ed
        .long 2 + 48<<2
        .long _standard_library_553
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_551:
        .long 0x2ce11ed
        .long _standard_library_511
        .long _standard_library_552
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_550:
        .long 0x2ce11ed
        .long _standard_library_551
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_545:
        .long 0x2ce11ed
        .long _standard_library_546
        .long _standard_library_550
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_544:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _standard_library_545
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_560:
        .long 0x2ce11ed
        .long _set_union_all_12
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_559:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long _standard_library_560
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_558:
        .long 0x2ce11ed
        .long _macroexpand_1_79
        .long _standard_library_559
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_566:
        .long 0x2ce11ed
        .long _set_union_all_12
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_565:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long _standard_library_566
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_564:
        .long 0x2ce11ed
        .long _macroexpand_1_79
        .long _standard_library_565
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_568:
        .long 0x2ce11ed
        .long 2 + 258<<2
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_567:
        .long 0x2ce11ed
        .long 2 + 257<<2
        .long _standard_library_568
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_563:
        .long 0x2ce11ed
        .long _standard_library_564
        .long _standard_library_567
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_562:
        .long 0x2ce11ed
        .long _macroexpand_1_20
        .long _standard_library_563
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_561:
        .long 0x2ce11ed
        .long _standard_library_562
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_557:
        .long 0x2ce11ed
        .long _standard_library_558
        .long _standard_library_561
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_556:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _standard_library_557
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_572:
        .long 0x2ce11ed
        .long _macroexpand_1_79
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_571:
        .long 0x2ce11ed
        .long _macroexpand_1_82
        .long _standard_library_572
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_570:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _standard_library_571
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_577:
        .long 0x2ce11ed
        .long _macroexpand_1_79
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_575:
        .long 0x2ce11ed
        .long _standard_library_576
        .long _standard_library_577
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_574:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _standard_library_575
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_581:
        .long 0x2ce11ed
        .long _macroexpand_1_79
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_580:
        .long 0x2ce11ed
        .long _macroexpand_1_44
        .long _standard_library_581
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_579:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _standard_library_580
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_588:
        .long 0x2ce11ed
        .long _set_union_all_12
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_587:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long _standard_library_588
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_585:
        .long 0x2ce11ed
        .long _standard_library_586
        .long _standard_library_587
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_595:
        .long 0x2ce11ed
        .long _set_union_all_12
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_594:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long _standard_library_595
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_593:
        .long 0x2ce11ed
        .long _macroexpand_1_79
        .long _standard_library_594
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_596:
        .long 0x2ce11ed
        .long 2 + 257<<2
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_592:
        .long 0x2ce11ed
        .long _standard_library_593
        .long _standard_library_596
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_600:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_599:
        .long 0x2ce11ed
        .long _string_magic_3
        .long _standard_library_600
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_605:
        .long 0x2ce11ed
        .long _set_union_all_12
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_604:
        .long 0x2ce11ed
        .long _string_magic_3
        .long _standard_library_605
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_610:
        .long 0x2ce11ed
        .long _set_union_all_12
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_609:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long _standard_library_610
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_607:
        .long 0x2ce11ed
        .long _standard_library_608
        .long _standard_library_609
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_606:
        .long 0x2ce11ed
        .long _standard_library_607
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_603:
        .long 0x2ce11ed
        .long _standard_library_604
        .long _standard_library_606
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_602:
        .long 0x2ce11ed
        .long _macroexpand_1_63
        .long _standard_library_603
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_601:
        .long 0x2ce11ed
        .long _standard_library_602
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_598:
        .long 0x2ce11ed
        .long _standard_library_599
        .long _standard_library_601
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_614:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_613:
        .long 0x2ce11ed
        .long _cons_magic_3
        .long _standard_library_614
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_619:
        .long 0x2ce11ed
        .long _set_union_all_12
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_618:
        .long 0x2ce11ed
        .long _cons_magic_3
        .long _standard_library_619
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_624:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_623:
        .long 0x2ce11ed
        .long _inline_primitive_22
        .long _standard_library_624
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_627:
        .long 0x2ce11ed
        .long _set_union_all_12
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_626:
        .long 0x2ce11ed
        .long _inline_primitive_22
        .long _standard_library_627
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_625:
        .long 0x2ce11ed
        .long _standard_library_626
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_622:
        .long 0x2ce11ed
        .long _standard_library_623
        .long _standard_library_625
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_621:
        .long 0x2ce11ed
        .long _standard_library_586
        .long _standard_library_622
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_632:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_631:
        .long 0x2ce11ed
        .long _inline_primitive_25
        .long _standard_library_632
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_635:
        .long 0x2ce11ed
        .long _set_union_all_12
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_634:
        .long 0x2ce11ed
        .long _inline_primitive_25
        .long _standard_library_635
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_633:
        .long 0x2ce11ed
        .long _standard_library_634
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_630:
        .long 0x2ce11ed
        .long _standard_library_631
        .long _standard_library_633
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_629:
        .long 0x2ce11ed
        .long _standard_library_586
        .long _standard_library_630
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_628:
        .long 0x2ce11ed
        .long _standard_library_629
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_620:
        .long 0x2ce11ed
        .long _standard_library_621
        .long _standard_library_628
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_617:
        .long 0x2ce11ed
        .long _standard_library_618
        .long _standard_library_620
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_616:
        .long 0x2ce11ed
        .long _macroexpand_1_63
        .long _standard_library_617
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_615:
        .long 0x2ce11ed
        .long _standard_library_616
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_612:
        .long 0x2ce11ed
        .long _standard_library_613
        .long _standard_library_615
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_638:
        .long 0x2ce11ed
        .long 2 + 258<<2
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_637:
        .long 0x2ce11ed
        .long _macroexpand_1_18
        .long _standard_library_638
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_636:
        .long 0x2ce11ed
        .long _standard_library_637
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_611:
        .long 0x2ce11ed
        .long _standard_library_612
        .long _standard_library_636
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_597:
        .long 0x2ce11ed
        .long _standard_library_598
        .long _standard_library_611
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_591:
        .long 0x2ce11ed
        .long _standard_library_592
        .long _standard_library_597
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_590:
        .long 0x2ce11ed
        .long _macroexpand_1_19
        .long _standard_library_591
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_589:
        .long 0x2ce11ed
        .long _standard_library_590
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_584:
        .long 0x2ce11ed
        .long _standard_library_585
        .long _standard_library_589
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_583:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _standard_library_584
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_644:
        .long 0x2ce11ed
        .long _set_union_all_12
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_643:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long _standard_library_644
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_642:
        .long 0x2ce11ed
        .long _standard_library_608
        .long _standard_library_643
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_651:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_650:
        .long 0x2ce11ed
        .long _inline_primitive_34
        .long _standard_library_651
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_654:
        .long 0x2ce11ed
        .long _set_union_all_12
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_653:
        .long 0x2ce11ed
        .long _inline_primitive_34
        .long _standard_library_654
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_652:
        .long 0x2ce11ed
        .long _standard_library_653
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_649:
        .long 0x2ce11ed
        .long _standard_library_650
        .long _standard_library_652
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_648:
        .long 0x2ce11ed
        .long _macroexpand_1_82
        .long _standard_library_649
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_660:
        .long 0x2ce11ed
        .long 1 + 0<<2
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_659:
        .long 0x2ce11ed
        .long _set_union_all_12
        .long _standard_library_660
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_658:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long _standard_library_659
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_656:
        .long 0x2ce11ed
        .long _standard_library_657
        .long _standard_library_658
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_655:
        .long 0x2ce11ed
        .long _standard_library_656
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_647:
        .long 0x2ce11ed
        .long _standard_library_648
        .long _standard_library_655
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_646:
        .long 0x2ce11ed
        .long _macroexpand_1_63
        .long _standard_library_647
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_645:
        .long 0x2ce11ed
        .long _standard_library_646
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_641:
        .long 0x2ce11ed
        .long _standard_library_642
        .long _standard_library_645
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_640:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _standard_library_641
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_667:
        .long 0x2ce11ed
        .long _standard_library_668
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_666:
        .long 0x2ce11ed
        .long _set_union_all_12
        .long _standard_library_667
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_665:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long _standard_library_666
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_664:
        .long 0x2ce11ed
        .long _standard_library_657
        .long _standard_library_665
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_676:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_675:
        .long 0x2ce11ed
        .long _inline_primitive_34
        .long _standard_library_676
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_674:
        .long 0x2ce11ed
        .long _standard_library_675
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_673:
        .long 0x2ce11ed
        .long _standard_library_668
        .long _standard_library_674
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_672:
        .long 0x2ce11ed
        .long _macroexpand_1_82
        .long _standard_library_673
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_684:
        .long 0x2ce11ed
        .long _standard_library_668
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_683:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long _standard_library_684
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_682:
        .long 0x2ce11ed
        .long _check_array_bounds_30
        .long _standard_library_683
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_688:
        .long 0x2ce11ed
        .long _standard_library_668
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_687:
        .long 0x2ce11ed
        .long _set_union_all_12
        .long _standard_library_688
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_686:
        .long 0x2ce11ed
        .long _check_array_bounds_30
        .long _standard_library_687
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_685:
        .long 0x2ce11ed
        .long _standard_library_686
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_681:
        .long 0x2ce11ed
        .long _standard_library_682
        .long _standard_library_685
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_680:
        .long 0x2ce11ed
        .long _standard_library_576
        .long _standard_library_681
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_695:
        .long 0x2ce11ed
        .long _standard_library_668
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_694:
        .long 0x2ce11ed
        .long _inline_primitive_16
        .long _standard_library_695
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_693:
        .long 0x2ce11ed
        .long _standard_library_694
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_692:
        .long 0x2ce11ed
        .long _set_union_all_12
        .long _standard_library_693
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_691:
        .long 0x2ce11ed
        .long _set_union_all_8
        .long _standard_library_692
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_690:
        .long 0x2ce11ed
        .long _standard_library_657
        .long _standard_library_691
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_689:
        .long 0x2ce11ed
        .long _standard_library_690
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_679:
        .long 0x2ce11ed
        .long _standard_library_680
        .long _standard_library_689
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_678:
        .long 0x2ce11ed
        .long _macroexpand_1_63
        .long _standard_library_679
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_677:
        .long 0x2ce11ed
        .long _standard_library_678
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_671:
        .long 0x2ce11ed
        .long _standard_library_672
        .long _standard_library_677
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_670:
        .long 0x2ce11ed
        .long _macroexpand_1_54
        .long _standard_library_671
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_669:
        .long 0x2ce11ed
        .long _standard_library_670
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_663:
        .long 0x2ce11ed
        .long _standard_library_664
        .long _standard_library_669
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_662:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _standard_library_663
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_700:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_699:
        .long 0x2ce11ed
        .long _macroexpand_1_85
        .long _standard_library_700
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_705:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_704:
        .long 0x2ce11ed
        .long _macroexpand_1_85
        .long _standard_library_705
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_707:
        .long 0x2ce11ed
        .long 2 + 258<<2
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_706:
        .long 0x2ce11ed
        .long 2 + 257<<2
        .long _standard_library_707
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_703:
        .long 0x2ce11ed
        .long _standard_library_704
        .long _standard_library_706
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_702:
        .long 0x2ce11ed
        .long _macroexpand_1_20
        .long _standard_library_703
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_701:
        .long 0x2ce11ed
        .long _standard_library_702
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_698:
        .long 0x2ce11ed
        .long _standard_library_699
        .long _standard_library_701
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_697:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _standard_library_698
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_713:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_711:
        .long 0x2ce11ed
        .long _standard_library_712
        .long _standard_library_713
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_719:
        .long 0x2ce11ed
        .long 2 + 257<<2
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_718:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long _standard_library_719
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_717:
        .long 0x2ce11ed
        .long _macroexpand_1_79
        .long _standard_library_718
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_724:
        .long 0x2ce11ed
        .long 2 + 258<<2
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_723:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long _standard_library_724
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_722:
        .long 0x2ce11ed
        .long _macroexpand_1_79
        .long _standard_library_723
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_721:
        .long 0x2ce11ed
        .long _standard_library_722
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_720:
        .long 0x2ce11ed
        .long 2 + 257<<2
        .long _standard_library_721
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_716:
        .long 0x2ce11ed
        .long _standard_library_717
        .long _standard_library_720
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_715:
        .long 0x2ce11ed
        .long _macroexpand_1_20
        .long _standard_library_716
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_714:
        .long 0x2ce11ed
        .long _standard_library_715
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_710:
        .long 0x2ce11ed
        .long _standard_library_711
        .long _standard_library_714
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_709:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _standard_library_710
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_729:
        .long 0x2ce11ed
        .long _integer_tag_6
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_727:
        .long 0x2ce11ed
        .long _standard_library_728
        .long _standard_library_729
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_726:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _standard_library_727
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_737:
        .long 0x2ce11ed
        .long _standard_library_58
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_735:
        .long 0x2ce11ed
        .long _standard_library_736
        .long _standard_library_737
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_733:
        .long 0x2ce11ed
        .long _standard_library_734
        .long _standard_library_735
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_744:
        .long 0x2ce11ed
        .long _standard_library_58
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_743:
        .long 0x2ce11ed
        .long _macroexpand_1_85
        .long _standard_library_744
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_742:
        .long 0x2ce11ed
        .long _standard_library_743
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_741:
        .long 0x2ce11ed
        .long _macroexpand_1_88
        .long _standard_library_742
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_751:
        .long 0x2ce11ed
        .long _standard_library_58
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_750:
        .long 0x2ce11ed
        .long _inline_primitive_22
        .long _standard_library_751
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_749:
        .long 0x2ce11ed
        .long _standard_library_750
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_748:
        .long 0x2ce11ed
        .long _standard_library_736
        .long _standard_library_749
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_757:
        .long 0x2ce11ed
        .long _standard_library_58
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_756:
        .long 0x2ce11ed
        .long _inline_primitive_25
        .long _standard_library_757
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_755:
        .long 0x2ce11ed
        .long _standard_library_756
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_754:
        .long 0x2ce11ed
        .long _standard_library_736
        .long _standard_library_755
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_753:
        .long 0x2ce11ed
        .long _standard_library_734
        .long _standard_library_754
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_752:
        .long 0x2ce11ed
        .long _standard_library_753
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_747:
        .long 0x2ce11ed
        .long _standard_library_748
        .long _standard_library_752
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_746:
        .long 0x2ce11ed
        .long _macroexpand_1_10
        .long _standard_library_747
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_745:
        .long 0x2ce11ed
        .long _standard_library_746
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_740:
        .long 0x2ce11ed
        .long _standard_library_741
        .long _standard_library_745
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_739:
        .long 0x2ce11ed
        .long _macroexpand_1_20
        .long _standard_library_740
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_738:
        .long 0x2ce11ed
        .long _standard_library_739
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_732:
        .long 0x2ce11ed
        .long _standard_library_733
        .long _standard_library_738
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_731:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _standard_library_732
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_764:
        .long 0x2ce11ed
        .long _standard_library_58
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_763:
        .long 0x2ce11ed
        .long _standard_library_736
        .long _standard_library_764
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_761:
        .long 0x2ce11ed
        .long _standard_library_762
        .long _standard_library_763
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_769:
        .long 0x2ce11ed
        .long _standard_library_58
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_768:
        .long 0x2ce11ed
        .long _macroexpand_1_85
        .long _standard_library_769
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_772:
        .long 0x2ce11ed
        .long 2 + 256<<2
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_771:
        .long 0x2ce11ed
        .long _free_vars_20
        .long _standard_library_772
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_779:
        .long 0x2ce11ed
        .long _standard_library_58
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_778:
        .long 0x2ce11ed
        .long _inline_primitive_22
        .long _standard_library_779
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_777:
        .long 0x2ce11ed
        .long _standard_library_778
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_776:
        .long 0x2ce11ed
        .long _standard_library_736
        .long _standard_library_777
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_785:
        .long 0x2ce11ed
        .long _standard_library_58
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_784:
        .long 0x2ce11ed
        .long _inline_primitive_25
        .long _standard_library_785
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_783:
        .long 0x2ce11ed
        .long _standard_library_784
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_782:
        .long 0x2ce11ed
        .long _standard_library_736
        .long _standard_library_783
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_781:
        .long 0x2ce11ed
        .long _standard_library_762
        .long _standard_library_782
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_780:
        .long 0x2ce11ed
        .long _standard_library_781
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_775:
        .long 0x2ce11ed
        .long _standard_library_776
        .long _standard_library_780
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_774:
        .long 0x2ce11ed
        .long _inline_cdr_13
        .long _standard_library_775
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_773:
        .long 0x2ce11ed
        .long _standard_library_774
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_770:
        .long 0x2ce11ed
        .long _standard_library_771
        .long _standard_library_773
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_767:
        .long 0x2ce11ed
        .long _standard_library_768
        .long _standard_library_770
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_766:
        .long 0x2ce11ed
        .long _macroexpand_1_20
        .long _standard_library_767
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_765:
        .long 0x2ce11ed
        .long _standard_library_766
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_760:
        .long 0x2ce11ed
        .long _standard_library_761
        .long _standard_library_765
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_759:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _standard_library_760
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_791:
        .long 0x2ce11ed
        .long _parse_eofP_42
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_789:
        .long 0x2ce11ed
        .long _standard_library_790
        .long _standard_library_791
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_797:
        .long 0x2ce11ed
        .long 2 + 256<<2
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_796:
        .long 0x2ce11ed
        .long _free_vars_20
        .long _standard_library_797
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_798:
        .long 0x2ce11ed
        .long _parse_eofP_42
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_795:
        .long 0x2ce11ed
        .long _standard_library_796
        .long _standard_library_798
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_793:
        .long 0x2ce11ed
        .long _standard_library_794
        .long _standard_library_795
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_792:
        .long 0x2ce11ed
        .long _standard_library_793
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_788:
        .long 0x2ce11ed
        .long _standard_library_789
        .long _standard_library_792
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_787:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _standard_library_788
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_805:
        .long 0x2ce11ed
        .long _parse_eofP_42
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_803:
        .long 0x2ce11ed
        .long _standard_library_804
        .long _standard_library_805
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_802:
        .long 0x2ce11ed
        .long _standard_library_794
        .long _standard_library_803
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_810:
        .long 0x2ce11ed
        .long _parse_eofP_42
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_809:
        .long 0x2ce11ed
        .long _macroexpand_1_85
        .long _standard_library_810
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_818:
        .long 0x2ce11ed
        .long _parse_eofP_42
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_817:
        .long 0x2ce11ed
        .long _inline_primitive_22
        .long _standard_library_818
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_819:
        .long 0x2ce11ed
        .long _standard_library_804
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_816:
        .long 0x2ce11ed
        .long _standard_library_817
        .long _standard_library_819
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_815:
        .long 0x2ce11ed
        .long _inline_cdr_13
        .long _standard_library_816
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_822:
        .long 0x2ce11ed
        .long _parse_eofP_42
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_821:
        .long 0x2ce11ed
        .long _inline_primitive_25
        .long _standard_library_822
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_820:
        .long 0x2ce11ed
        .long _standard_library_821
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_814:
        .long 0x2ce11ed
        .long _standard_library_815
        .long _standard_library_820
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_813:
        .long 0x2ce11ed
        .long _standard_library_794
        .long _standard_library_814
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_812:
        .long 0x2ce11ed
        .long _standard_library_813
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_811:
        .long 0x2ce11ed
        .long _standard_library_804
        .long _standard_library_812
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_808:
        .long 0x2ce11ed
        .long _standard_library_809
        .long _standard_library_811
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_807:
        .long 0x2ce11ed
        .long _macroexpand_1_20
        .long _standard_library_808
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_806:
        .long 0x2ce11ed
        .long _standard_library_807
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_801:
        .long 0x2ce11ed
        .long _standard_library_802
        .long _standard_library_806
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_800:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _standard_library_801
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_828:
        .long 0x2ce11ed
        .long _standard_library_829
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_826:
        .long 0x2ce11ed
        .long _standard_library_827
        .long _standard_library_828
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_836:
        .long 0x2ce11ed
        .long _standard_library_829
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_835:
        .long 0x2ce11ed
        .long _inline_primitive_34
        .long _standard_library_836
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_839:
        .long 0x2ce11ed
        .long 2 + 256<<2
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_838:
        .long 0x2ce11ed
        .long _free_vars_20
        .long _standard_library_839
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_837:
        .long 0x2ce11ed
        .long _standard_library_838
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_834:
        .long 0x2ce11ed
        .long _standard_library_835
        .long _standard_library_837
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_833:
        .long 0x2ce11ed
        .long _standard_library_829
        .long _standard_library_834
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_831:
        .long 0x2ce11ed
        .long _standard_library_832
        .long _standard_library_833
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_830:
        .long 0x2ce11ed
        .long _standard_library_831
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_825:
        .long 0x2ce11ed
        .long _standard_library_826
        .long _standard_library_830
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_824:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _standard_library_825
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_847:
        .long 0x2ce11ed
        .long _standard_library_848
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_845:
        .long 0x2ce11ed
        .long _standard_library_846
        .long _standard_library_847
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_844:
        .long 0x2ce11ed
        .long _standard_library_829
        .long _standard_library_845
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_843:
        .long 0x2ce11ed
        .long _standard_library_832
        .long _standard_library_844
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_854:
        .long 0x2ce11ed
        .long 1 + 0<<2
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_853:
        .long 0x2ce11ed
        .long _standard_library_846
        .long _standard_library_854
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_852:
        .long 0x2ce11ed
        .long _macroexpand_1_82
        .long _standard_library_853
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_862:
        .long 0x2ce11ed
        .long 1 + 1<<2
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_861:
        .long 0x2ce11ed
        .long _standard_library_846
        .long _standard_library_862
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_860:
        .long 0x2ce11ed
        .long _inline_primitive_13
        .long _standard_library_861
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_871:
        .long 0x2ce11ed
        .long 1 + 1<<2
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_870:
        .long 0x2ce11ed
        .long _standard_library_846
        .long _standard_library_871
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_869:
        .long 0x2ce11ed
        .long _inline_primitive_13
        .long _standard_library_870
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_868:
        .long 0x2ce11ed
        .long _standard_library_869
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_867:
        .long 0x2ce11ed
        .long _standard_library_829
        .long _standard_library_868
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_866:
        .long 0x2ce11ed
        .long _check_array_bounds_30
        .long _standard_library_867
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_872:
        .long 0x2ce11ed
        .long _standard_library_848
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_865:
        .long 0x2ce11ed
        .long _standard_library_866
        .long _standard_library_872
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_864:
        .long 0x2ce11ed
        .long _inline_cdr_13
        .long _standard_library_865
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_863:
        .long 0x2ce11ed
        .long _standard_library_864
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_859:
        .long 0x2ce11ed
        .long _standard_library_860
        .long _standard_library_863
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_858:
        .long 0x2ce11ed
        .long _standard_library_829
        .long _standard_library_859
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_857:
        .long 0x2ce11ed
        .long _standard_library_832
        .long _standard_library_858
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_856:
        .long 0x2ce11ed
        .long _standard_library_857
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_855:
        .long 0x2ce11ed
        .long _standard_library_848
        .long _standard_library_856
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_851:
        .long 0x2ce11ed
        .long _standard_library_852
        .long _standard_library_855
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_850:
        .long 0x2ce11ed
        .long _macroexpand_1_20
        .long _standard_library_851
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_849:
        .long 0x2ce11ed
        .long _standard_library_850
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_842:
        .long 0x2ce11ed
        .long _standard_library_843
        .long _standard_library_849
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_841:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _standard_library_842
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_877:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_876:
        .long 0x2ce11ed
        .long _inline_primitive_28
        .long _standard_library_877
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_880:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_879:
        .long 0x2ce11ed
        .long _inline_primitive_28
        .long _standard_library_880
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_878:
        .long 0x2ce11ed
        .long _standard_library_879
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_875:
        .long 0x2ce11ed
        .long _standard_library_876
        .long _standard_library_878
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_874:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _standard_library_875
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_885:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_884:
        .long 0x2ce11ed
        .long _inline_primitive_31
        .long _standard_library_885
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_888:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_887:
        .long 0x2ce11ed
        .long _inline_primitive_31
        .long _standard_library_888
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_886:
        .long 0x2ce11ed
        .long _standard_library_887
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_883:
        .long 0x2ce11ed
        .long _standard_library_884
        .long _standard_library_886
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_882:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _standard_library_883
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_894:
        .long 0x2ce11ed
        .long _parse_eofP_42
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_892:
        .long 0x2ce11ed
        .long _standard_library_893
        .long _standard_library_894
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_902:
        .long 0x2ce11ed
        .long _parse_eofP_42
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_901:
        .long 0x2ce11ed
        .long _standard_library_65
        .long _standard_library_902
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_900:
        .long 0x2ce11ed
        .long _standard_library_901
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_899:
        .long 0x2ce11ed
        .long _extract_string_15
        .long _standard_library_900
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_904:
        .long 0x2ce11ed
        .long 1 + 0<<2
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_903:
        .long 0x2ce11ed
        .long _parse_eofP_42
        .long _standard_library_904
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_898:
        .long 0x2ce11ed
        .long _standard_library_899
        .long _standard_library_903
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_896:
        .long 0x2ce11ed
        .long _standard_library_897
        .long _standard_library_898
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_895:
        .long 0x2ce11ed
        .long _standard_library_896
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_891:
        .long 0x2ce11ed
        .long _standard_library_892
        .long _standard_library_895
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_890:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _standard_library_891
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_911:
        .long 0x2ce11ed
        .long _standard_library_668
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_910:
        .long 0x2ce11ed
        .long _parse_eofP_42
        .long _standard_library_911
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_909:
        .long 0x2ce11ed
        .long _standard_library_379
        .long _standard_library_910
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_908:
        .long 0x2ce11ed
        .long _standard_library_897
        .long _standard_library_909
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_916:
        .long 0x2ce11ed
        .long _parse_eofP_42
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_915:
        .long 0x2ce11ed
        .long _macroexpand_1_85
        .long _standard_library_916
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_926:
        .long 0x2ce11ed
        .long _parse_eofP_42
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_925:
        .long 0x2ce11ed
        .long _inline_primitive_22
        .long _standard_library_926
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_924:
        .long 0x2ce11ed
        .long _standard_library_925
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_923:
        .long 0x2ce11ed
        .long _standard_library_668
        .long _standard_library_924
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_922:
        .long 0x2ce11ed
        .long _standard_library_379
        .long _standard_library_923
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_921:
        .long 0x2ce11ed
        .long _check_array_bounds_23
        .long _standard_library_922
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_932:
        .long 0x2ce11ed
        .long _parse_eofP_42
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_931:
        .long 0x2ce11ed
        .long _inline_primitive_25
        .long _standard_library_932
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_935:
        .long 0x2ce11ed
        .long _standard_library_668
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_934:
        .long 0x2ce11ed
        .long _inline_primitive_16
        .long _standard_library_935
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_933:
        .long 0x2ce11ed
        .long _standard_library_934
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_930:
        .long 0x2ce11ed
        .long _standard_library_931
        .long _standard_library_933
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_929:
        .long 0x2ce11ed
        .long _standard_library_379
        .long _standard_library_930
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_928:
        .long 0x2ce11ed
        .long _standard_library_897
        .long _standard_library_929
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_927:
        .long 0x2ce11ed
        .long _standard_library_928
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_920:
        .long 0x2ce11ed
        .long _standard_library_921
        .long _standard_library_927
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_919:
        .long 0x2ce11ed
        .long _macroexpand_1_10
        .long _standard_library_920
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_918:
        .long 0x2ce11ed
        .long _standard_library_919
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_917:
        .long 0x2ce11ed
        .long _standard_library_379
        .long _standard_library_918
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_914:
        .long 0x2ce11ed
        .long _standard_library_915
        .long _standard_library_917
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_913:
        .long 0x2ce11ed
        .long _macroexpand_1_20
        .long _standard_library_914
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_912:
        .long 0x2ce11ed
        .long _standard_library_913
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_907:
        .long 0x2ce11ed
        .long _standard_library_908
        .long _standard_library_912
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_906:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _standard_library_907
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_940:
        .long 0x2ce11ed
        .long _standard_library_549
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_939:
        .long 0x2ce11ed
        .long _parse_eofP_54
        .long _standard_library_940
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_948:
        .long 0x2ce11ed
        .long 1 + 1<<2
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_947:
        .long 0x2ce11ed
        .long _extract_string_15
        .long _standard_library_948
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_946:
        .long 0x2ce11ed
        .long _standard_library_947
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_945:
        .long 0x2ce11ed
        .long _standard_library_379
        .long _standard_library_946
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_944:
        .long 0x2ce11ed
        .long _standard_library_945
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_953:
        .long 0x2ce11ed
        .long _standard_library_549
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_952:
        .long 0x2ce11ed
        .long 1 + 0<<2
        .long _standard_library_953
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_951:
        .long 0x2ce11ed
        .long _standard_library_379
        .long _standard_library_952
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_950:
        .long 0x2ce11ed
        .long _check_array_bounds_23
        .long _standard_library_951
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_954:
        .long 0x2ce11ed
        .long _standard_library_379
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_949:
        .long 0x2ce11ed
        .long _standard_library_950
        .long _standard_library_954
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_943:
        .long 0x2ce11ed
        .long _standard_library_944
        .long _standard_library_949
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_942:
        .long 0x2ce11ed
        .long _macroexpand_1_31
        .long _standard_library_943
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_941:
        .long 0x2ce11ed
        .long _standard_library_942
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_938:
        .long 0x2ce11ed
        .long _standard_library_939
        .long _standard_library_941
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_937:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _standard_library_938
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_960:
        .long 0x2ce11ed
        .long _parse_eofP_60
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_958:
        .long 0x2ce11ed
        .long _standard_library_959
        .long _standard_library_960
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_966:
        .long 0xbabb1e
        .long 10
        .ascii "0123456789"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_967:
        .long 0x2ce11ed
        .long _parse_eofP_60
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_965:
        .long 0x2ce11ed
        .long _standard_library_966
        .long _standard_library_967
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_964:
        .long 0x2ce11ed
        .long _check_array_bounds_30
        .long _standard_library_965
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_963:
        .long 0x2ce11ed
        .long _standard_library_964
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_962:
        .long 0x2ce11ed
        .long _parse_eofP_54
        .long _standard_library_963
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_961:
        .long 0x2ce11ed
        .long _standard_library_962
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_957:
        .long 0x2ce11ed
        .long _standard_library_958
        .long _standard_library_961
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_956:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _standard_library_957
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_973:
        .long 0x2ce11ed
        .long _standard_library_974
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_971:
        .long 0x2ce11ed
        .long _standard_library_972
        .long _standard_library_973
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_980:
        .long 0x2ce11ed
        .long 1 + 10<<2
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_979:
        .long 0x2ce11ed
        .long _standard_library_974
        .long _standard_library_980
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_978:
        .long 0x2ce11ed
        .long _emit_division_code_24
        .long _standard_library_979
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_983:
        .long 0x2ce11ed
        .long _standard_library_974
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_982:
        .long 0x2ce11ed
        .long _standard_library_959
        .long _standard_library_983
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_991:
        .long 0x2ce11ed
        .long 1 + 10<<2
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_990:
        .long 0x2ce11ed
        .long _standard_library_974
        .long _standard_library_991
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_989:
        .long 0x2ce11ed
        .long _emit_division_code_17
        .long _standard_library_990
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_988:
        .long 0x2ce11ed
        .long _standard_library_989
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_987:
        .long 0x2ce11ed
        .long _standard_library_972
        .long _standard_library_988
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_997:
        .long 0x2ce11ed
        .long 1 + 10<<2
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_996:
        .long 0x2ce11ed
        .long _standard_library_974
        .long _standard_library_997
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_995:
        .long 0x2ce11ed
        .long _emit_division_code_13
        .long _standard_library_996
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_994:
        .long 0x2ce11ed
        .long _standard_library_995
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_993:
        .long 0x2ce11ed
        .long _standard_library_959
        .long _standard_library_994
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_992:
        .long 0x2ce11ed
        .long _standard_library_993
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_986:
        .long 0x2ce11ed
        .long _standard_library_987
        .long _standard_library_992
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_985:
        .long 0x2ce11ed
        .long _standard_library_369
        .long _standard_library_986
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_984:
        .long 0x2ce11ed
        .long _standard_library_985
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_981:
        .long 0x2ce11ed
        .long _standard_library_982
        .long _standard_library_984
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_977:
        .long 0x2ce11ed
        .long _standard_library_978
        .long _standard_library_981
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_976:
        .long 0x2ce11ed
        .long _macroexpand_1_20
        .long _standard_library_977
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_975:
        .long 0x2ce11ed
        .long _standard_library_976
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_970:
        .long 0x2ce11ed
        .long _standard_library_971
        .long _standard_library_975
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_969:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _standard_library_970
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1003:
        .long 0x2ce11ed
        .long _standard_library_974
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1001:
        .long 0x2ce11ed
        .long _standard_library_1002
        .long _standard_library_1003
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1009:
        .long 0x2ce11ed
        .long 1 + 0<<2
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1008:
        .long 0x2ce11ed
        .long _standard_library_974
        .long _standard_library_1009
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1007:
        .long 0x2ce11ed
        .long _emit_division_code_24
        .long _standard_library_1008
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1013:
        .long 0xbabb1e
        .long 1
        .ascii "-"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1019:
        .long 0x2ce11ed
        .long _standard_library_974
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1018:
        .long 0x2ce11ed
        .long 1 + 0<<2
        .long _standard_library_1019
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1017:
        .long 0x2ce11ed
        .long _inline_primitive_13
        .long _standard_library_1018
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1016:
        .long 0x2ce11ed
        .long _standard_library_1017
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1015:
        .long 0x2ce11ed
        .long _standard_library_972
        .long _standard_library_1016
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1014:
        .long 0x2ce11ed
        .long _standard_library_1015
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1012:
        .long 0x2ce11ed
        .long _standard_library_1013
        .long _standard_library_1014
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1011:
        .long 0x2ce11ed
        .long _standard_library_369
        .long _standard_library_1012
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1022:
        .long 0x2ce11ed
        .long _standard_library_974
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1021:
        .long 0x2ce11ed
        .long _standard_library_972
        .long _standard_library_1022
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1020:
        .long 0x2ce11ed
        .long _standard_library_1021
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1010:
        .long 0x2ce11ed
        .long _standard_library_1011
        .long _standard_library_1020
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1006:
        .long 0x2ce11ed
        .long _standard_library_1007
        .long _standard_library_1010
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1005:
        .long 0x2ce11ed
        .long _macroexpand_1_20
        .long _standard_library_1006
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1004:
        .long 0x2ce11ed
        .long _standard_library_1005
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1000:
        .long 0x2ce11ed
        .long _standard_library_1001
        .long _standard_library_1004
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_999:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _standard_library_1000
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1028:
        .long 0x2ce11ed
        .long _standard_library_1029
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1026:
        .long 0x2ce11ed
        .long _standard_library_1027
        .long _standard_library_1028
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1036:
        .long 0x2ce11ed
        .long _standard_library_1029
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1035:
        .long 0x2ce11ed
        .long _inline_primitive_34
        .long _standard_library_1036
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1037:
        .long 0x2ce11ed
        .long 1 + 0<<2
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1034:
        .long 0x2ce11ed
        .long _standard_library_1035
        .long _standard_library_1037
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1033:
        .long 0x2ce11ed
        .long _macroexpand_1_82
        .long _standard_library_1034
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1042:
        .long 0xbabb1e
        .long 30
        .ascii "string->number of empty string"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1041:
        .long 0x2ce11ed
        .long _standard_library_1042
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1039:
        .long 0x2ce11ed
        .long _standard_library_1040
        .long _standard_library_1041
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1048:
        .long 0x2ce11ed
        .long 1 + 0<<2
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1047:
        .long 0x2ce11ed
        .long _standard_library_1029
        .long _standard_library_1048
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1046:
        .long 0x2ce11ed
        .long _check_array_bounds_30
        .long _standard_library_1047
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1051:
        .long 0x2ce11ed
        .long 2 + 43<<2
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1057:
        .long 0x2ce11ed
        .long 1 + 0<<2
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1056:
        .long 0x2ce11ed
        .long 1 + 1<<2
        .long _standard_library_1057
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1055:
        .long 0x2ce11ed
        .long _standard_library_1029
        .long _standard_library_1056
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1053:
        .long 0x2ce11ed
        .long _standard_library_1054
        .long _standard_library_1055
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1052:
        .long 0x2ce11ed
        .long _standard_library_1053
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1050:
        .long 0x2ce11ed
        .long _standard_library_1051
        .long _standard_library_1052
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1060:
        .long 0x2ce11ed
        .long 2 + 45<<2
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1068:
        .long 0x2ce11ed
        .long 1 + 0<<2
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1067:
        .long 0x2ce11ed
        .long 1 + 1<<2
        .long _standard_library_1068
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1066:
        .long 0x2ce11ed
        .long _standard_library_1029
        .long _standard_library_1067
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1065:
        .long 0x2ce11ed
        .long _standard_library_1054
        .long _standard_library_1066
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1064:
        .long 0x2ce11ed
        .long _standard_library_1065
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1063:
        .long 0x2ce11ed
        .long 1 + 0<<2
        .long _standard_library_1064
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1062:
        .long 0x2ce11ed
        .long _inline_primitive_13
        .long _standard_library_1063
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1061:
        .long 0x2ce11ed
        .long _standard_library_1062
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1059:
        .long 0x2ce11ed
        .long _standard_library_1060
        .long _standard_library_1061
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1075:
        .long 0x2ce11ed
        .long 1 + 0<<2
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1074:
        .long 0x2ce11ed
        .long 1 + 0<<2
        .long _standard_library_1075
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1073:
        .long 0x2ce11ed
        .long _standard_library_1029
        .long _standard_library_1074
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1072:
        .long 0x2ce11ed
        .long _standard_library_1054
        .long _standard_library_1073
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1071:
        .long 0x2ce11ed
        .long _standard_library_1072
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1070:
        .long 0x2ce11ed
        .long _macroexpand_1_18
        .long _standard_library_1071
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1069:
        .long 0x2ce11ed
        .long _standard_library_1070
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1058:
        .long 0x2ce11ed
        .long _standard_library_1059
        .long _standard_library_1069
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1049:
        .long 0x2ce11ed
        .long _standard_library_1050
        .long _standard_library_1058
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1045:
        .long 0x2ce11ed
        .long _standard_library_1046
        .long _standard_library_1049
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1044:
        .long 0x2ce11ed
        .long _macroexpand_1_41
        .long _standard_library_1045
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1043:
        .long 0x2ce11ed
        .long _standard_library_1044
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1038:
        .long 0x2ce11ed
        .long _standard_library_1039
        .long _standard_library_1043
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1032:
        .long 0x2ce11ed
        .long _standard_library_1033
        .long _standard_library_1038
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1031:
        .long 0x2ce11ed
        .long _macroexpand_1_20
        .long _standard_library_1032
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1030:
        .long 0x2ce11ed
        .long _standard_library_1031
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1025:
        .long 0x2ce11ed
        .long _standard_library_1026
        .long _standard_library_1030
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1024:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _standard_library_1025
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1082:
        .long 0x2ce11ed
        .long _standard_library_1083
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1081:
        .long 0x2ce11ed
        .long _standard_library_668
        .long _standard_library_1082
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1080:
        .long 0x2ce11ed
        .long _standard_library_1029
        .long _standard_library_1081
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1079:
        .long 0x2ce11ed
        .long _standard_library_1054
        .long _standard_library_1080
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1091:
        .long 0x2ce11ed
        .long _standard_library_1029
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1090:
        .long 0x2ce11ed
        .long _inline_primitive_34
        .long _standard_library_1091
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1089:
        .long 0x2ce11ed
        .long _standard_library_1090
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1088:
        .long 0x2ce11ed
        .long _standard_library_668
        .long _standard_library_1089
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1087:
        .long 0x2ce11ed
        .long _macroexpand_1_82
        .long _standard_library_1088
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1101:
        .long 0x2ce11ed
        .long _standard_library_668
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1100:
        .long 0x2ce11ed
        .long _standard_library_1029
        .long _standard_library_1101
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1099:
        .long 0x2ce11ed
        .long _check_array_bounds_30
        .long _standard_library_1100
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1098:
        .long 0x2ce11ed
        .long _standard_library_1099
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1097:
        .long 0x2ce11ed
        .long _sample_abcd_4
        .long _standard_library_1098
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1096:
        .long 0x2ce11ed
        .long _standard_library_1097
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1110:
        .long 0x2ce11ed
        .long 2 + 57<<2
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1109:
        .long 0x2ce11ed
        .long _sample_abcd_4
        .long _standard_library_1110
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1108:
        .long 0x2ce11ed
        .long 2 + 48<<2
        .long _standard_library_1109
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1107:
        .long 0x2ce11ed
        .long _standard_library_511
        .long _standard_library_1108
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1106:
        .long 0x2ce11ed
        .long _standard_library_1107
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1105:
        .long 0x2ce11ed
        .long _macroexpand_1_88
        .long _standard_library_1106
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1114:
        .long 0xbabb1e
        .long 16
        .ascii "non-numeric char"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1116:
        .long 0x2ce11ed
        .long _standard_library_1029
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1115:
        .long 0x2ce11ed
        .long _sample_abcd_4
        .long _standard_library_1116
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1113:
        .long 0x2ce11ed
        .long _standard_library_1114
        .long _standard_library_1115
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1112:
        .long 0x2ce11ed
        .long _standard_library_1040
        .long _standard_library_1113
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1122:
        .long 0x2ce11ed
        .long _standard_library_668
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1121:
        .long 0x2ce11ed
        .long _inline_primitive_16
        .long _standard_library_1122
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1128:
        .long 0x2ce11ed
        .long _standard_library_1083
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1126:
        .long 0x2ce11ed
        .long _standard_library_1127
        .long _standard_library_1128
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1133:
        .long 0x2ce11ed
        .long _sample_abcd_4
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1132:
        .long 0x2ce11ed
        .long _inline_primitive_31
        .long _standard_library_1133
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1136:
        .long 0x2ce11ed
        .long 2 + 48<<2
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1135:
        .long 0x2ce11ed
        .long _inline_primitive_31
        .long _standard_library_1136
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1134:
        .long 0x2ce11ed
        .long _standard_library_1135
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1131:
        .long 0x2ce11ed
        .long _standard_library_1132
        .long _standard_library_1134
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1130:
        .long 0x2ce11ed
        .long _inline_primitive_13
        .long _standard_library_1131
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1129:
        .long 0x2ce11ed
        .long _standard_library_1130
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1125:
        .long 0x2ce11ed
        .long _standard_library_1126
        .long _standard_library_1129
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1124:
        .long 0x2ce11ed
        .long _inline_primitive_10
        .long _standard_library_1125
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1123:
        .long 0x2ce11ed
        .long _standard_library_1124
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1120:
        .long 0x2ce11ed
        .long _standard_library_1121
        .long _standard_library_1123
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1119:
        .long 0x2ce11ed
        .long _standard_library_1029
        .long _standard_library_1120
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1118:
        .long 0x2ce11ed
        .long _standard_library_1054
        .long _standard_library_1119
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1117:
        .long 0x2ce11ed
        .long _standard_library_1118
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1111:
        .long 0x2ce11ed
        .long _standard_library_1112
        .long _standard_library_1117
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1104:
        .long 0x2ce11ed
        .long _standard_library_1105
        .long _standard_library_1111
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1103:
        .long 0x2ce11ed
        .long _macroexpand_1_20
        .long _standard_library_1104
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1102:
        .long 0x2ce11ed
        .long _standard_library_1103
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1095:
        .long 0x2ce11ed
        .long _standard_library_1096
        .long _standard_library_1102
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1094:
        .long 0x2ce11ed
        .long _macroexpand_1_31
        .long _standard_library_1095
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1093:
        .long 0x2ce11ed
        .long _standard_library_1094
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1092:
        .long 0x2ce11ed
        .long _standard_library_1083
        .long _standard_library_1093
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1086:
        .long 0x2ce11ed
        .long _standard_library_1087
        .long _standard_library_1092
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1085:
        .long 0x2ce11ed
        .long _macroexpand_1_20
        .long _standard_library_1086
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1084:
        .long 0x2ce11ed
        .long _standard_library_1085
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1078:
        .long 0x2ce11ed
        .long _standard_library_1079
        .long _standard_library_1084
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1077:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _standard_library_1078
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1141:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1140:
        .long 0x2ce11ed
        .long _standard_library_1127
        .long _standard_library_1141
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1147:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1145:
        .long 0x2ce11ed
        .long _standard_library_1146
        .long _standard_library_1147
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1151:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1149:
        .long 0x2ce11ed
        .long _standard_library_1150
        .long _standard_library_1151
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1148:
        .long 0x2ce11ed
        .long _standard_library_1149
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1144:
        .long 0x2ce11ed
        .long _standard_library_1145
        .long _standard_library_1148
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1143:
        .long 0x2ce11ed
        .long _inline_primitive_10
        .long _standard_library_1144
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1142:
        .long 0x2ce11ed
        .long _standard_library_1143
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1139:
        .long 0x2ce11ed
        .long _standard_library_1140
        .long _standard_library_1142
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1138:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _standard_library_1139
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1156:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1155:
        .long 0x2ce11ed
        .long _standard_library_1150
        .long _standard_library_1156
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1160:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1159:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long _standard_library_1160
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1158:
        .long 0x2ce11ed
        .long _inline_primitive_10
        .long _standard_library_1159
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1157:
        .long 0x2ce11ed
        .long _standard_library_1158
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1154:
        .long 0x2ce11ed
        .long _standard_library_1155
        .long _standard_library_1157
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1153:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _standard_library_1154
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1165:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1164:
        .long 0x2ce11ed
        .long _standard_library_1146
        .long _standard_library_1165
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1172:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1171:
        .long 0x2ce11ed
        .long _standard_library_1150
        .long _standard_library_1172
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1170:
        .long 0x2ce11ed
        .long _standard_library_1171
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1169:
        .long 0x2ce11ed
        .long _standard_library_1150
        .long _standard_library_1170
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1168:
        .long 0x2ce11ed
        .long _standard_library_1169
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1167:
        .long 0x2ce11ed
        .long _standard_library_1150
        .long _standard_library_1168
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1166:
        .long 0x2ce11ed
        .long _standard_library_1167
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1163:
        .long 0x2ce11ed
        .long _standard_library_1164
        .long _standard_library_1166
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1162:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _standard_library_1163
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1176:
        .long 0x2ce11ed
        .long _heap_args_22
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1180:
        .long 0xbabb1e
        .long 1
        .ascii "\n"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1179:
        .long 0x2ce11ed
        .long _standard_library_1180
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1178:
        .long 0x2ce11ed
        .long _heap_args_14
        .long _standard_library_1179
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1177:
        .long 0x2ce11ed
        .long _standard_library_1178
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1175:
        .long 0x2ce11ed
        .long _standard_library_1176
        .long _standard_library_1177
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1174:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _standard_library_1175
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1184:
        .long 0x2ce11ed
        .long _standard_library_1040
        .long _standard_library_59
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1188:
        .long 0xbabb1e
        .long 7
        .ascii "error: "
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1187:
        .long 0x2ce11ed
        .long _standard_library_1188
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1186:
        .long 0x2ce11ed
        .long _write_2_64
        .long _standard_library_1187
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1194:
        .long 0x2ce11ed
        .long _standard_library_1195
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1200:
        .long 0x2ce11ed
        .long _write_2_64
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1199:
        .long 0x2ce11ed
        .long _standard_library_1195
        .long _standard_library_1200
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1197:
        .long 0x2ce11ed
        .long _standard_library_1198
        .long _standard_library_1199
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1204:
        .long 0xbabb1e
        .long 1
        .ascii " "
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1203:
        .long 0x2ce11ed
        .long _standard_library_1204
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1202:
        .long 0x2ce11ed
        .long _write_2_64
        .long _standard_library_1203
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1201:
        .long 0x2ce11ed
        .long _standard_library_1202
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1196:
        .long 0x2ce11ed
        .long _standard_library_1197
        .long _standard_library_1201
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1193:
        .long 0x2ce11ed
        .long _standard_library_1194
        .long _standard_library_1196
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1192:
        .long 0x2ce11ed
        .long _lambdas_8
        .long _standard_library_1193
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1205:
        .long 0x2ce11ed
        .long _standard_library_59
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1191:
        .long 0x2ce11ed
        .long _standard_library_1192
        .long _standard_library_1205
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1190:
        .long 0x2ce11ed
        .long _standard_library_734
        .long _standard_library_1191
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1209:
        .long 0xbabb1e
        .long 1
        .ascii "\n"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1208:
        .long 0x2ce11ed
        .long _standard_library_1209
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1207:
        .long 0x2ce11ed
        .long _write_2_64
        .long _standard_library_1208
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1212:
        .long 0x2ce11ed
        .long 1 + 1<<2
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1211:
        .long 0x2ce11ed
        .long _write_2_69
        .long _standard_library_1212
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1210:
        .long 0x2ce11ed
        .long _standard_library_1211
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1206:
        .long 0x2ce11ed
        .long _standard_library_1207
        .long _standard_library_1210
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1189:
        .long 0x2ce11ed
        .long _standard_library_1190
        .long _standard_library_1206
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1185:
        .long 0x2ce11ed
        .long _standard_library_1186
        .long _standard_library_1189
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1183:
        .long 0x2ce11ed
        .long _standard_library_1184
        .long _standard_library_1185
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1182:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _standard_library_1183
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1221:
        .long 0x2ce11ed
        .long _standard_library_1222
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1219:
        .long 0x2ce11ed
        .long _standard_library_1220
        .long _standard_library_1221
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1218:
        .long 0x2ce11ed
        .long _standard_library_549
        .long _standard_library_1219
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1216:
        .long 0x2ce11ed
        .long _standard_library_1217
        .long _standard_library_1218
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1228:
        .long 0x2ce11ed
        .long _standard_library_1220
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1227:
        .long 0x2ce11ed
        .long _macroexpand_1_85
        .long _standard_library_1228
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1231:
        .long 0x2ce11ed
        .long _standard_library_549
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1230:
        .long 0x2ce11ed
        .long _parse_eofP_54
        .long _standard_library_1231
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1229:
        .long 0x2ce11ed
        .long _standard_library_1230
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1226:
        .long 0x2ce11ed
        .long _standard_library_1227
        .long _standard_library_1229
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1240:
        .long 0x2ce11ed
        .long _standard_library_1220
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1239:
        .long 0x2ce11ed
        .long _inline_primitive_22
        .long _standard_library_1240
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1241:
        .long 0x2ce11ed
        .long 1 + 0<<2
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1238:
        .long 0x2ce11ed
        .long _standard_library_1239
        .long _standard_library_1241
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1237:
        .long 0x2ce11ed
        .long _check_array_bounds_30
        .long _standard_library_1238
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1236:
        .long 0x2ce11ed
        .long _standard_library_1237
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1235:
        .long 0x2ce11ed
        .long _standard_library_549
        .long _standard_library_1236
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1234:
        .long 0x2ce11ed
        .long _standard_library_576
        .long _standard_library_1235
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1244:
        .long 0x2ce11ed
        .long _standard_library_1222
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1243:
        .long 0x2ce11ed
        .long _inline_primitive_22
        .long _standard_library_1244
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1242:
        .long 0x2ce11ed
        .long _standard_library_1243
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1233:
        .long 0x2ce11ed
        .long _standard_library_1234
        .long _standard_library_1242
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1252:
        .long 0x2ce11ed
        .long _standard_library_1220
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1251:
        .long 0x2ce11ed
        .long _inline_primitive_25
        .long _standard_library_1252
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1255:
        .long 0x2ce11ed
        .long _standard_library_1222
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1254:
        .long 0x2ce11ed
        .long _inline_primitive_25
        .long _standard_library_1255
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1253:
        .long 0x2ce11ed
        .long _standard_library_1254
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1250:
        .long 0x2ce11ed
        .long _standard_library_1251
        .long _standard_library_1253
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1249:
        .long 0x2ce11ed
        .long _standard_library_549
        .long _standard_library_1250
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1248:
        .long 0x2ce11ed
        .long _standard_library_1217
        .long _standard_library_1249
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1247:
        .long 0x2ce11ed
        .long _standard_library_1248
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1246:
        .long 0x2ce11ed
        .long _macroexpand_1_18
        .long _standard_library_1247
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1245:
        .long 0x2ce11ed
        .long _standard_library_1246
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1232:
        .long 0x2ce11ed
        .long _standard_library_1233
        .long _standard_library_1245
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1225:
        .long 0x2ce11ed
        .long _standard_library_1226
        .long _standard_library_1232
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1224:
        .long 0x2ce11ed
        .long _macroexpand_1_19
        .long _standard_library_1225
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1223:
        .long 0x2ce11ed
        .long _standard_library_1224
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1215:
        .long 0x2ce11ed
        .long _standard_library_1216
        .long _standard_library_1223
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1214:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _standard_library_1215
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1264:
        .long 0x2ce11ed
        .long _standard_library_1222
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1263:
        .long 0x2ce11ed
        .long _standard_library_1220
        .long _standard_library_1264
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1262:
        .long 0x2ce11ed
        .long _standard_library_668
        .long _standard_library_1263
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1261:
        .long 0x2ce11ed
        .long _standard_library_829
        .long _standard_library_1262
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1259:
        .long 0x2ce11ed
        .long _standard_library_1260
        .long _standard_library_1261
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1272:
        .long 0x2ce11ed
        .long _standard_library_829
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1271:
        .long 0x2ce11ed
        .long _inline_primitive_34
        .long _standard_library_1272
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1270:
        .long 0x2ce11ed
        .long _standard_library_1271
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1269:
        .long 0x2ce11ed
        .long _standard_library_668
        .long _standard_library_1270
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1268:
        .long 0x2ce11ed
        .long _macroexpand_1_82
        .long _standard_library_1269
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1275:
        .long 0x2ce11ed
        .long 2 + 256<<2
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1274:
        .long 0x2ce11ed
        .long _free_vars_20
        .long _standard_library_1275
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1283:
        .long 0x2ce11ed
        .long _standard_library_668
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1282:
        .long 0x2ce11ed
        .long _standard_library_829
        .long _standard_library_1283
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1281:
        .long 0x2ce11ed
        .long _check_array_bounds_30
        .long _standard_library_1282
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1285:
        .long 0x2ce11ed
        .long _standard_library_1222
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1284:
        .long 0x2ce11ed
        .long _standard_library_1220
        .long _standard_library_1285
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1280:
        .long 0x2ce11ed
        .long _standard_library_1281
        .long _standard_library_1284
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1279:
        .long 0x2ce11ed
        .long _standard_library_1217
        .long _standard_library_1280
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1291:
        .long 0x2ce11ed
        .long _standard_library_668
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1290:
        .long 0x2ce11ed
        .long _inline_primitive_16
        .long _standard_library_1291
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1293:
        .long 0x2ce11ed
        .long _standard_library_1222
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1292:
        .long 0x2ce11ed
        .long _standard_library_1220
        .long _standard_library_1293
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1289:
        .long 0x2ce11ed
        .long _standard_library_1290
        .long _standard_library_1292
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1288:
        .long 0x2ce11ed
        .long _standard_library_829
        .long _standard_library_1289
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1287:
        .long 0x2ce11ed
        .long _standard_library_1260
        .long _standard_library_1288
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1286:
        .long 0x2ce11ed
        .long _standard_library_1287
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1278:
        .long 0x2ce11ed
        .long _standard_library_1279
        .long _standard_library_1286
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1277:
        .long 0x2ce11ed
        .long _inline_cdr_13
        .long _standard_library_1278
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1276:
        .long 0x2ce11ed
        .long _standard_library_1277
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1273:
        .long 0x2ce11ed
        .long _standard_library_1274
        .long _standard_library_1276
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1267:
        .long 0x2ce11ed
        .long _standard_library_1268
        .long _standard_library_1273
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1266:
        .long 0x2ce11ed
        .long _macroexpand_1_20
        .long _standard_library_1267
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1265:
        .long 0x2ce11ed
        .long _standard_library_1266
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1258:
        .long 0x2ce11ed
        .long _standard_library_1259
        .long _standard_library_1265
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1257:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _standard_library_1258
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1299:
        .long 0x2ce11ed
        .long _standard_library_829
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1297:
        .long 0x2ce11ed
        .long _standard_library_1298
        .long _standard_library_1299
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1308:
        .long 0xbabb1e
        .long 1
        .ascii "\\"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1310:
        .long 0xbabb1e
        .long 1
        .ascii "\n"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1312:
        .long 0xbabb1e
        .long 1
        .ascii "\""
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1311:
        .long 0x2ce11ed
        .long _standard_library_1312
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1309:
        .long 0x2ce11ed
        .long _standard_library_1310
        .long _standard_library_1311
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1307:
        .long 0x2ce11ed
        .long _standard_library_1308
        .long _standard_library_1309
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1306:
        .long 0x2ce11ed
        .long _standard_library_1307
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1305:
        .long 0x2ce11ed
        .long _free_vars_20
        .long _standard_library_1306
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1317:
        .long 0xbabb1e
        .long 2
        .ascii "\\\\"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1319:
        .long 0xbabb1e
        .long 2
        .ascii "\\n"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1321:
        .long 0xbabb1e
        .long 2
        .ascii "\\\""
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1320:
        .long 0x2ce11ed
        .long _standard_library_1321
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1318:
        .long 0x2ce11ed
        .long _standard_library_1319
        .long _standard_library_1320
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1316:
        .long 0x2ce11ed
        .long _standard_library_1317
        .long _standard_library_1318
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1315:
        .long 0x2ce11ed
        .long _standard_library_1316
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1314:
        .long 0x2ce11ed
        .long _free_vars_20
        .long _standard_library_1315
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1313:
        .long 0x2ce11ed
        .long _standard_library_1314
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1304:
        .long 0x2ce11ed
        .long _standard_library_1305
        .long _standard_library_1313
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1303:
        .long 0x2ce11ed
        .long 1 + 0<<2
        .long _standard_library_1304
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1302:
        .long 0x2ce11ed
        .long _standard_library_829
        .long _standard_library_1303
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1301:
        .long 0x2ce11ed
        .long _standard_library_1260
        .long _standard_library_1302
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1300:
        .long 0x2ce11ed
        .long _standard_library_1301
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1296:
        .long 0x2ce11ed
        .long _standard_library_1297
        .long _standard_library_1300
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1295:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _standard_library_1296
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1327:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1325:
        .long 0x2ce11ed
        .long _standard_library_1326
        .long _standard_library_1327
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1331:
        .long 0x2ce11ed
        .long _heap_args_14
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1330:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long _standard_library_1331
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1329:
        .long 0x2ce11ed
        .long _standard_library_1198
        .long _standard_library_1330
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1328:
        .long 0x2ce11ed
        .long _standard_library_1329
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1324:
        .long 0x2ce11ed
        .long _standard_library_1325
        .long _standard_library_1328
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1323:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _standard_library_1324
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1337:
        .long 0x2ce11ed
        .long _heap_args_14
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1336:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long _standard_library_1337
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1335:
        .long 0x2ce11ed
        .long _standard_library_1198
        .long _standard_library_1336
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1343:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1342:
        .long 0x2ce11ed
        .long _string_magic_3
        .long _standard_library_1343
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1348:
        .long 0x2ce11ed
        .long _heap_args_14
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1347:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long _standard_library_1348
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1345:
        .long 0x2ce11ed
        .long _standard_library_1346
        .long _standard_library_1347
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1344:
        .long 0x2ce11ed
        .long _standard_library_1345
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1341:
        .long 0x2ce11ed
        .long _standard_library_1342
        .long _standard_library_1344
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1354:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1353:
        .long 0x2ce11ed
        .long _cons_magic_3
        .long _standard_library_1354
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1357:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1356:
        .long 0x2ce11ed
        .long _macroexpand_1_85
        .long _standard_library_1357
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1355:
        .long 0x2ce11ed
        .long _standard_library_1356
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1352:
        .long 0x2ce11ed
        .long _standard_library_1353
        .long _standard_library_1355
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1351:
        .long 0x2ce11ed
        .long _macroexpand_1_54
        .long _standard_library_1352
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1361:
        .long 0xbabb1e
        .long 1
        .ascii "("
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1360:
        .long 0x2ce11ed
        .long _standard_library_1361
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1359:
        .long 0x2ce11ed
        .long _heap_args_14
        .long _standard_library_1360
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1366:
        .long 0x2ce11ed
        .long _heap_args_14
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1365:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long _standard_library_1366
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1363:
        .long 0x2ce11ed
        .long _standard_library_1364
        .long _standard_library_1365
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1362:
        .long 0x2ce11ed
        .long _standard_library_1363
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1358:
        .long 0x2ce11ed
        .long _standard_library_1359
        .long _standard_library_1362
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1350:
        .long 0x2ce11ed
        .long _standard_library_1351
        .long _standard_library_1358
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1370:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1369:
        .long 0x2ce11ed
        .long _symbol_magic_3
        .long _standard_library_1370
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1375:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1374:
        .long 0x2ce11ed
        .long _inline_primitive_37
        .long _standard_library_1375
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1373:
        .long 0x2ce11ed
        .long _standard_library_1374
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1372:
        .long 0x2ce11ed
        .long _heap_args_14
        .long _standard_library_1373
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1371:
        .long 0x2ce11ed
        .long _standard_library_1372
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1368:
        .long 0x2ce11ed
        .long _standard_library_1369
        .long _standard_library_1371
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1379:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1378:
        .long 0x2ce11ed
        .long _standard_library_728
        .long _standard_library_1379
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1384:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1383:
        .long 0x2ce11ed
        .long _standard_library_1002
        .long _standard_library_1384
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1382:
        .long 0x2ce11ed
        .long _standard_library_1383
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1381:
        .long 0x2ce11ed
        .long _heap_args_14
        .long _standard_library_1382
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1380:
        .long 0x2ce11ed
        .long _standard_library_1381
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1377:
        .long 0x2ce11ed
        .long _standard_library_1378
        .long _standard_library_1380
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1389:
        .long 0x2ce11ed
        .long 2 + 257<<2
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1388:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long _standard_library_1389
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1387:
        .long 0x2ce11ed
        .long _macroexpand_1_79
        .long _standard_library_1388
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1393:
        .long 0xbabb1e
        .long 2
        .ascii "#t"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1392:
        .long 0x2ce11ed
        .long _standard_library_1393
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1391:
        .long 0x2ce11ed
        .long _heap_args_14
        .long _standard_library_1392
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1390:
        .long 0x2ce11ed
        .long _standard_library_1391
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1386:
        .long 0x2ce11ed
        .long _standard_library_1387
        .long _standard_library_1390
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1398:
        .long 0x2ce11ed
        .long 2 + 258<<2
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1397:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long _standard_library_1398
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1396:
        .long 0x2ce11ed
        .long _macroexpand_1_79
        .long _standard_library_1397
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1402:
        .long 0xbabb1e
        .long 2
        .ascii "#f"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1401:
        .long 0x2ce11ed
        .long _standard_library_1402
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1400:
        .long 0x2ce11ed
        .long _heap_args_14
        .long _standard_library_1401
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1399:
        .long 0x2ce11ed
        .long _standard_library_1400
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1395:
        .long 0x2ce11ed
        .long _standard_library_1396
        .long _standard_library_1399
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1407:
        .long 0x2ce11ed
        .long 2 + 10<<2
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1406:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long _standard_library_1407
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1405:
        .long 0x2ce11ed
        .long _macroexpand_1_79
        .long _standard_library_1406
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1411:
        .long 0xbabb1e
        .long 9
        .ascii "#\\newline"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1410:
        .long 0x2ce11ed
        .long _standard_library_1411
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1409:
        .long 0x2ce11ed
        .long _heap_args_14
        .long _standard_library_1410
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1408:
        .long 0x2ce11ed
        .long _standard_library_1409
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1404:
        .long 0x2ce11ed
        .long _standard_library_1405
        .long _standard_library_1408
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1416:
        .long 0x2ce11ed
        .long 2 + 32<<2
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1415:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long _standard_library_1416
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1414:
        .long 0x2ce11ed
        .long _macroexpand_1_79
        .long _standard_library_1415
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1420:
        .long 0xbabb1e
        .long 7
        .ascii "#\\space"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1419:
        .long 0x2ce11ed
        .long _standard_library_1420
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1418:
        .long 0x2ce11ed
        .long _heap_args_14
        .long _standard_library_1419
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1417:
        .long 0x2ce11ed
        .long _standard_library_1418
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1413:
        .long 0x2ce11ed
        .long _standard_library_1414
        .long _standard_library_1417
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1425:
        .long 0x2ce11ed
        .long 2 + 9<<2
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1424:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long _standard_library_1425
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1423:
        .long 0x2ce11ed
        .long _macroexpand_1_79
        .long _standard_library_1424
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1429:
        .long 0xbabb1e
        .long 5
        .ascii "#\\tab"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1428:
        .long 0x2ce11ed
        .long _standard_library_1429
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1427:
        .long 0x2ce11ed
        .long _heap_args_14
        .long _standard_library_1428
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1426:
        .long 0x2ce11ed
        .long _standard_library_1427
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1422:
        .long 0x2ce11ed
        .long _standard_library_1423
        .long _standard_library_1426
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1433:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1432:
        .long 0x2ce11ed
        .long _ensure_character_12
        .long _standard_library_1433
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1437:
        .long 0xbabb1e
        .long 2
        .ascii "#\\"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1436:
        .long 0x2ce11ed
        .long _standard_library_1437
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1435:
        .long 0x2ce11ed
        .long _heap_args_14
        .long _standard_library_1436
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1442:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1441:
        .long 0x2ce11ed
        .long _parse_eofP_54
        .long _standard_library_1442
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1440:
        .long 0x2ce11ed
        .long _standard_library_1441
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1439:
        .long 0x2ce11ed
        .long _heap_args_14
        .long _standard_library_1440
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1438:
        .long 0x2ce11ed
        .long _standard_library_1439
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1434:
        .long 0x2ce11ed
        .long _standard_library_1435
        .long _standard_library_1438
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1431:
        .long 0x2ce11ed
        .long _standard_library_1432
        .long _standard_library_1434
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1448:
        .long 0xbabb1e
        .long 23
        .ascii "don't know how to write"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1449:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1447:
        .long 0x2ce11ed
        .long _standard_library_1448
        .long _standard_library_1449
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1446:
        .long 0x2ce11ed
        .long _standard_library_1040
        .long _standard_library_1447
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1445:
        .long 0x2ce11ed
        .long _standard_library_1446
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1444:
        .long 0x2ce11ed
        .long _macroexpand_1_18
        .long _standard_library_1445
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1443:
        .long 0x2ce11ed
        .long _standard_library_1444
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1430:
        .long 0x2ce11ed
        .long _standard_library_1431
        .long _standard_library_1443
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1421:
        .long 0x2ce11ed
        .long _standard_library_1422
        .long _standard_library_1430
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1412:
        .long 0x2ce11ed
        .long _standard_library_1413
        .long _standard_library_1421
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1403:
        .long 0x2ce11ed
        .long _standard_library_1404
        .long _standard_library_1412
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1394:
        .long 0x2ce11ed
        .long _standard_library_1395
        .long _standard_library_1403
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1385:
        .long 0x2ce11ed
        .long _standard_library_1386
        .long _standard_library_1394
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1376:
        .long 0x2ce11ed
        .long _standard_library_1377
        .long _standard_library_1385
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1367:
        .long 0x2ce11ed
        .long _standard_library_1368
        .long _standard_library_1376
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1349:
        .long 0x2ce11ed
        .long _standard_library_1350
        .long _standard_library_1367
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1340:
        .long 0x2ce11ed
        .long _standard_library_1341
        .long _standard_library_1349
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1339:
        .long 0x2ce11ed
        .long _macroexpand_1_19
        .long _standard_library_1340
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1338:
        .long 0x2ce11ed
        .long _standard_library_1339
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1334:
        .long 0x2ce11ed
        .long _standard_library_1335
        .long _standard_library_1338
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1333:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _standard_library_1334
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1455:
        .long 0x2ce11ed
        .long _standard_library_1456
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1454:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long _standard_library_1455
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1453:
        .long 0x2ce11ed
        .long _standard_library_1346
        .long _standard_library_1454
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1460:
        .long 0xbabb1e
        .long 1
        .ascii "\""
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1459:
        .long 0x2ce11ed
        .long _standard_library_1460
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1458:
        .long 0x2ce11ed
        .long _standard_library_1456
        .long _standard_library_1459
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1466:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1465:
        .long 0x2ce11ed
        .long _standard_library_1298
        .long _standard_library_1466
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1464:
        .long 0x2ce11ed
        .long _standard_library_1465
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1463:
        .long 0x2ce11ed
        .long _standard_library_1456
        .long _standard_library_1464
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1462:
        .long 0x2ce11ed
        .long _standard_library_734
        .long _standard_library_1463
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1470:
        .long 0xbabb1e
        .long 1
        .ascii "\""
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1469:
        .long 0x2ce11ed
        .long _standard_library_1470
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1468:
        .long 0x2ce11ed
        .long _standard_library_1456
        .long _standard_library_1469
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1467:
        .long 0x2ce11ed
        .long _standard_library_1468
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1461:
        .long 0x2ce11ed
        .long _standard_library_1462
        .long _standard_library_1467
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1457:
        .long 0x2ce11ed
        .long _standard_library_1458
        .long _standard_library_1461
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1452:
        .long 0x2ce11ed
        .long _standard_library_1453
        .long _standard_library_1457
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1451:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _standard_library_1452
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1476:
        .long 0x2ce11ed
        .long _standard_library_1456
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1475:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long _standard_library_1476
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1474:
        .long 0x2ce11ed
        .long _standard_library_1364
        .long _standard_library_1475
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1482:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1481:
        .long 0x2ce11ed
        .long _macroexpand_1_85
        .long _standard_library_1482
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1486:
        .long 0xbabb1e
        .long 1
        .ascii ")"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1485:
        .long 0x2ce11ed
        .long _standard_library_1486
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1484:
        .long 0x2ce11ed
        .long _standard_library_1456
        .long _standard_library_1485
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1483:
        .long 0x2ce11ed
        .long _standard_library_1484
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1480:
        .long 0x2ce11ed
        .long _standard_library_1481
        .long _standard_library_1483
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1490:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1489:
        .long 0x2ce11ed
        .long _cons_magic_3
        .long _standard_library_1490
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1495:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1494:
        .long 0x2ce11ed
        .long _inline_primitive_22
        .long _standard_library_1495
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1496:
        .long 0x2ce11ed
        .long _standard_library_1456
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1493:
        .long 0x2ce11ed
        .long _standard_library_1494
        .long _standard_library_1496
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1492:
        .long 0x2ce11ed
        .long _standard_library_1198
        .long _standard_library_1493
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1505:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1504:
        .long 0x2ce11ed
        .long _inline_primitive_25
        .long _standard_library_1505
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1503:
        .long 0x2ce11ed
        .long _standard_library_1504
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1502:
        .long 0x2ce11ed
        .long _macroexpand_1_85
        .long _standard_library_1503
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1501:
        .long 0x2ce11ed
        .long _standard_library_1502
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1500:
        .long 0x2ce11ed
        .long _macroexpand_1_88
        .long _standard_library_1501
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1509:
        .long 0xbabb1e
        .long 1
        .ascii " "
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1508:
        .long 0x2ce11ed
        .long _standard_library_1509
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1507:
        .long 0x2ce11ed
        .long _standard_library_1456
        .long _standard_library_1508
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1506:
        .long 0x2ce11ed
        .long _standard_library_1507
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1499:
        .long 0x2ce11ed
        .long _standard_library_1500
        .long _standard_library_1506
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1498:
        .long 0x2ce11ed
        .long _macroexpand_1_20
        .long _standard_library_1499
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1514:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1513:
        .long 0x2ce11ed
        .long _inline_primitive_25
        .long _standard_library_1514
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1515:
        .long 0x2ce11ed
        .long _standard_library_1456
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1512:
        .long 0x2ce11ed
        .long _standard_library_1513
        .long _standard_library_1515
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1511:
        .long 0x2ce11ed
        .long _standard_library_1364
        .long _standard_library_1512
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1510:
        .long 0x2ce11ed
        .long _standard_library_1511
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1497:
        .long 0x2ce11ed
        .long _standard_library_1498
        .long _standard_library_1510
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1491:
        .long 0x2ce11ed
        .long _standard_library_1492
        .long _standard_library_1497
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1488:
        .long 0x2ce11ed
        .long _standard_library_1489
        .long _standard_library_1491
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1521:
        .long 0xbabb1e
        .long 2
        .ascii ". "
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1520:
        .long 0x2ce11ed
        .long _standard_library_1521
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1519:
        .long 0x2ce11ed
        .long _standard_library_1456
        .long _standard_library_1520
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1525:
        .long 0x2ce11ed
        .long _standard_library_1456
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1524:
        .long 0x2ce11ed
        .long _sample_begin_expr_17
        .long _standard_library_1525
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1523:
        .long 0x2ce11ed
        .long _standard_library_1198
        .long _standard_library_1524
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1529:
        .long 0xbabb1e
        .long 1
        .ascii ")"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1528:
        .long 0x2ce11ed
        .long _standard_library_1529
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1527:
        .long 0x2ce11ed
        .long _standard_library_1456
        .long _standard_library_1528
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1526:
        .long 0x2ce11ed
        .long _standard_library_1527
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1522:
        .long 0x2ce11ed
        .long _standard_library_1523
        .long _standard_library_1526
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1518:
        .long 0x2ce11ed
        .long _standard_library_1519
        .long _standard_library_1522
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1517:
        .long 0x2ce11ed
        .long _macroexpand_1_18
        .long _standard_library_1518
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1516:
        .long 0x2ce11ed
        .long _standard_library_1517
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1487:
        .long 0x2ce11ed
        .long _standard_library_1488
        .long _standard_library_1516
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1479:
        .long 0x2ce11ed
        .long _standard_library_1480
        .long _standard_library_1487
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1478:
        .long 0x2ce11ed
        .long _macroexpand_1_19
        .long _standard_library_1479
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1477:
        .long 0x2ce11ed
        .long _standard_library_1478
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1473:
        .long 0x2ce11ed
        .long _standard_library_1474
        .long _standard_library_1477
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1472:
        .long 0x2ce11ed
        .long _macroexpand_1_27
        .long _standard_library_1473
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1471:
        .long 0x2ce11ed
        .long _standard_library_1472
        .long 2 + 256<<2
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1450:
        .long 0x2ce11ed
        .long _standard_library_1451
        .long _standard_library_1471
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1332:
        .long 0x2ce11ed
        .long _standard_library_1333
        .long _standard_library_1450
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1322:
        .long 0x2ce11ed
        .long _standard_library_1323
        .long _standard_library_1332
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1294:
        .long 0x2ce11ed
        .long _standard_library_1295
        .long _standard_library_1322
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1256:
        .long 0x2ce11ed
        .long _standard_library_1257
        .long _standard_library_1294
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1213:
        .long 0x2ce11ed
        .long _standard_library_1214
        .long _standard_library_1256
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1181:
        .long 0x2ce11ed
        .long _standard_library_1182
        .long _standard_library_1213
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1173:
        .long 0x2ce11ed
        .long _standard_library_1174
        .long _standard_library_1181
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1161:
        .long 0x2ce11ed
        .long _standard_library_1162
        .long _standard_library_1173
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1152:
        .long 0x2ce11ed
        .long _standard_library_1153
        .long _standard_library_1161
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1137:
        .long 0x2ce11ed
        .long _standard_library_1138
        .long _standard_library_1152
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1076:
        .long 0x2ce11ed
        .long _standard_library_1077
        .long _standard_library_1137
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1023:
        .long 0x2ce11ed
        .long _standard_library_1024
        .long _standard_library_1076
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_998:
        .long 0x2ce11ed
        .long _standard_library_999
        .long _standard_library_1023
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_968:
        .long 0x2ce11ed
        .long _standard_library_969
        .long _standard_library_998
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_955:
        .long 0x2ce11ed
        .long _standard_library_956
        .long _standard_library_968
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_936:
        .long 0x2ce11ed
        .long _standard_library_937
        .long _standard_library_955
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_905:
        .long 0x2ce11ed
        .long _standard_library_906
        .long _standard_library_936
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_889:
        .long 0x2ce11ed
        .long _standard_library_890
        .long _standard_library_905
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_881:
        .long 0x2ce11ed
        .long _standard_library_882
        .long _standard_library_889
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_873:
        .long 0x2ce11ed
        .long _standard_library_874
        .long _standard_library_881
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_840:
        .long 0x2ce11ed
        .long _standard_library_841
        .long _standard_library_873
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_823:
        .long 0x2ce11ed
        .long _standard_library_824
        .long _standard_library_840
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_799:
        .long 0x2ce11ed
        .long _standard_library_800
        .long _standard_library_823
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_786:
        .long 0x2ce11ed
        .long _standard_library_787
        .long _standard_library_799
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_758:
        .long 0x2ce11ed
        .long _standard_library_759
        .long _standard_library_786
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_730:
        .long 0x2ce11ed
        .long _standard_library_731
        .long _standard_library_758
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_725:
        .long 0x2ce11ed
        .long _standard_library_726
        .long _standard_library_730
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_708:
        .long 0x2ce11ed
        .long _standard_library_709
        .long _standard_library_725
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_696:
        .long 0x2ce11ed
        .long _standard_library_697
        .long _standard_library_708
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_661:
        .long 0x2ce11ed
        .long _standard_library_662
        .long _standard_library_696
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_639:
        .long 0x2ce11ed
        .long _standard_library_640
        .long _standard_library_661
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_582:
        .long 0x2ce11ed
        .long _standard_library_583
        .long _standard_library_639
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_578:
        .long 0x2ce11ed
        .long _standard_library_579
        .long _standard_library_582
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_573:
        .long 0x2ce11ed
        .long _standard_library_574
        .long _standard_library_578
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_569:
        .long 0x2ce11ed
        .long _standard_library_570
        .long _standard_library_573
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_555:
        .long 0x2ce11ed
        .long _standard_library_556
        .long _standard_library_569
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_543:
        .long 0x2ce11ed
        .long _standard_library_544
        .long _standard_library_555
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_525:
        .long 0x2ce11ed
        .long _standard_library_526
        .long _standard_library_543
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_507:
        .long 0x2ce11ed
        .long _standard_library_508
        .long _standard_library_525
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_490:
        .long 0x2ce11ed
        .long _standard_library_491
        .long _standard_library_507
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_475:
        .long 0x2ce11ed
        .long _standard_library_476
        .long _standard_library_490
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_457:
        .long 0x2ce11ed
        .long _standard_library_458
        .long _standard_library_475
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_412:
        .long 0x2ce11ed
        .long _standard_library_413
        .long _standard_library_457
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_365:
        .long 0x2ce11ed
        .long _standard_library_366
        .long _standard_library_412
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_357:
        .long 0x2ce11ed
        .long _standard_library_358
        .long _standard_library_365
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_349:
        .long 0x2ce11ed
        .long _standard_library_350
        .long _standard_library_357
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_339:
        .long 0x2ce11ed
        .long _standard_library_340
        .long _standard_library_349
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_324:
        .long 0x2ce11ed
        .long _standard_library_325
        .long _standard_library_339
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_309:
        .long 0x2ce11ed
        .long _standard_library_310
        .long _standard_library_324
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_294:
        .long 0x2ce11ed
        .long _standard_library_295
        .long _standard_library_309
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_281:
        .long 0x2ce11ed
        .long _standard_library_282
        .long _standard_library_294
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_268:
        .long 0x2ce11ed
        .long _standard_library_269
        .long _standard_library_281
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_255:
        .long 0x2ce11ed
        .long _standard_library_256
        .long _standard_library_268
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_243:
        .long 0x2ce11ed
        .long _standard_library_244
        .long _standard_library_255
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_232:
        .long 0x2ce11ed
        .long _standard_library_233
        .long _standard_library_243
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_222:
        .long 0x2ce11ed
        .long _standard_library_223
        .long _standard_library_232
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_211:
        .long 0x2ce11ed
        .long _standard_library_212
        .long _standard_library_222
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_200:
        .long 0x2ce11ed
        .long _standard_library_201
        .long _standard_library_211
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_188:
        .long 0x2ce11ed
        .long _standard_library_189
        .long _standard_library_200
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_176:
        .long 0x2ce11ed
        .long _standard_library_177
        .long _standard_library_188
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_149:
        .long 0x2ce11ed
        .long _standard_library_150
        .long _standard_library_176
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_145:
        .long 0x2ce11ed
        .long _standard_library_146
        .long _standard_library_149
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_115:
        .long 0x2ce11ed
        .long _standard_library_116
        .long _standard_library_145
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_80:
        .long 0x2ce11ed
        .long _standard_library_81
        .long _standard_library_115
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_61:
        .long 0x2ce11ed
        .long _standard_library_62
        .long _standard_library_80
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_54:
        .long 0x2ce11ed
        .long _standard_library_55
        .long _standard_library_61
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_46:
        .long 0x2ce11ed
        .long _standard_library_47
        .long _standard_library_54
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_38:
        .long 0x2ce11ed
        .long _standard_library_39
        .long _standard_library_46
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_30:
        .long 0x2ce11ed
        .long _standard_library_31
        .long _standard_library_38
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_22:
        .long 0x2ce11ed
        .long _standard_library_23
        .long _standard_library_30
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_12:
        .long 0x2ce11ed
        .long _standard_library_13
        .long _standard_library_22
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_2:
        .long 0x2ce11ed
        .long _standard_library_3
        .long _standard_library_12
        .text
        push %eax
        movl $_standard_library_2, %eax
        # initialize global variable with value
        movl %eax, (_standard_library_1)
        pop %eax
        .section .data
_compile_program_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _compile_program_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_program_3:
        .long 0xca11ab1e
        .long _compile_program_4
        .long 0
        .text
        .type _compile_program_4, @function
_compile_program_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_program_5:
        .long 0xbabb1e
        .long 12
        .ascii "stack_bottom"
        .text
        push %eax
        movl $_compile_program_5, %eax
        # get procedure
        push %eax
        movl (_indirect_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl (_esp_1), %eax
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_stuff_to_put_in_the_header_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_program_6:
        .long 0xbabb1e
        .long 6
        .ascii "_start"
        .text
        push %eax
        movl $_compile_program_6, %eax
        # get procedure
        push %eax
        movl (_global_label_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_program_7:
        .long 0xbabb1e
        .long 12
        .ascii ".weak _start"
        .text
        push %eax
        movl $_compile_program_7, %eax
        # get procedure
        push %eax
        movl (_insn_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_program_8:
        .long 0xbabb1e
        .long 4
        .ascii "main"
        .text
        push %eax
        movl $_compile_program_8, %eax
        # get procedure
        push %eax
        movl (_global_label_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_ebp_1), %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_program_9:
        .long 0xbabb1e
        .long 8
        .ascii "0x610ba1"
        .text
        push %eax
        movl $_compile_program_9, %eax
        # get procedure
        push %eax
        movl (_const_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_standard_library_1), %eax
        push %eax
        movl (_compile_toplevel_1), %eax
        # get procedure
        push %eax
        movl (_for_each_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_program_10:
        .long 0xbabb1e
        .long 34
        .ascii "(end of standard library prologue)"
        .text
        push %eax
        movl $_compile_program_10, %eax
        # get procedure
        push %eax
        movl (_comment_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl 0(%ebp), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_eax_1), %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_program_11:
        .long 0xbabb1e
        .long 1
        .ascii "1"
        .text
        push %eax
        movl $_compile_program_11, %eax
        # get procedure
        push %eax
        movl (_const_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        push %eax
        movl (_ebx_1), %eax
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_program_12:
        .long 0xbabb1e
        .long 1
        .ascii "0"
        .text
        push %eax
        movl $_compile_program_12, %eax
        # get procedure
        push %eax
        movl (_const_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_mov_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $2, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_syscall_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_emit_symbols_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_assert_no_undefined_global_variables_1), %eax
        # apply procedure
        # Tail call; nargs = 0
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea -4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _compile_program_4, .-_compile_program_4
_compile_program_2:
        push %eax
        movl $_compile_program_3, %eax
        # initialize global variable with value
        movl %eax, (_compile_program_1)
        pop %eax
        .section .data
_read_compile_loop_1:
        .long 2 + 256<<2
        .text
        # compute initial value for global variable
        # jump past the body of the lambda
        jmp _read_compile_loop_2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_3:
        .long 0xca11ab1e
        .long _read_compile_loop_4
        .long 0
        .text
        .type _read_compile_loop_4, @function
_read_compile_loop_4:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $0, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # get procedure
        push %eax
        movl (_current_input_port_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        call *%ebx
        # get procedure
        push %eax
        movl (_read_expr_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        # get procedure
        # jump past the body of the lambda
        jmp _read_compile_loop_5
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_6:
        .long 0xca11ab1e
        .long _read_compile_loop_7
        .long 0
        .text
        .type _read_compile_loop_7, @function
_read_compile_loop_7:
        # compute desired %esp on return in %ebx and push it
        # the extra offset of 4 skips over the return address
        lea 4(%esp,%edx,4), %ebx
        push %ebx
        push %ebp
        lea 12(%esp), %ebp
        cmpl $1, %edx
        jnz argument_count_wrong
        # discarding useless value in %eax
        pop %eax
        # %ifeq
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_eof_objectP_2), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        push %eax
        movl $2 + 258<<2, %eax
        cmpl %eax, (%esp)
        pop %eax
        pop %eax
        jnz _read_compile_loop_8
        push %eax
        movl 0(%ebp), %eax
        # get procedure
        push %eax
        movl (_compile_toplevel_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        # get procedure
        push %eax
        movl (_read_compile_loop_1), %eax
        # apply procedure
        # Tail call; nargs = 0
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea -4(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $0, %edx
        jmp *%ebx
        jmp _read_compile_loop_9
_read_compile_loop_8:
        push %eax
        movl $2 + 258<<2, %eax
_read_compile_loop_9:
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _read_compile_loop_7, .-_read_compile_loop_7
_read_compile_loop_5:
        push %eax
        movl $_read_compile_loop_6, %eax
        # apply procedure
        # Tail call; nargs = 1
        # Note %esp points at the last thing pushed,
        # not the next thing to push.  So for 1 arg, we want %ebx=%esp
        lea 0(%esp), %ebx
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        push 0(%ebx)
        push %edx
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        jmp *%ebx
        # procedure epilogue
        # get return address
        movl -4(%ebp), %edx
        movl -8(%ebp), %esp
        movl -12(%ebp), %ebp
        jmp *%edx
        .size _read_compile_loop_4, .-_read_compile_loop_4
_read_compile_loop_2:
        push %eax
        movl $_read_compile_loop_3, %eax
        # initialize global variable with value
        movl %eax, (_read_compile_loop_1)
        pop %eax
        push %eax
        movl (_read_compile_loop_1), %eax
        # get procedure
        push %eax
        movl (_compile_program_1), %eax
        # apply procedure
        call ensure_procedure
        movl 4(%eax), %ebx
        movl $1, %edx
        call *%ebx
        pop %eax
        movl $1, %eax
        movl $0, %ebx
        int $0x80
        # symbols
        # symbol: pr
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_10:
        .long 0xbabb1e
        .long 2
        .ascii "pr"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1456:
        .long 0x1abe1
        .long _read_compile_loop_10
        .long 0
        # symbol: wlist
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_11:
        .long 0xbabb1e
        .long 5
        .ascii "wlist"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1364:
        .long 0x1abe1
        .long _read_compile_loop_11
        .long _standard_library_1456
        # symbol: wstring
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_12:
        .long 0xbabb1e
        .long 7
        .ascii "wstring"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1346:
        .long 0x1abe1
        .long _read_compile_loop_12
        .long _standard_library_1364
        # symbol: write
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_13:
        .long 0xbabb1e
        .long 5
        .ascii "write"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1326:
        .long 0x1abe1
        .long _read_compile_loop_13
        .long _standard_library_1346
        # symbol: backslash
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_14:
        .long 0xbabb1e
        .long 9
        .ascii "backslash"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1298:
        .long 0x1abe1
        .long _read_compile_loop_14
        .long _standard_library_1326
        # symbol: escape
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_15:
        .long 0xbabb1e
        .long 6
        .ascii "escape"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1260:
        .long 0x1abe1
        .long _read_compile_loop_15
        .long _standard_library_1298
        # symbol: escapes
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_16:
        .long 0xbabb1e
        .long 7
        .ascii "escapes"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1222:
        .long 0x1abe1
        .long _read_compile_loop_16
        .long _standard_library_1260
        # symbol: dangerous
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_17:
        .long 0xbabb1e
        .long 9
        .ascii "dangerous"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1220:
        .long 0x1abe1
        .long _read_compile_loop_17
        .long _standard_library_1222
        # symbol: escape-char
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_18:
        .long 0xbabb1e
        .long 11
        .ascii "escape-char"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1217:
        .long 0x1abe1
        .long _read_compile_loop_18
        .long _standard_library_1220
        # symbol: wthunk
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_19:
        .long 0xbabb1e
        .long 6
        .ascii "wthunk"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1198:
        .long 0x1abe1
        .long _read_compile_loop_19
        .long _standard_library_1217
        # symbol: arg
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_20:
        .long 0xbabb1e
        .long 3
        .ascii "arg"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1195:
        .long 0x1abe1
        .long _read_compile_loop_20
        .long _standard_library_1198
        # symbol: 2*
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_21:
        .long 0xbabb1e
        .long 2
        .ascii "2*"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1150:
        .long 0x1abe1
        .long _read_compile_loop_21
        .long _standard_library_1195
        # symbol: 8*
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_22:
        .long 0xbabb1e
        .long 2
        .ascii "8*"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1146:
        .long 0x1abe1
        .long _read_compile_loop_22
        .long _standard_library_1150
        # symbol: 10*
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_23:
        .long 0xbabb1e
        .long 3
        .ascii "10*"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1127:
        .long 0x1abe1
        .long _read_compile_loop_23
        .long _standard_library_1146
        # symbol: sofar
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_24:
        .long 0xbabb1e
        .long 5
        .ascii "sofar"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1083:
        .long 0x1abe1
        .long _read_compile_loop_24
        .long _standard_library_1127
        # symbol: string->number-2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_25:
        .long 0xbabb1e
        .long 16
        .ascii "string->number-2"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1054:
        .long 0x1abe1
        .long _read_compile_loop_25
        .long _standard_library_1083
        # symbol: error
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_26:
        .long 0xbabb1e
        .long 5
        .ascii "error"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1040:
        .long 0x1abe1
        .long _read_compile_loop_26
        .long _standard_library_1054
        # symbol: str
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_27:
        .long 0xbabb1e
        .long 3
        .ascii "str"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1029:
        .long 0x1abe1
        .long _read_compile_loop_27
        .long _standard_library_1040
        # symbol: string->number
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_28:
        .long 0xbabb1e
        .long 14
        .ascii "string->number"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1027:
        .long 0x1abe1
        .long _read_compile_loop_28
        .long _standard_library_1029
        # symbol: number->string
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_29:
        .long 0xbabb1e
        .long 14
        .ascii "number->string"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_1002:
        .long 0x1abe1
        .long _read_compile_loop_29
        .long _standard_library_1027
        # symbol: num
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_30:
        .long 0xbabb1e
        .long 3
        .ascii "num"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_974:
        .long 0x1abe1
        .long _read_compile_loop_30
        .long _standard_library_1002
        # symbol: number->string-2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_31:
        .long 0xbabb1e
        .long 16
        .ascii "number->string-2"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_972:
        .long 0x1abe1
        .long _read_compile_loop_31
        .long _standard_library_974
        # symbol: string-digit
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_32:
        .long 0xbabb1e
        .long 12
        .ascii "string-digit"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_959:
        .long 0x1abe1
        .long _read_compile_loop_32
        .long _standard_library_972
        # symbol: list->string-2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_33:
        .long 0xbabb1e
        .long 14
        .ascii "list->string-2"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_897:
        .long 0x1abe1
        .long _read_compile_loop_33
        .long _standard_library_959
        # symbol: list->string
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_34:
        .long 0xbabb1e
        .long 12
        .ascii "list->string"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_893:
        .long 0x1abe1
        .long _read_compile_loop_34
        .long _standard_library_897
        # symbol: rest
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_35:
        .long 0xbabb1e
        .long 4
        .ascii "rest"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_848:
        .long 0x1abe1
        .long _read_compile_loop_35
        .long _standard_library_893
        # symbol: n
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_36:
        .long 0xbabb1e
        .long 1
        .ascii "n"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_846:
        .long 0x1abe1
        .long _read_compile_loop_36
        .long _standard_library_848
        # symbol: string->list-2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_37:
        .long 0xbabb1e
        .long 14
        .ascii "string->list-2"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_832:
        .long 0x1abe1
        .long _read_compile_loop_37
        .long _standard_library_846
        # symbol: string
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_38:
        .long 0xbabb1e
        .long 6
        .ascii "string"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_829:
        .long 0x1abe1
        .long _read_compile_loop_38
        .long _standard_library_832
        # symbol: string->list
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_39:
        .long 0xbabb1e
        .long 12
        .ascii "string->list"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_827:
        .long 0x1abe1
        .long _read_compile_loop_39
        .long _standard_library_829
        # symbol: tail
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_40:
        .long 0xbabb1e
        .long 4
        .ascii "tail"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_804:
        .long 0x1abe1
        .long _read_compile_loop_40
        .long _standard_library_827
        # symbol: reverse-plus
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_41:
        .long 0xbabb1e
        .long 12
        .ascii "reverse-plus"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_794:
        .long 0x1abe1
        .long _read_compile_loop_41
        .long _standard_library_804
        # symbol: reverse
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_42:
        .long 0xbabb1e
        .long 7
        .ascii "reverse"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_790:
        .long 0x1abe1
        .long _read_compile_loop_42
        .long _standard_library_794
        # symbol: map
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_43:
        .long 0xbabb1e
        .long 3
        .ascii "map"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_762:
        .long 0x1abe1
        .long _read_compile_loop_43
        .long _standard_library_790
        # symbol: proc
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_44:
        .long 0xbabb1e
        .long 4
        .ascii "proc"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_736:
        .long 0x1abe1
        .long _read_compile_loop_44
        .long _standard_library_762
        # symbol: for-each
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_45:
        .long 0xbabb1e
        .long 8
        .ascii "for-each"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_734:
        .long 0x1abe1
        .long _read_compile_loop_45
        .long _standard_library_736
        # symbol: number?
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_46:
        .long 0xbabb1e
        .long 7
        .ascii "number?"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_728:
        .long 0x1abe1
        .long _read_compile_loop_46
        .long _standard_library_734
        # symbol: boolean?
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_47:
        .long 0xbabb1e
        .long 8
        .ascii "boolean?"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_712:
        .long 0x1abe1
        .long _read_compile_loop_47
        .long _standard_library_728
        # symbol: idx
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_48:
        .long 0xbabb1e
        .long 3
        .ascii "idx"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_668:
        .long 0x1abe1
        .long _read_compile_loop_48
        .long _standard_library_712
        # symbol: string=?-2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_49:
        .long 0xbabb1e
        .long 10
        .ascii "string=?-2"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_657:
        .long 0x1abe1
        .long _read_compile_loop_49
        .long _standard_library_668
        # symbol: string=?
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_50:
        .long 0xbabb1e
        .long 8
        .ascii "string=?"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_608:
        .long 0x1abe1
        .long _read_compile_loop_50
        .long _standard_library_657
        # symbol: equal?
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_51:
        .long 0xbabb1e
        .long 6
        .ascii "equal?"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_586:
        .long 0x1abe1
        .long _read_compile_loop_51
        .long _standard_library_608
        # symbol: char=?
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_52:
        .long 0xbabb1e
        .long 6
        .ascii "char=?"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_576:
        .long 0x1abe1
        .long _read_compile_loop_52
        .long _standard_library_586
        # symbol: char
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_53:
        .long 0xbabb1e
        .long 4
        .ascii "char"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_549:
        .long 0x1abe1
        .long _read_compile_loop_53
        .long _standard_library_576
        # symbol: char-numeric?
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_54:
        .long 0xbabb1e
        .long 13
        .ascii "char-numeric?"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_547:
        .long 0x1abe1
        .long _read_compile_loop_54
        .long _standard_library_549
        # symbol: char-alphabetic?
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_55:
        .long 0xbabb1e
        .long 16
        .ascii "char-alphabetic?"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_529:
        .long 0x1abe1
        .long _read_compile_loop_55
        .long _standard_library_547
        # symbol: char-between?
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_56:
        .long 0xbabb1e
        .long 13
        .ascii "char-between?"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_511:
        .long 0x1abe1
        .long _read_compile_loop_56
        .long _standard_library_529
        # symbol: char<=?
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_57:
        .long 0xbabb1e
        .long 7
        .ascii "char<=?"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_494:
        .long 0x1abe1
        .long _read_compile_loop_57
        .long _standard_library_511
        # symbol: char<?
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_58:
        .long 0xbabb1e
        .long 6
        .ascii "char<?"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_479:
        .long 0x1abe1
        .long _read_compile_loop_58
        .long _standard_library_494
        # symbol: char-whitespace?
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_59:
        .long 0xbabb1e
        .long 16
        .ascii "char-whitespace?"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_461:
        .long 0x1abe1
        .long _read_compile_loop_59
        .long _standard_library_479
        # symbol: destidx
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_60:
        .long 0xbabb1e
        .long 7
        .ascii "destidx"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_425:
        .long 0x1abe1
        .long _read_compile_loop_60
        .long _standard_library_461
        # symbol: dest
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_61:
        .long 0xbabb1e
        .long 4
        .ascii "dest"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_423:
        .long 0x1abe1
        .long _read_compile_loop_61
        .long _standard_library_425
        # symbol: len
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_62:
        .long 0xbabb1e
        .long 3
        .ascii "len"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_421:
        .long 0x1abe1
        .long _read_compile_loop_62
        .long _standard_library_423
        # symbol: srcidx
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_63:
        .long 0xbabb1e
        .long 6
        .ascii "srcidx"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_419:
        .long 0x1abe1
        .long _read_compile_loop_63
        .long _standard_library_421
        # symbol: src
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_64:
        .long 0xbabb1e
        .long 3
        .ascii "src"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_417:
        .long 0x1abe1
        .long _read_compile_loop_64
        .long _standard_library_419
        # symbol: string-blit!
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_65:
        .long 0xbabb1e
        .long 12
        .ascii "string-blit!"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_392:
        .long 0x1abe1
        .long _read_compile_loop_65
        .long _standard_library_417
        # symbol: buf
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_66:
        .long 0xbabb1e
        .long 3
        .ascii "buf"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_379:
        .long 0x1abe1
        .long _read_compile_loop_66
        .long _standard_library_392
        # symbol: s2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_67:
        .long 0xbabb1e
        .long 2
        .ascii "s2"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_373:
        .long 0x1abe1
        .long _read_compile_loop_67
        .long _standard_library_379
        # symbol: s1
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_68:
        .long 0xbabb1e
        .long 2
        .ascii "s1"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_371:
        .long 0x1abe1
        .long _read_compile_loop_68
        .long _standard_library_373
        # symbol: string-append
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_69:
        .long 0xbabb1e
        .long 13
        .ascii "string-append"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_369:
        .long 0x1abe1
        .long _read_compile_loop_69
        .long _standard_library_371
        # symbol: caaadr
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_70:
        .long 0xbabb1e
        .long 6
        .ascii "caaadr"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_328:
        .long 0x1abe1
        .long _read_compile_loop_70
        .long _standard_library_369
        # symbol: cadddr
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_71:
        .long 0xbabb1e
        .long 6
        .ascii "cadddr"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_313:
        .long 0x1abe1
        .long _read_compile_loop_71
        .long _standard_library_328
        # symbol: caddar
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_72:
        .long 0xbabb1e
        .long 6
        .ascii "caddar"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_298:
        .long 0x1abe1
        .long _read_compile_loop_72
        .long _standard_library_313
        # symbol: cadar
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_73:
        .long 0xbabb1e
        .long 5
        .ascii "cadar"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_285:
        .long 0x1abe1
        .long _read_compile_loop_73
        .long _standard_library_298
        # symbol: cdadr
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_74:
        .long 0xbabb1e
        .long 5
        .ascii "cdadr"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_272:
        .long 0x1abe1
        .long _read_compile_loop_74
        .long _standard_library_285
        # symbol: caadr
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_75:
        .long 0xbabb1e
        .long 5
        .ascii "caadr"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_259:
        .long 0x1abe1
        .long _read_compile_loop_75
        .long _standard_library_272
        # symbol: cddr
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_76:
        .long 0xbabb1e
        .long 4
        .ascii "cddr"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_236:
        .long 0x1abe1
        .long _read_compile_loop_76
        .long _standard_library_259
        # symbol: cdar
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_77:
        .long 0xbabb1e
        .long 4
        .ascii "cdar"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_215:
        .long 0x1abe1
        .long _read_compile_loop_77
        .long _standard_library_236
        # symbol: val
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_78:
        .long 0xbabb1e
        .long 3
        .ascii "val"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_205:
        .long 0x1abe1
        .long _read_compile_loop_78
        .long _standard_library_215
        # symbol: append
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_79:
        .long 0xbabb1e
        .long 6
        .ascii "append"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_192:
        .long 0x1abe1
        .long _read_compile_loop_79
        .long _standard_library_205
        # symbol: append2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_80:
        .long 0xbabb1e
        .long 7
        .ascii "append2"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_180:
        .long 0x1abe1
        .long _read_compile_loop_80
        .long _standard_library_192
        # symbol: init
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_81:
        .long 0xbabb1e
        .long 4
        .ascii "init"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_157:
        .long 0x1abe1
        .long _read_compile_loop_81
        .long _standard_library_180
        # symbol: reduce
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_82:
        .long 0xbabb1e
        .long 6
        .ascii "reduce"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_153:
        .long 0x1abe1
        .long _read_compile_loop_82
        .long _standard_library_157
        # symbol: memq
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_83:
        .long 0xbabb1e
        .long 4
        .ascii "memq"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_119:
        .long 0x1abe1
        .long _read_compile_loop_83
        .long _standard_library_153
        # symbol: caar
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_84:
        .long 0xbabb1e
        .long 4
        .ascii "caar"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_102:
        .long 0x1abe1
        .long _read_compile_loop_84
        .long _standard_library_119
        # symbol: alist
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_85:
        .long 0xbabb1e
        .long 5
        .ascii "alist"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_88:
        .long 0x1abe1
        .long _read_compile_loop_85
        .long _standard_library_102
        # symbol: obj
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_86:
        .long 0xbabb1e
        .long 3
        .ascii "obj"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_86:
        .long 0x1abe1
        .long _read_compile_loop_86
        .long _standard_library_88
        # symbol: assq
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_87:
        .long 0xbabb1e
        .long 4
        .ascii "assq"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_84:
        .long 0x1abe1
        .long _read_compile_loop_87
        .long _standard_library_86
        # symbol: length
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_88:
        .long 0xbabb1e
        .long 6
        .ascii "length"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_65:
        .long 0x1abe1
        .long _read_compile_loop_88
        .long _standard_library_84
        # symbol: args
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_89:
        .long 0xbabb1e
        .long 4
        .ascii "args"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_59:
        .long 0x1abe1
        .long _read_compile_loop_89
        .long _standard_library_65
        # symbol: list
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_90:
        .long 0xbabb1e
        .long 4
        .ascii "list"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_standard_library_58:
        .long 0x1abe1
        .long _read_compile_loop_90
        .long _standard_library_59
        # symbol: esp
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_91:
        .long 0xbabb1e
        .long 3
        .ascii "esp"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_83:
        .long 0x1abe1
        .long _read_compile_loop_91
        .long _standard_library_58
        # symbol: ebp
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_92:
        .long 0xbabb1e
        .long 3
        .ascii "ebp"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_80:
        .long 0x1abe1
        .long _read_compile_loop_92
        .long _parse_eofP_83
        # symbol: offset
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_93:
        .long 0xbabb1e
        .long 6
        .ascii "offset"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_78:
        .long 0x1abe1
        .long _read_compile_loop_93
        .long _parse_eofP_80
        # symbol: mov
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_94:
        .long 0xbabb1e
        .long 3
        .ascii "mov"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_75:
        .long 0x1abe1
        .long _read_compile_loop_94
        .long _parse_eofP_78
        # symbol: digit
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_95:
        .long 0xbabb1e
        .long 5
        .ascii "digit"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_60:
        .long 0x1abe1
        .long _read_compile_loop_95
        .long _parse_eofP_75
        # symbol: char->string
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_96:
        .long 0xbabb1e
        .long 12
        .ascii "char->string"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_54:
        .long 0x1abe1
        .long _read_compile_loop_96
        .long _parse_eofP_60
        # symbol: lst
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_97:
        .long 0xbabb1e
        .long 3
        .ascii "lst"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_42:
        .long 0x1abe1
        .long _read_compile_loop_97
        .long _parse_eofP_54
        # symbol: fn
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_98:
        .long 0xbabb1e
        .long 2
        .ascii "fn"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_40:
        .long 0x1abe1
        .long _read_compile_loop_98
        .long _parse_eofP_42
        # symbol: filter
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_99:
        .long 0xbabb1e
        .long 6
        .ascii "filter"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_38:
        .long 0x1abe1
        .long _read_compile_loop_99
        .long _parse_eofP_40
        # symbol: xyz
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_100:
        .long 0xbabb1e
        .long 3
        .ascii "xyz"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_eofP_15:
        .long 0x1abe1
        .long _read_compile_loop_100
        .long _parse_eofP_38
        # symbol: tab
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_101:
        .long 0xbabb1e
        .long 3
        .ascii "tab"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_named_char_18:
        .long 0x1abe1
        .long _read_compile_loop_101
        .long _parse_eofP_15
        # symbol: space
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_102:
        .long 0xbabb1e
        .long 5
        .ascii "space"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_parse_named_char_13:
        .long 0x1abe1
        .long _read_compile_loop_102
        .long _parse_named_char_18
        # symbol: unget
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_103:
        .long 0xbabb1e
        .long 5
        .ascii "unget"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_unget_3:
        .long 0x1abe1
        .long _read_compile_loop_103
        .long _parse_named_char_13
        # symbol: eof-indicator
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_104:
        .long 0xbabb1e
        .long 13
        .ascii "eof-indicator"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_from_string_11:
        .long 0x1abe1
        .long _read_compile_loop_104
        .long _sample_unget_3
        # symbol: new-label
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_105:
        .long 0xbabb1e
        .long 9
        .ascii "new-label"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_285:
        .long 0x1abe1
        .long _read_compile_loop_105
        .long _read_from_string_11
        # symbol: caddr
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_106:
        .long 0xbabb1e
        .long 5
        .ascii "caddr"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_281:
        .long 0x1abe1
        .long _read_compile_loop_106
        .long _totally_macroexpand_285
        # symbol: cadr
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_107:
        .long 0xbabb1e
        .long 4
        .ascii "cadr"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_277:
        .long 0x1abe1
        .long _read_compile_loop_107
        .long _totally_macroexpand_281
        # symbol: rands
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_108:
        .long 0xbabb1e
        .long 5
        .ascii "rands"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_274:
        .long 0x1abe1
        .long _read_compile_loop_108
        .long _totally_macroexpand_277
        # symbol: jump-if-false
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_109:
        .long 0xbabb1e
        .long 13
        .ascii "jump-if-false"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_269:
        .long 0x1abe1
        .long _read_compile_loop_109
        .long _totally_macroexpand_274
        # symbol: env
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_110:
        .long 0xbabb1e
        .long 3
        .ascii "env"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_265:
        .long 0x1abe1
        .long _read_compile_loop_110
        .long _totally_macroexpand_269
        # symbol: compile-expr
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_111:
        .long 0xbabb1e
        .long 12
        .ascii "compile-expr"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_262:
        .long 0x1abe1
        .long _read_compile_loop_111
        .long _totally_macroexpand_265
        # symbol: endlabel
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_112:
        .long 0xbabb1e
        .long 8
        .ascii "endlabel"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_259:
        .long 0x1abe1
        .long _read_compile_loop_112
        .long _totally_macroexpand_262
        # symbol: falselabel
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_113:
        .long 0xbabb1e
        .long 10
        .ascii "falselabel"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_257:
        .long 0x1abe1
        .long _read_compile_loop_113
        .long _totally_macroexpand_259
        # symbol: then
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_114:
        .long 0xbabb1e
        .long 4
        .ascii "then"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_254:
        .long 0x1abe1
        .long _read_compile_loop_114
        .long _totally_macroexpand_257
        # symbol: xxx
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_115:
        .long 0xbabb1e
        .long 3
        .ascii "xxx"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_totally_macroexpand_239:
        .long 0x1abe1
        .long _read_compile_loop_115
        .long _totally_macroexpand_254
        # symbol: not
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_116:
        .long 0xbabb1e
        .long 3
        .ascii "not"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_macroexpand_1_88:
        .long 0x1abe1
        .long _read_compile_loop_116
        .long _totally_macroexpand_239
        # symbol: null?
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_117:
        .long 0xbabb1e
        .long 5
        .ascii "null?"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_macroexpand_1_85:
        .long 0x1abe1
        .long _read_compile_loop_117
        .long _macroexpand_1_88
        # symbol: =
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_118:
        .long 0xbabb1e
        .long 1
        .ascii "="
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_macroexpand_1_82:
        .long 0x1abe1
        .long _read_compile_loop_118
        .long _macroexpand_1_85
        # symbol: eq?
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_119:
        .long 0xbabb1e
        .long 3
        .ascii "eq?"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_macroexpand_1_79:
        .long 0x1abe1
        .long _read_compile_loop_119
        .long _macroexpand_1_82
        # symbol: %if
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_120:
        .long 0xbabb1e
        .long 3
        .ascii "%if"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_macroexpand_1_73:
        .long 0x1abe1
        .long _read_compile_loop_120
        .long _macroexpand_1_79
        # symbol: and
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_121:
        .long 0xbabb1e
        .long 3
        .ascii "and"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_macroexpand_1_63:
        .long 0x1abe1
        .long _read_compile_loop_121
        .long _macroexpand_1_73
        # symbol: or-internal-argument
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_122:
        .long 0xbabb1e
        .long 20
        .ascii "or-internal-argument"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_macroexpand_1_55:
        .long 0x1abe1
        .long _read_compile_loop_122
        .long _macroexpand_1_63
        # symbol: or
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_123:
        .long 0xbabb1e
        .long 2
        .ascii "or"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_macroexpand_1_54:
        .long 0x1abe1
        .long _read_compile_loop_123
        .long _macroexpand_1_55
        # symbol: case-atom-key
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_124:
        .long 0xbabb1e
        .long 13
        .ascii "case-atom-key"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_macroexpand_1_46:
        .long 0x1abe1
        .long _read_compile_loop_124
        .long _macroexpand_1_54
        # symbol: memv
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_125:
        .long 0xbabb1e
        .long 4
        .ascii "memv"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_macroexpand_1_45:
        .long 0x1abe1
        .long _read_compile_loop_125
        .long _macroexpand_1_46
        # symbol: eqv?
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_126:
        .long 0xbabb1e
        .long 4
        .ascii "eqv?"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_macroexpand_1_44:
        .long 0x1abe1
        .long _read_compile_loop_126
        .long _macroexpand_1_45
        # symbol: case
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_127:
        .long 0xbabb1e
        .long 4
        .ascii "case"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_macroexpand_1_41:
        .long 0x1abe1
        .long _read_compile_loop_127
        .long _macroexpand_1_44
        # symbol: let
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_128:
        .long 0xbabb1e
        .long 3
        .ascii "let"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_macroexpand_1_31:
        .long 0x1abe1
        .long _read_compile_loop_128
        .long _macroexpand_1_41
        # symbol: define
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_129:
        .long 0xbabb1e
        .long 6
        .ascii "define"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_macroexpand_1_27:
        .long 0x1abe1
        .long _read_compile_loop_129
        .long _macroexpand_1_31
        # symbol: %define
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_130:
        .long 0xbabb1e
        .long 7
        .ascii "%define"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_macroexpand_1_26:
        .long 0x1abe1
        .long _read_compile_loop_130
        .long _macroexpand_1_27
        # symbol: if
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_131:
        .long 0xbabb1e
        .long 2
        .ascii "if"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_macroexpand_1_20:
        .long 0x1abe1
        .long _read_compile_loop_131
        .long _macroexpand_1_26
        # symbol: cond
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_132:
        .long 0xbabb1e
        .long 4
        .ascii "cond"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_macroexpand_1_19:
        .long 0x1abe1
        .long _read_compile_loop_132
        .long _macroexpand_1_20
        # symbol: else
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_133:
        .long 0xbabb1e
        .long 4
        .ascii "else"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_macroexpand_1_18:
        .long 0x1abe1
        .long _read_compile_loop_133
        .long _macroexpand_1_19
        # symbol: begin
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_134:
        .long 0xbabb1e
        .long 5
        .ascii "begin"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_macroexpand_1_10:
        .long 0x1abe1
        .long _read_compile_loop_134
        .long _macroexpand_1_18
        # symbol: symbol->string
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_135:
        .long 0xbabb1e
        .long 14
        .ascii "symbol->string"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_inline_primitive_37:
        .long 0x1abe1
        .long _read_compile_loop_135
        .long _macroexpand_1_10
        # symbol: string-length
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_136:
        .long 0xbabb1e
        .long 13
        .ascii "string-length"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_inline_primitive_34:
        .long 0x1abe1
        .long _read_compile_loop_136
        .long _inline_primitive_37
        # symbol: char->integer
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_137:
        .long 0xbabb1e
        .long 13
        .ascii "char->integer"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_inline_primitive_31:
        .long 0x1abe1
        .long _read_compile_loop_137
        .long _inline_primitive_34
        # symbol: integer->char
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_138:
        .long 0xbabb1e
        .long 13
        .ascii "integer->char"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_inline_primitive_28:
        .long 0x1abe1
        .long _read_compile_loop_138
        .long _inline_primitive_31
        # symbol: cdr
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_139:
        .long 0xbabb1e
        .long 3
        .ascii "cdr"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_inline_primitive_25:
        .long 0x1abe1
        .long _read_compile_loop_139
        .long _inline_primitive_28
        # symbol: car
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_140:
        .long 0xbabb1e
        .long 3
        .ascii "car"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_inline_primitive_22:
        .long 0x1abe1
        .long _read_compile_loop_140
        .long _inline_primitive_25
        # symbol: 1-
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_141:
        .long 0xbabb1e
        .long 2
        .ascii "1-"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_inline_primitive_19:
        .long 0x1abe1
        .long _read_compile_loop_141
        .long _inline_primitive_22
        # symbol: 1+
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_142:
        .long 0xbabb1e
        .long 2
        .ascii "1+"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_inline_primitive_16:
        .long 0x1abe1
        .long _read_compile_loop_142
        .long _inline_primitive_19
        # symbol: -
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_143:
        .long 0xbabb1e
        .long 1
        .ascii "-"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_inline_primitive_13:
        .long 0x1abe1
        .long _read_compile_loop_143
        .long _inline_primitive_16
        # symbol: +
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_144:
        .long 0xbabb1e
        .long 1
        .ascii "+"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_inline_primitive_10:
        .long 0x1abe1
        .long _read_compile_loop_144
        .long _inline_primitive_13
        # symbol: stack
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_145:
        .long 0xbabb1e
        .long 5
        .ascii "stack"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_get_variable_9:
        .long 0x1abe1
        .long _read_compile_loop_145
        .long _inline_primitive_10
        # symbol: char?
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_146:
        .long 0xbabb1e
        .long 5
        .ascii "char?"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_ensure_character_12:
        .long 0x1abe1
        .long _read_compile_loop_146
        .long _get_variable_9
        # symbol: eof-object?
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_147:
        .long 0xbabb1e
        .long 11
        .ascii "eof-object?"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_eof_value_6:
        .long 0x1abe1
        .long _read_compile_loop_147
        .long _ensure_character_12
        # symbol: <
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_148:
        .long 0xbabb1e
        .long 1
        .ascii "<"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_emit_division_code_24:
        .long 0x1abe1
        .long _read_compile_loop_148
        .long _eof_value_6
        # symbol: quotient
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_149:
        .long 0xbabb1e
        .long 8
        .ascii "quotient"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_emit_division_code_17:
        .long 0x1abe1
        .long _read_compile_loop_149
        .long _emit_division_code_24
        # symbol: remainder
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_150:
        .long 0xbabb1e
        .long 9
        .ascii "remainder"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_emit_division_code_13:
        .long 0x1abe1
        .long _read_compile_loop_150
        .long _emit_division_code_17
        # symbol: integer?
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_151:
        .long 0xbabb1e
        .long 8
        .ascii "integer?"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_integer_tag_6:
        .long 0x1abe1
        .long _read_compile_loop_151
        .long _emit_division_code_13
        # symbol: exit
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_152:
        .long 0xbabb1e
        .long 4
        .ascii "exit"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_write_2_69:
        .long 0x1abe1
        .long _read_compile_loop_152
        .long _integer_tag_6
        # symbol: display-stderr
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_153:
        .long 0xbabb1e
        .long 14
        .ascii "display-stderr"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_write_2_64:
        .long 0x1abe1
        .long _read_compile_loop_153
        .long _write_2_69
        # symbol: read-char
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_154:
        .long 0xbabb1e
        .long 9
        .ascii "read-char"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_write_2_56:
        .long 0x1abe1
        .long _read_compile_loop_154
        .long _write_2_64
        # symbol: current-input-port
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_155:
        .long 0xbabb1e
        .long 18
        .ascii "current-input-port"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_write_2_14:
        .long 0x1abe1
        .long _read_compile_loop_155
        .long _write_2_56
        # symbol: string->symbol
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_156:
        .long 0xbabb1e
        .long 14
        .ascii "string->symbol"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_inline_symbol_Gtstring_30:
        .long 0x1abe1
        .long _read_compile_loop_156
        .long _write_2_14
        # symbol: symbol?
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_157:
        .long 0xbabb1e
        .long 7
        .ascii "symbol?"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_symbol_magic_3:
        .long 0x1abe1
        .long _read_compile_loop_157
        .long _inline_symbol_Gtstring_30
        # symbol: cons
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_158:
        .long 0xbabb1e
        .long 4
        .ascii "cons"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_inline_cdr_13:
        .long 0x1abe1
        .long _read_compile_loop_158
        .long _symbol_magic_3
        # symbol: pair?
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_159:
        .long 0xbabb1e
        .long 5
        .ascii "pair?"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_cons_magic_3:
        .long 0x1abe1
        .long _read_compile_loop_159
        .long _inline_cdr_13
        # symbol: string-ref
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_160:
        .long 0xbabb1e
        .long 10
        .ascii "string-ref"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_check_array_bounds_30:
        .long 0x1abe1
        .long _read_compile_loop_160
        .long _cons_magic_3
        # symbol: string-set!
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_161:
        .long 0xbabb1e
        .long 11
        .ascii "string-set!"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_check_array_bounds_23:
        .long 0x1abe1
        .long _read_compile_loop_161
        .long _check_array_bounds_30
        # symbol: make-string
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_162:
        .long 0xbabb1e
        .long 11
        .ascii "make-string"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_extract_string_15:
        .long 0x1abe1
        .long _read_compile_loop_162
        .long _check_array_bounds_23
        # symbol: string?
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_163:
        .long 0xbabb1e
        .long 7
        .ascii "string?"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_string_magic_3:
        .long 0x1abe1
        .long _read_compile_loop_163
        .long _extract_string_15
        # symbol: newline
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_164:
        .long 0xbabb1e
        .long 7
        .ascii "newline"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_heap_args_22:
        .long 0x1abe1
        .long _read_compile_loop_164
        .long _string_magic_3
        # symbol: message
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_165:
        .long 0xbabb1e
        .long 7
        .ascii "message"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_heap_args_16:
        .long 0x1abe1
        .long _read_compile_loop_165
        .long _heap_args_22
        # symbol: display
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_166:
        .long 0xbabb1e
        .long 7
        .ascii "display"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_heap_args_14:
        .long 0x1abe1
        .long _read_compile_loop_166
        .long _heap_args_16
        # symbol: message2
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_167:
        .long 0xbabb1e
        .long 8
        .ascii "message2"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_heap_args_11:
        .long 0x1abe1
        .long _read_compile_loop_167
        .long _heap_args_14
        # symbol: y
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_168:
        .long 0xbabb1e
        .long 1
        .ascii "y"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_begin_expr_23:
        .long 0x1abe1
        .long _read_compile_loop_168
        .long _heap_args_11
        # symbol: x
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_169:
        .long 0xbabb1e
        .long 1
        .ascii "x"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_begin_expr_17:
        .long 0x1abe1
        .long _read_compile_loop_169
        .long _sample_begin_expr_23
        # symbol: z
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_170:
        .long 0xbabb1e
        .long 1
        .ascii "z"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_begin_expr_10:
        .long 0x1abe1
        .long _read_compile_loop_170
        .long _sample_begin_expr_17
        # symbol: bar
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_171:
        .long 0xbabb1e
        .long 3
        .ascii "bar"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_quoted_expr_4:
        .long 0x1abe1
        .long _read_compile_loop_171
        .long _sample_begin_expr_10
        # symbol: whatever
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_172:
        .long 0xbabb1e
        .long 8
        .ascii "whatever"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_inner_lambda_2_13:
        .long 0x1abe1
        .long _read_compile_loop_172
        .long _sample_quoted_expr_4
        # symbol: foo
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_173:
        .long 0xbabb1e
        .long 3
        .ascii "foo"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_closure_expression_20:
        .long 0x1abe1
        .long _read_compile_loop_173
        .long _sample_inner_lambda_2_13
        # symbol: f
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_174:
        .long 0xbabb1e
        .long 1
        .ascii "f"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_closure_expression_17:
        .long 0x1abe1
        .long _read_compile_loop_174
        .long _sample_closure_expression_20
        # symbol: e
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_175:
        .long 0xbabb1e
        .long 1
        .ascii "e"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_closure_expression_15:
        .long 0x1abe1
        .long _read_compile_loop_175
        .long _sample_closure_expression_17
        # symbol: heap-pointer
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_176:
        .long 0xbabb1e
        .long 12
        .ascii "heap-pointer"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_compile_heap_args_2_11:
        .long 0x1abe1
        .long _read_compile_loop_176
        .long _sample_closure_expression_15
        # symbol: set!
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_177:
        .long 0xbabb1e
        .long 4
        .ascii "set!"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_free_vars_23:
        .long 0x1abe1
        .long _read_compile_loop_177
        .long _compile_heap_args_2_11
        # symbol: quote
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_178:
        .long 0xbabb1e
        .long 5
        .ascii "quote"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_free_vars_20:
        .long 0x1abe1
        .long _read_compile_loop_178
        .long _free_vars_23
        # symbol: %ifeq
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_179:
        .long 0xbabb1e
        .long 5
        .ascii "%ifeq"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_free_vars_17:
        .long 0x1abe1
        .long _read_compile_loop_179
        .long _free_vars_20
        # symbol: %begin
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_180:
        .long 0xbabb1e
        .long 6
        .ascii "%begin"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_free_vars_15:
        .long 0x1abe1
        .long _read_compile_loop_180
        .long _free_vars_17
        # symbol: lambda
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_181:
        .long 0xbabb1e
        .long 6
        .ascii "lambda"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_lambdas_8:
        .long 0x1abe1
        .long _read_compile_loop_181
        .long _free_vars_15
        # symbol: set-equal
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_182:
        .long 0xbabb1e
        .long 9
        .ascii "set-equal"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_assert_set_equal_5:
        .long 0x1abe1
        .long _read_compile_loop_182
        .long _lambdas_8
        # symbol: d
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_183:
        .long 0xbabb1e
        .long 1
        .ascii "d"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_abcd_6:
        .long 0x1abe1
        .long _read_compile_loop_183
        .long _assert_set_equal_5
        # symbol: c
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_184:
        .long 0xbabb1e
        .long 1
        .ascii "c"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_sample_abcd_4:
        .long 0x1abe1
        .long _read_compile_loop_184
        .long _sample_abcd_6
        # symbol: b
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_185:
        .long 0xbabb1e
        .long 1
        .ascii "b"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_union_all_12:
        .long 0x1abe1
        .long _read_compile_loop_185
        .long _sample_abcd_4
        # symbol: a
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_186:
        .long 0xbabb1e
        .long 1
        .ascii "a"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_set_union_all_8:
        .long 0x1abe1
        .long _read_compile_loop_186
        .long _set_union_all_12
        # symbol: procedure?
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_read_compile_loop_187:
        .long 0xbabb1e
        .long 10
        .ascii "procedure?"
        .text
        .section .rodata
        # align pointers so they end in binary 00
        .align 4
_define_magic_check_primitive_9:
        .long 0x1abe1
        .long _read_compile_loop_187
        .long _set_union_all_8
        .section .data
symbol_table:
        .long _define_magic_check_primitive_9
